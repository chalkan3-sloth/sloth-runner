package scaffolding

// basicWorkflowTemplate is the template for a basic workflow
const basicWorkflowTemplate = `-- {{.WorkflowName}} - Basic Workflow
-- Generated by Sloth Runner Scaffolder
-- Created: {{.CreatedAt}}
-- Author: {{.Author}}

-- Basic task using Modern DSL
local main_task = task("{{.WorkflowName}}_main")
    :description("{{.Description}}")
    :command(function(params, deps)
        log.info("üöÄ Executing {{.WorkflowName}} workflow...")
        
        -- TODO: Add your implementation here
        -- Example:
        -- local result = exec.run("echo 'Hello from {{.WorkflowName}}'")
        -- return result.success, result.stdout, { message = "Task completed" }
        
        return true, "Task completed successfully", {
            task_name = "{{.WorkflowName}}_main",
            execution_time = os.time(),
            status = "success",
            message = "{{.Description}}"
        }
    end)
    :timeout("5m")
    :retries(2, "exponential")
    :on_success(function(params, output)
        log.info("‚úÖ {{.WorkflowName}} task completed successfully")
    end)
    :on_failure(function(params, error)
        log.error("‚ùå {{.WorkflowName}} task failed: " .. error)
    end)
    :build()

-- Workflow Definition
workflow.define("{{.WorkflowName}}", {
    description = "{{.Description}}",
    version = "{{.Version}}",
    
    metadata = {
        author = "{{.Author}}",
        category = "{{.Category}}",
        complexity = "{{.Complexity}}",
        tags = {"{{.WorkflowName}}", "basic", "generated"},
        created_at = "{{.CreatedAt}}"
    },
    
    tasks = { main_task },
    
    config = {
        timeout = "10m",
        max_parallel_tasks = 1,
        retry_policy = "exponential"
    },
    
    on_complete = function(success, results)
        if success then
            log.info("üéâ {{.WorkflowName}} workflow completed successfully!")
        else
            log.error("‚ùå {{.WorkflowName}} workflow failed")
        end
        return true
    end
})`

// cicdWorkflowTemplate is the template for a CI/CD pipeline
const cicdWorkflowTemplate = `-- {{.WorkflowName}} - CI/CD Pipeline
-- Generated by Sloth Runner Scaffolder
-- Created: {{.CreatedAt}}
-- Author: {{.Author}}

-- Build task
local build_task = task("build")
    :description("Build the application")
    :command(function(params, deps)
        log.info("üî® Building application...")
        
        -- TODO: Replace with your build command
        local result = exec.run("echo 'Building application...' && sleep 2")
        
        if result.success then
            return true, result.stdout, {
                build_status = "success",
                build_time = os.time(),
                artifacts = {"app", "dist/"}
            }
        else
            return false, result.stderr
        end
    end)
    :timeout("10m")
    :artifacts({"app", "dist/"})
    :build()

-- Test task
local test_task = task("test")
    :description("Run tests")
    :depends_on({"build"})
    :command(function(params, deps)
        log.info("üß™ Running tests...")
        
        -- TODO: Replace with your test command
        local result = exec.run("echo 'Running tests...' && sleep 3")
        
        if result.success then
            return true, result.stdout, {
                test_status = "passed",
                test_count = 42,
                coverage = "95%"
            }
        else
            return false, result.stderr
        end
    end)
    :timeout("15m")
    :build()

-- Deploy task
local deploy_task = task("deploy")
    :description("Deploy to production")
    :depends_on({"test"})
    :run_if(function(params, deps)
        return deps.test.test_status == "passed"
    end)
    :command(function(params, deps)
        log.info("üöÄ Deploying to production...")
        
        -- TODO: Replace with your deployment command
        local result = exec.run("echo 'Deploying application...' && sleep 2")
        
        if result.success then
            return true, result.stdout, {
                deployment_status = "success",
                deployment_url = "https://{{.WorkflowName}}.example.com",
                version = "v1.0.0"
            }
        else
            return false, result.stderr
        end
    end)
    :timeout("10m")
    :on_failure(function(params, error)
        log.error("‚ùå Deployment failed, consider rollback")
    end)
    :build()

-- Workflow Definition
workflow.define("{{.WorkflowName}}", {
    description = "{{.Description}}",
    version = "{{.Version}}",
    
    metadata = {
        author = "{{.Author}}",
        category = "{{.Category}}",
        complexity = "{{.Complexity}}",
        tags = {"{{.WorkflowName}}", "cicd", "devops", "pipeline"},
        created_at = "{{.CreatedAt}}"
    },
    
    tasks = { build_task, test_task, deploy_task },
    
    config = {
        timeout = "45m",
        max_parallel_tasks = 2,
        fail_fast = true
    },
    
    on_complete = function(success, results)
        if success then
            log.info("üéâ CI/CD Pipeline completed successfully!")
            -- TODO: Add notification logic (Slack, email, etc.)
        else
            log.error("‚ùå CI/CD Pipeline failed!")
        end
        return true
    end
})`

// infrastructureWorkflowTemplate is the template for infrastructure deployment
const infrastructureWorkflowTemplate = `-- {{.WorkflowName}} - Infrastructure Deployment
-- Generated by Sloth Runner Scaffolder
-- Created: {{.CreatedAt}}
-- Author: {{.Author}}

-- Plan infrastructure task
local plan_task = task("plan")
    :description("Plan infrastructure changes")
    :command(function(params, deps)
        log.info("üìã Planning infrastructure changes...")
        
        -- TODO: Replace with your IaC tool (Terraform, Pulumi, etc.)
        local result = exec.run("echo 'Planning infrastructure...' && sleep 2")
        
        if result.success then
            return true, result.stdout, {
                plan_status = "success",
                changes = {
                    add = 5,
                    change = 2,
                    destroy = 0
                }
            }
        else
            return false, result.stderr
        end
    end)
    :timeout("10m")
    :build()

-- Apply infrastructure task
local apply_task = task("apply")
    :description("Apply infrastructure changes")
    :depends_on({"plan"})
    :run_if(function(params, deps)
        return deps.plan.plan_status == "success"
    end)
    :command(function(params, deps)
        log.info("üèóÔ∏è Applying infrastructure changes...")
        
        -- TODO: Replace with your apply command
        local result = exec.run("echo 'Applying infrastructure...' && sleep 5")
        
        if result.success then
            return true, result.stdout, {
                apply_status = "success",
                resources_created = 5,
                resources_updated = 2
            }
        else
            return false, result.stderr
        end
    end)
    :timeout("30m")
    :build()

-- Validate infrastructure task
local validate_task = task("validate")
    :description("Validate deployed infrastructure")
    :depends_on({"apply"})
    :command(function(params, deps)
        log.info("‚úÖ Validating infrastructure...")
        
        -- TODO: Add validation checks
        local result = exec.run("echo 'Validating infrastructure...' && sleep 1")
        
        if result.success then
            return true, result.stdout, {
                validation_status = "passed",
                health_checks = "all_passed"
            }
        else
            return false, result.stderr
        end
    end)
    :timeout("5m")
    :build()

-- Workflow Definition
workflow.define("{{.WorkflowName}}", {
    description = "{{.Description}}",
    version = "{{.Version}}",
    
    metadata = {
        author = "{{.Author}}",
        category = "{{.Category}}",
        complexity = "{{.Complexity}}",
        tags = {"{{.WorkflowName}}", "infrastructure", "iac", "terraform"},
        created_at = "{{.CreatedAt}}"
    },
    
    tasks = { plan_task, apply_task, validate_task },
    
    config = {
        timeout = "60m",
        max_parallel_tasks = 1,
        fail_fast = true
    },
    
    on_complete = function(success, results)
        if success then
            log.info("üéâ Infrastructure deployment completed successfully!")
        else
            log.error("‚ùå Infrastructure deployment failed!")
        end
        return true
    end
})`

// microservicesWorkflowTemplate is the template for microservices deployment
const microservicesWorkflowTemplate = `-- {{.WorkflowName}} - Microservices Deployment
-- Generated by Sloth Runner Scaffolder
-- Created: {{.CreatedAt}}
-- Author: {{.Author}}

-- Build services task
local build_services = task("build_services")
    :description("Build all microservices")
    :command(function(params, deps)
        log.info("üî® Building microservices...")
        
        -- TODO: Add your build logic for multiple services
        local services = {"auth-service", "user-service", "order-service"}
        local results = {}
        
        for _, service in ipairs(services) do
            log.info("Building " .. service .. "...")
            -- local result = exec.run("docker build -t " .. service .. " ./" .. service)
            results[service] = "success"
        end
        
        return true, "All services built successfully", {
            services_built = services,
            build_time = os.time()
        }
    end)
    :timeout("20m")
    :build()

-- Deploy to staging task
local deploy_staging = task("deploy_staging")
    :description("Deploy to staging environment")
    :depends_on({"build_services"})
    :command(function(params, deps)
        log.info("üöÄ Deploying to staging...")
        
        -- TODO: Add your staging deployment logic
        local result = exec.run("echo 'Deploying to staging...' && sleep 3")
        
        if result.success then
            return true, result.stdout, {
                environment = "staging",
                deployment_status = "success",
                endpoints = {
                    auth = "https://auth-staging.example.com",
                    user = "https://user-staging.example.com",
                    order = "https://order-staging.example.com"
                }
            }
        else
            return false, result.stderr
        end
    end)
    :timeout("15m")
    :build()

-- Run integration tests task
local integration_tests = task("integration_tests")
    :description("Run integration tests")
    :depends_on({"deploy_staging"})
    :command(function(params, deps)
        log.info("üß™ Running integration tests...")
        
        -- TODO: Add your integration test logic
        local result = exec.run("echo 'Running integration tests...' && sleep 4")
        
        if result.success then
            return true, result.stdout, {
                test_status = "passed",
                test_suite = "integration",
                tests_run = 156,
                tests_passed = 156
            }
        else
            return false, result.stderr
        end
    end)
    :timeout("20m")
    :build()

-- Deploy to production task
local deploy_production = task("deploy_production")
    :description("Deploy to production environment")
    :depends_on({"integration_tests"})
    :run_if(function(params, deps)
        return deps.integration_tests.test_status == "passed"
    end)
    :command(function(params, deps)
        log.info("üåê Deploying to production...")
        
        -- TODO: Add your production deployment logic
        local result = exec.run("echo 'Deploying to production...' && sleep 5")
        
        if result.success then
            return true, result.stdout, {
                environment = "production",
                deployment_status = "success",
                endpoints = {
                    auth = "https://auth.example.com",
                    user = "https://user.example.com",
                    order = "https://order.example.com"
                }
            }
        else
            return false, result.stderr
        end
    end)
    :timeout("15m")
    :on_failure(function(params, error)
        log.error("‚ùå Production deployment failed, initiating rollback")
    end)
    :build()

-- Workflow Definition
workflow.define("{{.WorkflowName}}", {
    description = "{{.Description}}",
    version = "{{.Version}}",
    
    metadata = {
        author = "{{.Author}}",
        category = "{{.Category}}",
        complexity = "{{.Complexity}}",
        tags = {"{{.WorkflowName}}", "microservices", "kubernetes", "docker"},
        created_at = "{{.CreatedAt}}"
    },
    
    tasks = { build_services, deploy_staging, integration_tests, deploy_production },
    
    config = {
        timeout = "90m",
        max_parallel_tasks = 3,
        fail_fast = false
    },
    
    on_complete = function(success, results)
        if success then
            log.info("üéâ Microservices deployment completed successfully!")
        else
            log.error("‚ùå Microservices deployment failed!")
        end
        return true
    end
})`

// dataPipelineWorkflowTemplate is the template for data processing pipeline
const dataPipelineWorkflowTemplate = `-- {{.WorkflowName}} - Data Processing Pipeline
-- Generated by Sloth Runner Scaffolder
-- Created: {{.CreatedAt}}
-- Author: {{.Author}}

-- Extract data task
local extract_data = task("extract_data")
    :description("Extract data from sources")
    :command(function(params, deps)
        log.info("üì• Extracting data from sources...")
        
        -- TODO: Add your data extraction logic
        local result = exec.run("echo 'Extracting data...' && sleep 3")
        
        if result.success then
            return true, result.stdout, {
                extraction_status = "success",
                records_extracted = 10000,
                sources = {"database", "api", "files"}
            }
        else
            return false, result.stderr
        end
    end)
    :timeout("30m")
    :build()

-- Transform data task
local transform_data = task("transform_data")
    :description("Transform and clean data")
    :depends_on({"extract_data"})
    :command(function(params, deps)
        log.info("üîÑ Transforming data...")
        
        -- TODO: Add your data transformation logic
        local result = exec.run("echo 'Transforming data...' && sleep 5")
        
        if result.success then
            return true, result.stdout, {
                transformation_status = "success",
                records_processed = deps.extract_data.records_extracted,
                quality_score = "98.5%"
            }
        else
            return false, result.stderr
        end
    end)
    :timeout("45m")
    :build()

-- Load data task
local load_data = task("load_data")
    :description("Load data to destination")
    :depends_on({"transform_data"})
    :command(function(params, deps)
        log.info("üì§ Loading data to destination...")
        
        -- TODO: Add your data loading logic
        local result = exec.run("echo 'Loading data...' && sleep 2")
        
        if result.success then
            return true, result.stdout, {
                load_status = "success",
                records_loaded = deps.transform_data.records_processed,
                destination = "data_warehouse"
            }
        else
            return false, result.stderr
        end
    end)
    :timeout("20m")
    :build()

-- Validate data task
local validate_data = task("validate_data")
    :description("Validate loaded data")
    :depends_on({"load_data"})
    :command(function(params, deps)
        log.info("‚úÖ Validating data quality...")
        
        -- TODO: Add your data validation logic
        local result = exec.run("echo 'Validating data...' && sleep 1")
        
        if result.success then
            return true, result.stdout, {
                validation_status = "passed",
                data_quality = "excellent",
                completeness = "100%"
            }
        else
            return false, result.stderr
        end
    end)
    :timeout("10m")
    :build()

-- Workflow Definition
workflow.define("{{.WorkflowName}}", {
    description = "{{.Description}}",
    version = "{{.Version}}",
    
    metadata = {
        author = "{{.Author}}",
        category = "{{.Category}}",
        complexity = "{{.Complexity}}",
        tags = {"{{.WorkflowName}}", "data", "etl", "pipeline"},
        created_at = "{{.CreatedAt}}"
    },
    
    tasks = { extract_data, transform_data, load_data, validate_data },
    
    config = {
        timeout = "120m",
        max_parallel_tasks = 2,
        retry_policy = "exponential"
    },
    
    on_complete = function(success, results)
        if success then
            log.info("üéâ Data pipeline completed successfully!")
        else
            log.error("‚ùå Data pipeline failed!")
        end
        return true
    end
})`

// readmeTemplate is the template for README.md
const readmeTemplate = `# %s

%s

## Overview

This workflow was generated using the Sloth Runner Scaffolder.

**Author:** %s  
**Created:** %s

## Usage

Run the workflow:

` + "```bash" + `
sloth-runner run -f %s.lua
` + "```" + `

## Customization

Edit the %s.lua file to customize the workflow according to your needs:

1. Update task commands with your actual implementation
2. Modify task dependencies as needed
3. Add additional tasks if required
4. Configure timeouts and retry policies

## Documentation

- [Sloth Runner Documentation](https://github.com/chalkan3-sloth/sloth-runner/docs)
- [Modern DSL Reference](https://github.com/chalkan3-sloth/sloth-runner/docs/LUA_API.md)
- [Examples](https://github.com/chalkan3-sloth/sloth-runner/examples)

## Support

For issues and questions:
- [GitHub Issues](https://github.com/chalkan3-sloth/sloth-runner/issues)
- [Discussions](https://github.com/chalkan3-sloth/sloth-runner/discussions)
`

// gitignoreTemplate is the template for .gitignore
const gitignoreTemplate = `# Sloth Runner artifacts
.sloth-cache/
*.log
sloth-runner-*.pid

# Build artifacts
dist/
build/
target/

# Dependencies
node_modules/
vendor/

# Environment files
.env
.env.local

# IDE files
.vscode/
.idea/
*.swp
*.swo

# OS files
.DS_Store
Thumbs.db

# Temporary files
*.tmp
*.temp
`

// configTemplate is the template for sloth-runner.yaml
const configTemplate = `# Sloth Runner Configuration
# Project: %s

project:
  name: "%s"
  description: "%s"
  version: "%s"

# Default settings
defaults:
  timeout: "30m"
  retry_policy: "exponential"
  max_parallel_tasks: 3

# Logging configuration
logging:
  level: "info"
  format: "json"

# Output configuration
output:
  style: "pulumi"  # pulumi, basic, json
  show_outputs: true
  capture_artifacts: true

# Agent configuration (for distributed execution)
agent:
  master_address: "localhost:50053"
  heartbeat_interval: "5s"

# State management
state:
  backend: "sqlite"
  file: ".sloth-runner/state.db"
`