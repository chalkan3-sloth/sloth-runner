diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
new file mode 100644
index 0000000..6d9a7a8
--- /dev/null
+++ b/.github/workflows/ci.yml
@@ -0,0 +1,154 @@
+name: CI
+
+on:
+  push:
+    branches: [ master ]
+  pull_request:
+    branches: [ master ]
+
+jobs:
+  setup:
+    name: Setup
+    runs-on: ubuntu-latest
+    steps:
+      - name: Install Git
+        run: |
+          sudo apt-get update
+          sudo apt-get install -y git
+  lint-and-format:
+    name: Lint and Format
+    runs-on: ubuntu-latest
+    needs: setup
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+      - name: Set up Go
+        uses: actions/setup-go@v5
+        with:
+          go-version: '1.25.1'
+      - name: Cache Go modules
+        uses: actions/cache@v4
+        with:
+          path: ~/go/pkg/mod
+          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
+          restore-keys: |
+            ${{ runner.os }}-go-
+      - name: Install dependencies
+        run: go mod tidy
+        env:
+          GOPROXY: "direct"
+      - name: Run linter
+        run: |
+          curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v1.55.2
+          $(go env GOPATH)/bin/golangci-lint run ./...
+
+  test:
+    name: Test
+    runs-on: ubuntu-latest
+    needs: setup
+    steps:
+        - name: Checkout
+          uses: actions/checkout@v4
+        - name: Set up Go
+          uses: actions/setup-go@v5
+          with:
+            go-version: '1.25.1'
+        - name: Cache Go modules
+          uses: actions/cache@v4
+          with:
+            path: ~/go/pkg/mod
+            key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
+            restore-keys: |
+              ${{ runner.os }}-go-
+        - name: Install dependencies
+          run: go mod tidy
+          env:
+            GOPROXY: "direct"
+        - name: Run tests with coverage
+          run: go test -v ./... -coverprofile=coverage.out
+        - name: Upload coverage report
+          uses: actions/upload-artifact@v4
+          with:
+            name: coverage-report
+  security-scan:
+    name: Security Scan
+    runs-on: ubuntu-latest
+    needs: setup
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+      - name: Set up Go
+        uses: actions/setup-go@v5
+        with:
+          go-version: '1.25.1'
+      - name: Cache Go modules
+        uses: actions/cache@v4
+        with:
+          path: ~/go/pkg/mod
+          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
+          restore-keys: |
+            ${{ runner.os }}-go-
+      - name: Install dependencies
+        run: go mod tidy
+        env:
+          GOPROXY: "direct"
+      - name: Install govulncheck
+        run: go install golang.org/x/vuln/cmd/govulncheck@latest
+      - name: Run govulncheck
+        run: $(go env GOPATH)/bin/govulncheck ./...
+
+  build:
+    name: Build
+    runs-on: ubuntu-latest
+    needs: setup
+    strategy:
+      matrix:
+        goos: [linux, windows, darwin]
+        goarch: [amd64, arm64]
+        exclude:
+          - goos: windows
+            goarch: arm64
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+      - name: Set up Go
+        uses: actions/setup-go@v5
+        with:
+          go-version: '1.25.1'
+      - name: Cache Go modules
+        uses: actions/cache@v4
+        with:
+          path: ~/go/pkg/mod
+          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
+          restore-keys: |
+            ${{ runner.os }}-go-
+      - name: Install dependencies
+        run: go mod tidy
+        env:
+          GOPROXY: "direct"
+      - name: Build
+        run: |
+          GOOS=${{ matrix.goos }} GOARCH=${{ matrix.goarch }} go build -v ./cmd/sloth-runner
+
+  changelog:
+    name: Changelog
+    runs-on: ubuntu-latest
+    needs: setup
+    if: github.event_name == 'pull_request'
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+        with:
+          fetch-depth: 0
+      - name: Set up Go
+        uses: actions/setup-go@v5
+        with:
+          go-version: '1.25.1'
+      - name: Run GoReleaser for changelog
+        uses: goreleaser/goreleaser-action@v5
+        with:
+          version: '~> v2'
+          args: release --snapshot --clean
+        env:
+          GOPROXY: "direct"
+          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
diff --git a/.github/workflows/go.yml b/.github/workflows/go.yml
deleted file mode 100644
index aacf446..0000000
--- a/.github/workflows/go.yml
+++ /dev/null
@@ -1,45 +0,0 @@
-name: Go CI
-
-on:
-  push:
-    branches: [ master ]
-  pull_request:
-    branches: [ master ]
-
-jobs:
-  build-and-test:
-    runs-on: ubuntu-latest
-    steps:
-    - uses: actions/checkout@v3
-
-    - name: Set up Go
-      uses: actions/setup-go@v4
-      with:
-        go-version: '1.21'
-
-    - name: Install dependencies
-      run: go mod tidy
-
-    - name: Test
-      run: go test -v ./...
-
-  release:
-    needs: build-and-test
-    if: github.event_name == 'push' && github.ref == 'refs/heads/master'
-    runs-on: ubuntu-latest
-    steps:
-      - name: Checkout
-        uses: actions/checkout@v3
-        with:
-          fetch-depth: 0
-      - name: Set up Go
-        uses: actions/setup-go@v4
-        with:
-          go-version: '1.21'
-      - name: Run GoReleaser
-        uses: goreleaser/goreleaser-action@v2
-        with:
-          version: latest
-          args: release --clean
-        env:
-          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
\ No newline at end of file
diff --git a/.github/workflows/release.yml b/.github/workflows/release.yml
new file mode 100644
index 0000000..f1d7fdb
--- /dev/null
+++ b/.github/workflows/release.yml
@@ -0,0 +1,34 @@
+name: Release
+
+on:
+  push:
+    tags:
+      - 'v*'
+
+jobs:
+  release:
+    name: Release
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+        with:
+          fetch-depth: 0
+      - name: Set up Go
+        uses: actions/setup-go@v5
+        with:
+          go-version: '1.25.1'
+      - name: Cache Go modules
+        uses: actions/cache@v4
+        with:
+          path: ~/go/pkg/mod
+          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
+          restore-keys: |
+            ${{ runner.os }}-go-
+      - name: Run GoReleaser
+        uses: goreleaser/goreleaser-action@v5
+        with:
+          version: '~> v2'
+          args: release --clean
+        env:
+          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
diff --git a/.github/workflows/tag-on-merge.yml b/.github/workflows/tag-on-merge.yml
new file mode 100644
index 0000000..d5ef948
--- /dev/null
+++ b/.github/workflows/tag-on-merge.yml
@@ -0,0 +1,23 @@
+name: Create Tag on Merge
+
+on:
+  push:
+    branches:
+      - master
+
+jobs:
+  create-tag:
+    name: Create Tag
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+        with:
+          fetch-depth: 0 # Required to fetch all history for correct versioning
+
+      - name: Bump version and push tag
+        uses: anothrNick/github-tag-action@1.67.0
+        env:
+          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
+          DEFAULT_BUMP: patch # Automatically increments the patch version (e.g., v1.0.0 -> v1.0.1)
+          WITH_V: true # Ensures the tag is created with a 'v' prefix (e.g., v1.0.1)
diff --git a/cmd/sloth-runner/main.go b/cmd/sloth-runner/main.go
index a88f143..ebe34e4 100644
--- a/cmd/sloth-runner/main.go
+++ b/cmd/sloth-runner/main.go
@@ -8,20 +8,287 @@ import (
 	"os"
 	"strconv"
 	"strings"
+	"text/tabwriter"
 	"text/template"
 
 	"github.com/AlecAivazis/survey/v2"
-	lua "github.com/yuin/gopher-lua"
-
 	"github.com/spf13/cobra"
+	"gopkg.in/yaml.v2"
 
 	"github.com/chalkan3/sloth-runner/internal/luainterface"
 	"github.com/chalkan3/sloth-runner/internal/taskrunner"
 	"github.com/chalkan3/sloth-runner/internal/types"
-	"gopkg.in/yaml.v2" // Added for YAML parsing
+	lua "github.com/yuin/gopher-lua"
 )
 
-// TemplateData struct to hold data passed to the Go template
+// --- Início: Definição Centralizada de Templates ---
+
+// Template defines a structure for a scaffolding template.
+type Template struct {
+	Name        string
+	Description string
+	Content     string
+}
+
+// templateRegistry is the single source of truth for all available templates.
+var templateRegistry = map[string]Template{
+	"simple": {
+		Name:        "simple",
+		Description: "Generates a single group with a 'hello world' task. Ideal for getting started.",
+		Content: `
+-- Task definitions for group: {{.GroupName}}
+-- Generated by: sloth-runner new (template: simple)
+TaskDefinitions = {
+  ["{{.GroupName}}"] = {
+    description = "TODO: Add a description for the {{.GroupName}} task group.",
+    tasks = {
+      {
+        name = "hello_task",
+        description = "An example task. Modify or add new tasks here.",
+        command = function(params)
+          local workdir = params.workdir
+          log.info("Running example task for group {{.GroupName}} in: " .. workdir)
+          local stdout, stderr, err = exec.command("echo 'Hello from sloth-runner!'")
+          if err then
+            log.error("Failed to run example task: " .. stderr)
+            return false, "Dummy task failed."
+          else
+            log.info("Example task completed successfully.")
+            print("Command output: " .. stdout)
+            return true, "Dummy task executed successfully."
+          end
+        end
+      }
+    }
+  }
+}
+`,
+	},
+	"python": {
+		Name:        "python",
+		Description: "Creates a pipeline to set up a Python environment, install dependencies, and run a script.",
+		Content: `
+-- Task definitions for group: {{.GroupName}}
+-- Generated by: sloth-runner new (template: python)
+TaskDefinitions = {
+  ["{{.GroupName}}"] = {
+    description = "A pipeline to set up a Python environment and run a script.",
+    clean_workdir_after_run = function(last_result)
+      if not last_result.success then
+        log.error("Task failed. The workdir will be kept for debugging at: " .. last_result.output.workdir)
+      end
+      return last_result.success
+    end,
+    tasks = {
+      {
+        name = "run_python_script",
+        description = "Creates a venv, installs dependencies, and runs the main script.",
+        command = function(params)
+          local workdir = params.workdir
+          log.info("Starting Python task in workdir: " .. workdir)
+          fs.write(workdir .. "/requirements.txt", "requests")
+          fs.write(workdir .. "/main.py", "import requests; print('Hello from Python! Requests version: %s' % requests.__version__)")
+          local python = require("python")
+          local venv = python.venv(workdir .. "/.venv")
+          log.info("Creating virtual environment...")
+          venv:create()
+          log.info("Installing dependencies...")
+          venv:pip("install -r " .. workdir .. "/requirements.txt")
+          log.info("Running script...")
+          local result = venv:exec(workdir .. "/main.py")
+          result.workdir = workdir
+          return result.success, "Python task finished.", result
+        end
+      }
+    }
+  }
+}
+`,
+	},
+	"parallel": {
+		Name:        "parallel",
+		Description: "Demonstrates how to run multiple tasks concurrently.",
+		Content: `
+-- Task definitions for group: {{.GroupName}}
+-- Generated by: sloth-runner new (template: parallel)
+TaskDefinitions = {
+  ["{{.GroupName}}"] = {
+    description = "An example of running tasks in parallel.",
+    tasks = {
+      { name = "short_task", command = "sleep 1 && echo 'Short task finished.'" },
+      { name = "medium_task", command = "sleep 2 && echo 'Medium task finished.'" },
+      { name = "long_task", command = "sleep 3 && echo 'Long task finished.'" },
+      {
+        name = "run_all_in_parallel",
+        description = "Executes the sleep tasks concurrently.",
+        command = function()
+          log.info("Starting 3 tasks in parallel...")
+          local results, err = parallel({
+            { name = "short_task" },
+            { name = "medium_task" },
+            { name = "long_task" }
+          })
+          if err then
+            log.error("Parallel execution encountered an error: " .. err)
+            return false, "Parallel execution failed"
+          end
+          log.info("All parallel tasks have completed.")
+          return true, "Parallel execution finished successfully.", results
+        end
+      }
+    }
+  }
+}
+`,
+	},
+	"python-pulumi": {
+		Name:        "python-pulumi",
+		Description: "Pipeline to deploy Pulumi infrastructure managed with Python.",
+		Content: `
+-- Task definitions for group: {{.GroupName}}
+-- Generated by: sloth-runner new (template: python-pulumi)
+TaskDefinitions = {
+  ["{{.GroupName}}"] = {
+    description = "A pipeline to deploy Pulumi infrastructure using a Python environment.",
+    create_workdir_before_run = true,
+    clean_workdir_after_run = function(last_result) return last_result.success end,
+    tasks = {
+      {
+        name = "setup_and_deploy",
+        description = "Sets up the Python environment and runs 'pulumi up'.",
+        command = function(params)
+          local workdir = params.workdir
+          log.info("Starting Python+Pulumi pipeline in: " .. workdir)
+          fs.write(workdir .. "/requirements.txt", "pulumi")
+          fs.write(workdir .. "/__main__.py", "import pulumi\npulumi.export('urn', 'urn:pulumi:dev::{{.GroupName}}::pulumi:pulumi:Stack::{{.GroupName}}-dev')")
+          fs.write(workdir .. "/Pulumi.yaml", "name: {{.GroupName}}\nruntime: python\ndescription: A minimal Python Pulumi program")
+          local python = require("python")
+          local venv = python.venv(workdir .. "/.venv")
+          log.info("Creating venv...")
+          venv:create()
+          log.info("Installing Python dependencies...")
+          venv:pip("install -r " .. workdir .. "/requirements.txt")
+          local pulumi = require("pulumi")
+          local stack = pulumi.stack("dev", { workdir = workdir })
+          log.info("Running 'pulumi up'...")
+          local up_result = stack:up({ yes = true })
+          if not up_result.success then
+            log.error("'pulumi up' failed: " .. up_result.stderr)
+            return false, "Pulumi up failed", up_result
+          end
+          log.info("Pulumi up completed successfully.")
+          local outputs = stack:outputs()
+          return true, "Python+Pulumi pipeline finished.", outputs
+        end
+      }
+    }
+  }
+}
+`,
+	},
+	"python-pulumi-salt": {
+		Name:        "python-pulumi-salt",
+		Description: "Provisions infrastructure with Pulumi and configures it using SaltStack.",
+		Content: `
+-- Task definitions for group: {{.GroupName}}
+-- Generated by: sloth-runner new (template: python-pulumi-salt)
+TaskDefinitions = {
+  ["{{.GroupName}}"] = {
+    description = "Pipeline: Pulumi creates the infra, Salt configures it.",
+    create_workdir_before_run = true,
+    tasks = {
+      {
+        name = "deploy_infra",
+        description = "Uses Python and Pulumi to create the infrastructure.",
+        command = function(params)
+          local workdir = params.workdir
+          log.info("Starting infra deployment in: " .. workdir)
+          fs.write(workdir .. "/requirements.txt", "pulumi")
+          fs.write(workdir .. "/__main__.py", "import pulumi\npulumi.export('minion_id', 'test-minion-123')")
+          fs.write(workdir .. "/Pulumi.yaml", "name: {{.GroupName}}\nruntime: python")
+          require("python").venv(workdir .. "/.venv"):create()
+          local stack = require("pulumi").stack("dev", { workdir = workdir })
+          local up_result = stack:up({ yes = true })
+          if not up_result.success then return false, "Pulumi up failed", up_result end
+          return true, "Infrastructure created.", stack:outputs()
+        end
+      },
+      {
+        name = "configure_server",
+        description = "Uses Salt to apply a highstate on the created minion.",
+        depends_on = "deploy_infra",
+        command = function(params, inputs)
+          local minion_id = inputs.deploy_infra.minion_id
+          if not minion_id then
+            return false, "Minion ID not found in Pulumi outputs."
+          end
+          log.info("Configuring minion '" .. minion_id .. "' with Salt...")
+          local salt = require("salt")
+          local client = salt.client({ config_path = "/etc/salt/master" })
+          local result = client:target(minion_id):cmd("state.apply")
+          if not result.success then
+            log.error("Failed to apply Salt state: " .. result.stderr)
+            return false, "Salt state.apply failed", result
+          end
+          log.info("Salt configuration applied successfully.")
+          return true, "Server configured.", result
+        end
+      }
+    }
+  }
+}
+`,
+	},
+	"git-python-pulumi": {
+		Name:        "git-python-pulumi",
+		Description: "CI/CD Pipeline: Clones a repo, sets up the environment, and deploys with Pulumi.",
+		Content: `
+-- Task definitions for group: {{.GroupName}}
+-- Generated by: sloth-runner new (template: git-python-pulumi)
+TaskDefinitions = {
+  ["{{.GroupName}}"] = {
+    description = "CI/CD Pipeline: Clones, sets up environment, and deploys with Pulumi.",
+    create_workdir_before_run = true,
+    clean_workdir_after_run = function(r) return r.success end,
+    tasks = {
+      {
+        name = "clone_repository",
+        description = "Clones the project repository.",
+        command = function(params)
+          local workdir = params.workdir
+          log.info("Cloning repository into: " .. workdir)
+          -- TODO: Replace with your repository URL
+          local repo_url = "https://github.com/pulumi/examples.git"
+          local result = require("git").repo(workdir):clone(repo_url)
+          if not result.success then
+            log.error("Failed to clone: " .. result.stderr)
+            return false, "Git clone failed", result
+          end
+          return true, "Repository cloned."
+        end
+      },
+      {
+        name = "deploy_stack",
+        description = "Installs dependencies and deploys the Pulumi stack from the repository.",
+        depends_on = "clone_repository",
+        command = function(params)
+          local workdir = params.workdir .. "/aws-py-s3-folder" -- Example: subdirectory of the repo
+          log.info("Running deployment from: " .. workdir)
+          require("python").venv(workdir .. "/.venv"):create()
+          local stack = require("pulumi").stack("dev", { workdir = workdir })
+          local result = stack:up({ yes = true })
+          return result.success, "Deployment finished.", result
+        end
+      }
+    }
+  }
+}
+`,
+	},
+}
+
+// --- Fim: Definição de Templates ---
+
 type TemplateData struct {
 	Env          string
 	IsProduction bool
@@ -35,27 +302,23 @@ var (
 	shardsStr      string
 	targetTasksStr string
 	targetGroup    string
-	valuesFilePath string // New: Path to a values.yaml file
+	valuesFilePath string
 	dryRun         bool
 	returnOutput   bool
 	yes            bool
+	outputFile     string
+	templateName   string
 )
 
-// loadAndRenderLuaConfig reads, renders, and loads Lua task definitions.
 func loadAndRenderLuaConfig(L *lua.LState, configFilePath, env, shardsStr string, isProduction bool, valuesFilePath string, tr types.TaskRunner) (map[string]types.TaskGroup, error) {
-	// Read the Lua template file
 	templateContent, err := ioutil.ReadFile(configFilePath)
 	if err != nil {
 		return nil, fmt.Errorf("error reading Lua template file %s: %w", configFilePath, err)
 	}
-
-	// Parse the template
 	tmpl, err := template.New("lua_config").Parse(string(templateContent))
 	if err != nil {
 		return nil, fmt.Errorf("error parsing Lua template: %w", err)
 	}
-
-	// Parse shards string into []int
 	var shards []int
 	if shardsStr != "" {
 		shardStrings := strings.Split(shardsStr, ",")
@@ -67,194 +330,210 @@ func loadAndRenderLuaConfig(L *lua.LState, configFilePath, env, shardsStr string
 			shards = append(shards, shard)
 		}
 	}
-
-	// Prepare data for the template
 	data := TemplateData{
 		Env:          env,
 		IsProduction: isProduction,
 		Shards:       shards,
 	}
-
-	// Execute the template into a buffer
 	var renderedLua bytes.Buffer
 	if err := tmpl.Execute(&renderedLua, data); err != nil {
 		return nil, fmt.Errorf("error executing Lua template: %w", err)
 	}
-
-	// Open the 'exec' library for shell command execution
 	luainterface.OpenExec(L)
-
-	// Open the 'fs' library for file system operations
 	luainterface.OpenFs(L)
-
-	// Open the 'net' library for network operations
 	luainterface.OpenNet(L)
-
-	// Open the 'data' library for data serialization/deserialization
 	luainterface.OpenData(L)
-
-	// Open the 'log' library for logging from Lua
 	luainterface.OpenLog(L)
-
-	// Open the 'salt' library for SaltStack operations
 	luainterface.OpenSalt(L)
-
-	// Open the 'pulumi' library for Pulumi operations (NEW)
 	luainterface.OpenPulumi(L)
-
-	// Open the 'git' library for Git operations (NEW)
 	luainterface.OpenGit(L)
-
-	// Open the 'import' function for importing other Lua files
+	luainterface.OpenPython(L)
 	luainterface.OpenImport(L, configFilePath)
-
-	// Open the 'parallel' function, passing the task runner instance
 	luainterface.OpenParallel(L, tr)
-
-	// --- New: Load and expose values.yaml to Lua ---
 	if valuesFilePath != "" {
 		valuesContent, err := ioutil.ReadFile(valuesFilePath)
 		if err != nil {
 			return nil, fmt.Errorf("error reading values file %s: %w", valuesFilePath, err)
 		}
-
-		var goValues map[string]interface{} // Explicitly unmarshal into map[string]interface{}
+		var goValues map[string]interface{}
 		if err := yaml.Unmarshal(valuesContent, &goValues); err != nil {
 			return nil, fmt.Errorf("error parsing values YAML from %s: %w", valuesFilePath, err)
 		}
-
 		luaValues := luainterface.GoValueToLua(L, goValues)
 		L.SetGlobal("values", luaValues)
 	}
-	// --- End New ---
-
-	// Load the rendered Lua script content and parse task definitions
 	taskGroups, err := luainterface.LoadTaskDefinitions(L, renderedLua.String(), configFilePath)
 	if err != nil {
 		return nil, fmt.Errorf("error loading task definitions: %w", err)
 	}
-
 	return taskGroups, nil
 }
 
 var rootCmd = &cobra.Command{
 	Use:   "sloth-runner",
 	Short: "A flexible sloth-runner with Lua scripting capabilities",
-	Long: "sloth-runner is a command-line tool that allows you to define and execute " +
-		"tasks using Lua scripts. It supports pipelines, workflows, dynamic task generation, " +
-		"and output manipulation.",
+	Long: `sloth-runner is a command-line tool that allows you to define and execute
+tasks using Lua scripts. It supports pipelines, workflows, dynamic task generation,
+and output manipulation.`,
 	Run: func(cmd *cobra.Command, args []string) {
 		cmd.Help()
 	},
 }
 
+var templateCmd = &cobra.Command{
+	Use:   "template",
+	Short: "Manage task templates",
+	Long:  "Provides commands to list and manage available task templates.",
+}
+
+var templateListCmd = &cobra.Command{
+	Use:   "list",
+	Short: "Lists all available templates",
+	Long:  "Displays a table of all available templates that can be used with the 'new' command.",
+	RunE: func(cmd *cobra.Command, args []string) error {
+		w := tabwriter.NewWriter(os.Stdout, 0, 0, 3, ' ', 0)
+		fmt.Fprintln(w, "TEMPLATE NAME\tDESCRIPTION")
+		fmt.Fprintln(w, "-------------\t-----------")
+
+		for _, tmpl := range templateRegistry {
+			fmt.Fprintf(w, "%s\t%s\n", tmpl.Name, tmpl.Description)
+		}
+
+		return w.Flush()
+	},
+}
+
+var newCmd = &cobra.Command{
+	Use:   "new <group-name>",
+	Short: "Generates a new task definition file from a template",
+	Long: `The new command creates a boilerplate Lua task definition file.
+You can choose from different templates and specify an output file.
+Run 'sloth-runner template list' to see all available templates.`,
+	Args: cobra.ExactArgs(1),
+	RunE: func(cmd *cobra.Command, args []string) error {
+		groupName := args[0]
+		sanitizedGroupName := strings.ReplaceAll(groupName, " ", "-")
+
+		tmpl, ok := templateRegistry[templateName]
+		if !ok {
+			return fmt.Errorf("invalid template '%s'. Use 'sloth-runner template list' to see the options", templateName)
+		}
+
+		data := struct {
+			GroupName string
+		}{
+			GroupName: sanitizedGroupName,
+		}
+		t, err := template.New("new_task").Parse(tmpl.Content)
+		if err != nil {
+			return fmt.Errorf("internal error processing template: %w", err)
+		}
+		var output bytes.Buffer
+		if err := t.Execute(&output, data); err != nil {
+			return fmt.Errorf("error populating template: %w", err)
+		}
+		if outputFile != "" {
+			if err := ioutil.WriteFile(outputFile, output.Bytes(), 0644); err != nil {
+				return fmt.Errorf("failed to write to file %s: %w", outputFile, err)
+			}
+			fmt.Fprintf(os.Stderr, "✓ Task file '%s' generated successfully for group '%s'.\n", outputFile, sanitizedGroupName)
+		} else {
+			fmt.Println(output.String())
+		}
+		return nil
+	},
+}
+
 var runCmd = &cobra.Command{
 	Use:   "run",
 	Short: "Executes tasks defined in a Lua template file",
 	Long: `The run command executes tasks defined in a Lua template file.
-
-You can specify the file, environment variables, and target specific tasks or groups.`, 
-		RunE: func(cmd *cobra.Command, args []string) error {
-			L := lua.NewState()
-			defer L.Close()
-
-			// Create a dummy TaskRunner for initial Lua config loading. The real one will be created later.
-			// This is necessary because OpenParallel is called within loadAndRenderLuaConfig.
-			// The actual TaskRunner instance will be passed to OpenParallel again after it's fully initialized.
-			var dummyTr types.TaskRunner = nil
-
-			taskGroups, err := loadAndRenderLuaConfig(L, configFilePath, env, shardsStr, isProduction, valuesFilePath, dummyTr)
-			if err != nil {
-				return err
+You can specify the file, environment variables, and target specific tasks or groups.`,
+	RunE: func(cmd *cobra.Command, args []string) error {
+		L := lua.NewState()
+		defer L.Close()
+		var dummyTr types.TaskRunner = nil
+		taskGroups, err := loadAndRenderLuaConfig(L, configFilePath, env, shardsStr, isProduction, valuesFilePath, dummyTr)
+		if err != nil {
+			return err
+		}
+		var targetTasks []string
+		if targetTasksStr != "" {
+			targetTasks = strings.Split(targetTasksStr, ",")
+			for i, task := range targetTasks {
+				targetTasks[i] = strings.TrimSpace(task)
 			}
-	
-			var targetTasks []string
-			if targetTasksStr != "" {
-				targetTasks = strings.Split(targetTasksStr, ",")
-				for i, task := range targetTasks {
-					targetTasks[i] = strings.TrimSpace(task)
-				}
-			} else {
-				var allTasks []string
-				if targetGroup != "" {
-					if group, ok := taskGroups[targetGroup]; ok {
-						for _, task := range group.Tasks {
-							allTasks = append(allTasks, task.Name)
-						}
-					} else {
-						return fmt.Errorf("task group '%s' not found", targetGroup)
+		} else {
+			var allTasks []string
+			if targetGroup != "" {
+				if group, ok := taskGroups[targetGroup]; ok {
+					for _, task := range group.Tasks {
+						allTasks = append(allTasks, task.Name)
 					}
 				} else {
-					for _, group := range taskGroups {
-						for _, task := range group.Tasks {
-							allTasks = append(allTasks, task.Name)
-						}
-					}
-				}
-	
-				if len(allTasks) == 0 {
-					fmt.Println("No tasks found to run.")
-					return nil
+					return fmt.Errorf("task group '%s' not found", targetGroup)
 				}
-	
-				if yes {
-					targetTasks = allTasks
-				} else {
-					prompt := &survey.MultiSelect{
-						Message: "Select tasks to run:",
-						Options: allTasks,
+			} else {
+				for _, group := range taskGroups {
+					for _, task := range group.Tasks {
+						allTasks = append(allTasks, task.Name)
 					}
-					survey.AskOne(prompt, &targetTasks)
 				}
 			}
-	
-			if len(targetTasks) == 0 {
-				fmt.Println("No tasks selected.")
+			if len(allTasks) == 0 {
+				fmt.Println("No tasks found to run.")
 				return nil
 			}
-	
-			// Create a new TaskRunner instance
-			tr := taskrunner.NewTaskRunner(L, taskGroups, targetGroup, targetTasks, dryRun)
-	
-			// Re-open the 'parallel' function with the actual task runner instance
-			luainterface.OpenParallel(L, tr)
-	
-			if err := tr.Run(); err != nil {
-				return fmt.Errorf("error running tasks: %w", err)
+			if yes {
+				targetTasks = allTasks
+			} else {
+				prompt := &survey.MultiSelect{
+					Message: "Select tasks to run:",
+					Options: allTasks,
+				}
+				survey.AskOne(prompt, &targetTasks)
 			}
-	
-			if returnOutput {
-				finalOutputs := make(map[string]interface{})
-				for _, taskName := range targetTasks {
-					if output, ok := tr.Outputs[taskName]; ok {
-						finalOutputs[taskName] = output
-					}
+		}
+		if len(targetTasks) == 0 {
+			fmt.Println("No tasks selected.")
+			return nil
+		}
+		tr := taskrunner.NewTaskRunner(L, taskGroups, targetGroup, targetTasks, dryRun)
+		luainterface.OpenParallel(L, tr)
+		if err := tr.Run(); err != nil {
+			return fmt.Errorf("error running tasks: %w", err)
+		}
+		if returnOutput {
+			finalOutputs := make(map[string]interface{})
+			for _, taskName := range targetTasks {
+				if output, ok := tr.Outputs[taskName]; ok {
+					finalOutputs[taskName] = output
 				}
-	
-				var outputToMarshal interface{}
-				if len(targetTasks) == 1 {
-					if val, ok := finalOutputs[targetTasks[0]]; ok {
-						outputToMarshal = val
-					} else {
-						outputToMarshal = make(map[string]interface{})
-					}
+			}
+			var outputToMarshal interface{}
+			if len(targetTasks) == 1 {
+				if val, ok := finalOutputs[targetTasks[0]]; ok {
+					outputToMarshal = val
 				} else {
-					outputToMarshal = finalOutputs
+					outputToMarshal = make(map[string]interface{})
 				}
-	
-				jsonOutput, err := json.Marshal(outputToMarshal)
-				if err != nil {
-					return fmt.Errorf("error marshaling final task output to JSON: %w", err)
-				}
-				fmt.Println(string(jsonOutput))
+			} else {
+				outputToMarshal = finalOutputs
 			}
-	
-			return nil
-		},}
+			jsonOutput, err := json.Marshal(outputToMarshal)
+			if err != nil {
+				return fmt.Errorf("error marshaling final task output to JSON: %w", err)
+			}
+			fmt.Println(string(jsonOutput))
+		}
+		return nil
+	},
+}
+
 var listCmd = &cobra.Command{
 	Use:   "list",
 	Short: "Lists all available task groups and tasks",
-	Long:  `The list command displays all task groups and their respective tasks, along with their descriptions and dependencies.`, 
+	Long:  `The list command displays all task groups and their respective tasks, along with their descriptions and dependencies.`,
 	RunE: func(cmd *cobra.Command, args []string) error {
 		L := lua.NewState()
 		defer L.Close()
@@ -262,12 +541,10 @@ var listCmd = &cobra.Command{
 		if err != nil {
 			return err
 		}
-
 		if len(taskGroups) == 0 {
 			fmt.Println("No task groups found.")
 			return nil
 		}
-
 		fmt.Println("Available Task Groups and Tasks:")
 		for groupName, group := range taskGroups {
 			fmt.Printf("\n  Group: %s (Description: %s)\n", groupName, group.Description)
@@ -291,7 +568,7 @@ var listCmd = &cobra.Command{
 var validateCmd = &cobra.Command{
 	Use:   "validate",
 	Short: "Validates the syntax and structure of a Lua task file",
-	Long:  `The validate command checks a Lua task file for syntax errors and ensures that the TaskDefinitions table is correctly structured.`, 
+	Long:  `The validate command checks a Lua task file for syntax errors and ensures that the TaskDefinitions table is correctly structured.`,
 	RunE: func(cmd *cobra.Command, args []string) error {
 		L := lua.NewState()
 		defer L.Close()
@@ -299,37 +576,35 @@ var validateCmd = &cobra.Command{
 		if err != nil {
 			return err
 		}
-
 		fmt.Println("✅ Configuration file is valid.")
 		return nil
 	},
 }
 
 func init() {
+	rootCmd.AddCommand(templateCmd)
+	templateCmd.AddCommand(templateListCmd)
+	rootCmd.AddCommand(newCmd)
 	rootCmd.AddCommand(runCmd)
 	rootCmd.AddCommand(listCmd)
 	rootCmd.AddCommand(validateCmd)
-
-	// Define flags for the run command
+	newCmd.Flags().StringVarP(&outputFile, "output", "o", "", "Output file path (default: stdout)")
+	newCmd.Flags().StringVarP(&templateName, "template", "t", "simple", "Template to use. See 'template list' for options.")
 	runCmd.Flags().StringVarP(&configFilePath, "file", "f", "examples/basic_pipeline.lua", "Path to the Lua task configuration template file")
 	runCmd.Flags().StringVarP(&env, "env", "e", "Development", "Environment for the tasks (e.g., Development, Production)")
 	runCmd.Flags().BoolVarP(&isProduction, "prod", "p", false, "Set to true for production environment")
 	runCmd.Flags().StringVar(&shardsStr, "shards", "1,2,3", "Comma-separated list of shard numbers (e.g., 1,2,3)")
 	runCmd.Flags().StringVarP(&targetTasksStr, "tasks", "t", "", "Comma-separated list of specific tasks to run (e.g., task1,task2)")
 	runCmd.Flags().StringVarP(&targetGroup, "group", "g", "", "Run tasks only from a specific task group")
-	runCmd.Flags().StringVarP(&valuesFilePath, "values", "v", "", "Path to a YAML file with values to be passed to Lua tasks") // New flag for runCmd
+	runCmd.Flags().StringVarP(&valuesFilePath, "values", "v", "", "Path to a YAML file with values to be passed to Lua tasks")
 	runCmd.Flags().BoolVarP(&dryRun, "dry-run", "d", false, "Simulate the execution of tasks without actually running them")
 	runCmd.Flags().BoolVar(&returnOutput, "return", false, "Return the output of the target tasks as JSON")
 	runCmd.Flags().BoolVarP(&yes, "yes", "y", false, "Bypass interactive task selection and run all tasks")
-
-	// Flags for list command (can reuse configFilePath, env, isProduction, shardsStr)
 	listCmd.Flags().StringVarP(&configFilePath, "file", "f", "examples/basic_pipeline.lua", "Path to the Lua task configuration template file")
 	listCmd.Flags().StringVarP(&env, "env", "e", "Development", "Environment for the tasks (e.g., Development, Production)")
 	listCmd.Flags().BoolVarP(&isProduction, "prod", "p", false, "Set to true for production environment")
 	listCmd.Flags().StringVar(&shardsStr, "shards", "1,2,3", "Comma-separated list of shard numbers (e.g., 1,2,3)")
-	listCmd.Flags().StringVarP(&valuesFilePath, "values", "v", "", "Path to a YAML file with values to be passed to Lua tasks") // New flag for listCmd
-
-	// Flags for validate command
+	listCmd.Flags().StringVarP(&valuesFilePath, "values", "v", "", "Path to a YAML file with values to be passed to Lua tasks")
 	validateCmd.Flags().StringVarP(&configFilePath, "file", "f", "examples/basic_pipeline.lua", "Path to the Lua task configuration template file")
 	validateCmd.Flags().StringVarP(&env, "env", "e", "Development", "Environment for the tasks (e.g., Development, Production)")
 	validateCmd.Flags().BoolVarP(&isProduction, "prod", "p", false, "Set to true for production environment")
@@ -338,6 +613,7 @@ func init() {
 }
 
 func main() {
+	rootCmd.SilenceUsage = true // Suprime a ajuda em erros de execução
 	if err := rootCmd.Execute(); err != nil {
 		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
 		os.Exit(1)
diff --git a/examples/comprehensive_scenarios.lua b/examples/comprehensive_scenarios.lua
new file mode 100644
index 0000000..10feffb
--- /dev/null
+++ b/examples/comprehensive_scenarios.lua
@@ -0,0 +1,188 @@
+-- examples/comprehensive_scenarios.lua
+--
+-- Este arquivo demonstra vários cenários de uso do Sloth Runner,
+-- servindo como um teste de integração e um guia de funcionalidades.
+
+TaskDefinitions = {
+  -- ===================================================================
+  -- GRUPO 1: Comandos Básicos, Módulos e Dependências
+  -- ===================================================================
+  basic_features = {
+    description = "Testa a execução de comandos simples, o módulo 'fs' e dependências.",
+    tasks = {
+      {
+        name = "print_message",
+        description = "Executa um comando 'echo' simples.",
+        command = "echo 'Hello from a simple command!'"
+      },
+      {
+        name = "read_file",
+        description = "Usa o módulo 'fs' para ler um arquivo local.",
+        command = function()
+          local content, err = fs.read("test_file.txt")
+          if err then
+            log.error("Falha ao ler test_file.txt: " .. err)
+            return false, "File read failed"
+          end
+          log.info("Conteúdo do arquivo: " .. content)
+          return true, "File read successfully"
+        end
+      },
+      {
+        name = "chained_task",
+        description = "Executa somente após 'print_message'.",
+        depends_on = "print_message",
+        command = "echo 'Esta tarefa executou depois de print_message.'"
+      }
+    }
+  },
+
+  -- ===================================================================
+  -- GRUPO 2: Manipulação de Dados com Módulos 'net' e 'data'
+  -- ===================================================================
+  data_pipeline = {
+    description = "Busca dados de uma API, processa com JSON e usa o resultado.",
+    tasks = {
+      {
+        name = "fetch_api_data",
+        description = "Busca dados de httpbin.org.",
+        command = function()
+          local body, status, _, err = net.http_get("https://httpbin.org/json")
+          if err or status ~= 200 then
+            return false, "API fetch failed", { error = err or "status not 200" }
+          end
+          return true, "API data fetched", { json_string = body }
+        end
+      },
+      {
+        name = "parse_json",
+        description = "Analisa o JSON retornado pela API.",
+        depends_on = "fetch_api_data",
+        command = function(params, inputs)
+          local json_str = inputs.fetch_api_data.json_string
+          local parsed, err = data.parse_json(json_str)
+          if err then
+            return false, "JSON parsing failed", { error = err }
+          end
+          log.info("Título do slideshow: " .. parsed.slideshow.title)
+          return true, "JSON parsed successfully", { title = parsed.slideshow.title }
+        end
+      }
+    }
+  },
+
+  -- ===================================================================
+  -- GRUPO 3: Execução Paralela
+  -- ===================================================================
+  parallel_tasks = {
+    description = "Executa múltiplas tarefas em paralelo.",
+    tasks = {
+      { name = "sleep_1", command = "sleep 1 && echo 'Slept for 1s'" },
+      { name = "sleep_2", command = "sleep 2 && echo 'Slept for 2s'" },
+      {
+        name = "run_in_parallel",
+        description = "Usa a função 'parallel' para executar tarefas concorrentemente.",
+        command = function()
+          log.info("Iniciando execução paralela...")
+          local results, err = parallel({
+            { name = "sleep_1" },
+            { name = "sleep_2" }
+          })
+          if err then
+            return false, "Parallel execution failed: " .. err
+          end
+          log.info("Execução paralela concluída.")
+          return true, "Parallel tasks finished", results
+        end
+      }
+    }
+  },
+
+  -- ===================================================================
+  -- GRUPO 4: Ciclo de Vida do Workdir (Sucesso e Falha)
+  -- ===================================================================
+  python_lifecycle = {
+    description = "Testa a criação e limpeza do workdir em cenários de sucesso e falha.",
+    
+    -- Política de limpeza: manter o workdir se a tarefa falhar.
+    clean_workdir_after_run = function(last_result)
+      return last_result.success
+    end,
+
+    tasks = {
+      {
+        name = "python_succeeds",
+        description = "Executa um script Python que deve ter sucesso.",
+        command = function(params, workdir)
+          -- O runner deve copiar os arquivos para o workdir antes.
+          -- Para este teste, vamos criá-los dinamicamente.
+          fs.write(workdir .. "/requirements.txt", "requests==2.28.1")
+          fs.write(workdir .. "/app.py", "import sys; print('Success!'); sys.exit(0)")
+
+          local python = require("python")
+          local venv = python.venv(workdir .. "/.venv")
+          venv:create()
+          venv:pip("install -r " .. workdir .. "/requirements.txt")
+          local result = venv:exec(workdir .. "/app.py")
+          
+          log.info("Resultado da execução Python (sucesso): " .. result.stdout)
+          return result.success, "Python script finished.", result
+        end
+      },
+      {
+        name = "python_fails",
+        description = "Executa um script Python que deve falhar.",
+        command = function(params, workdir)
+          fs.write(workdir .. "/requirements.txt", "requests==2.28.1")
+          fs.write(workdir .. "/app.py", "import sys; print('Failure!', file=sys.stderr); sys.exit(1)")
+
+          local python = require("python")
+          local venv = python.venv(workdir .. "/.venv")
+          venv:create()
+          venv:pip("install -r " .. workdir .. "/requirements.txt")
+          local result = venv:exec(workdir .. "/app.py")
+          
+          log.info("Resultado da execução Python (falha): " .. result.stderr)
+          return result.success, "Python script finished.", result
+        end
+      }
+    }
+  },
+
+  -- ===================================================================
+  -- GRUPO 5: Tratamento de Erros (Retries e Next-If-Fail)
+  -- ===================================================================
+  error_handling = {
+    description = "Demonstra as capacidades de retentativas e fluxo de falha.",
+    tasks = {
+      {
+        name = "flaky_task",
+        description = "Uma tarefa que falha na primeira vez.",
+        retries = 2,
+        command = function()
+          local marker_file = "/tmp/sloth_marker"
+          if not fs.exists(marker_file) then
+            log.warn("Tentativa 1: Falhando de propósito.")
+            fs.write(marker_file, "exists")
+            return false, "Falha simulada"
+          else
+            log.info("Tentativa 2: Sucesso!")
+            fs.rm(marker_file)
+            return true, "Sucesso na retentativa"
+          end
+        end
+      },
+      {
+        name = "always_fail",
+        description = "Uma tarefa que sempre falha.",
+        command = "exit 1"
+      },
+      {
+        name = "cleanup_on_fail",
+        description = "Executa somente se 'always_fail' falhar.",
+        next_if_fail = "always_fail",
+        command = "echo 'Executando limpeza após a falha!'"
+      }
+    }
+  }
+}
diff --git a/examples/fluent_salt_api_test.lua b/examples/fluent_salt_api_test.lua
index 8eeca36..5341ad4 100644
--- a/examples/fluent_salt_api_test.lua
+++ b/examples/fluent_salt_api_test.lua
@@ -10,19 +10,19 @@ command = function()
     -- Teste 1: Executando comandos no minion 'keiteguica'
     log.info("Testando alvo único: keiteguica")
     -- Encadeia o comando ping() para o alvo 'keiteguica'
-    salt.target('keiteguica'):ping()
+    salt.target('keiteguica', 'glob'):ping()
 
     log.info("--------------------------------------------------")
 
     -- Teste 2: Executando comandos em múltiplos minions usando globbing
     log.info("Testando alvo com glob: vm-gcp-squid-proxy*")
     -- Encadeia os comandos ping() e cmd() para alvos que correspondem ao padrão
-    salt.target('vm-gcp-squid-proxy*'):ping():cmd('pkg.upgrade')
+    salt.target('vm-gcp-squid-proxy*', 'glob'):ping():cmd('pkg.upgrade')
 
     log.info("Teste da API fluente do Salt concluído.")
 
     log.info("Executando 'ls -la' via Salt e tratando a saída...")
-    local result_stdout, result_stderr, result_err = salt.target('keiteguica'):cmd('cmd.run', 'ls -la'):result()
+    local result_stdout, result_stderr, result_err = salt.target('keiteguica', 'glob'):cmd('cmd.run', 'ls -la'):result()
 
     if result_err ~= nil then
         log.error("Erro ao executar 'ls -la' via Salt: " .. result_err)
diff --git a/examples/gcp-host-pipeline.lua b/examples/gcp-host-pipeline.lua
new file mode 100644
index 0000000..5b17f5e
--- /dev/null
+++ b/examples/gcp-host-pipeline.lua
@@ -0,0 +1,99 @@
+TaskDefinitions = {
+  ["gcp-host"] = {
+    description = "CI/CD Pipeline: Clones, prepares environment, configures, and deploys the gcp-hosts project.",
+    create_workdir_before_run = true,
+    workdir = '/tmp/gcp-host-deployment',
+    execution_mode = "shared_session", 
+    clean_workdir_after_run = function(r) return r.success end,
+
+    tasks = {
+      {
+        name = "clone_repository",
+        command = function(params)
+          local git = require("git")
+          local result = git.clone("https://github.com/chalkan3/gcp-hosts.git", params.workdir)
+          if not result.success then
+            return false, "Failed to clone repository: " .. result.stderr
+          end
+          return true, "Repository cloned successfully."
+        end
+      },
+      {
+        name = "setup_python_env",
+        description = "Creates a virtual environment and installs all dependencies.",
+        depends_on = "clone_repository",
+        command = function(params)
+          local py = require("python")
+          local venv_path = params.workdir .. "/.venv"
+          local venv = py.venv(venv_path)
+          
+          local create_result = venv:create()
+          if not create_result.success then
+            return false, "Failed to create python venv: " .. create_result.stderr
+          end
+          
+          local pip_result = venv:pip("install -r " .. params.workdir .. "/requirements.txt")
+          if not pip_result.success then
+            return false, "Failed to install python dependencies: " .. pip_result.stderr
+          end
+
+          return true, "Python environment created.", { venv_path = venv_path }
+        end
+      },
+      {
+        name = "init_stack",
+        description = "Initializes the Pulumi stack if it does not exist.",
+        depends_on = "setup_python_env",
+        command = function(params, inputs)
+          local pulumi = require("pulumi")
+          local stack = pulumi.stack("organization/gcp-host/prod", { workdir = params.workdir, venv_path = inputs.setup_python_env.venv_path })
+          local result = stack:select()
+          if not result.success then
+            return false, "Failed to select pulumi stack: " .. result.stderr
+          end
+          return true, "Pulumi stack selected.", { stack = stack, venv_path = inputs.setup_python_env.venv_path }
+        end
+      },
+      {
+        name = "configure_pulumi",
+        description = "Sets all required Pulumi config values for the gcp-hosts stack.",
+        depends_on = "init_stack",
+        command = function(params, inputs)
+          local stack = inputs.init_stack.stack
+          local configs = {
+            { "gcp:project", "chalkan3" },
+            { "gcp:zone", "us-central1-a" },
+            { "gcp-host:machineType", "e2-medium" },
+            { "gcp-host:bootDiskImage", "ubuntu-os-cloud/ubuntu-2204-lts" },
+            { "gcp-host:instanceName", "vm-gcp-squid-proxy-02" },
+            { "gcp-host:saltMasterIp", "34.57.154.158" },
+            { "gcp-host:firewallPorts", '["3128"]' },
+            { "gcp-host:saltGrains", '{ "roles": ["squid"], "environment": "production" }' }
+          }
+
+          for _, conf in ipairs(configs) do
+            local result = stack:config(conf[1], conf[2])
+            if not result.success then
+              return false, "Failed to set config '" .. conf[1] .. "': " .. result.stderr
+            end
+          end
+
+          return true, "Stack Configurated", { stack = stack }
+        end
+      },
+      {
+        name = "deploy_stack",
+        description = "Deploys the Pulumi stack using the prepared environment.",
+        depends_on = "configure_pulumi",
+        command = function(params, inputs)
+          local stack = inputs.configure_pulumi.stack
+          local result = stack:up({ yes = true, skip_preview = true })
+          if not result.success then
+            return false, "Failed to deploy pulumi stack: " .. result.stdout
+          end
+          return true, "Pulumi stack deployed."
+        end
+      }
+    }
+  }
+}
diff --git a/examples/git_conditional_deploy.lua b/examples/git_conditional_deploy.lua
new file mode 100644
index 0000000..5fb8338
--- /dev/null
+++ b/examples/git_conditional_deploy.lua
@@ -0,0 +1,45 @@
+-- examples/git_conditional_deploy.lua
+-- Description: Este exemplo demonstra um pipeline de deploy condicional
+-- que utiliza a nova API orientada a objetos. O script inspeciona a
+-- branch de um repositório Git local e, em seguida, usa o módulo Salt
+-- para "deployar" para ambientes diferentes com base no nome da branch.
+
+-- Pré-requisito: Você deve ter um repositório git local em "./tmp/app-checkout"
+-- para que este exemplo funcione.
+
+log.info("Iniciando pipeline de deploy condicional...")
+
+-- Etapa 1: Obter um objeto para um repositório Git local existente.
+-- Note que estamos usando 'git:repo()' em vez de 'git:clone()'.
+local app_repo = git:repo("./tmp/app-checkout")
+
+log.info("Repositório local em: " .. app_repo.local.path)
+log.info("Branch atual detectada: '" .. app_repo.current.branch .. "'")
+
+-- Etapa 2: Lógica condicional baseada nos dados do objeto do repositório.
+if app_repo.current.branch == "main" then
+  -- Se a branch for 'main', consideramos um deploy de produção.
+  log.info("Branch 'main' detectada. Preparando para deploy em produção.")
+
+  -- Garante que o código está atualizado antes do deploy.
+  log.info("Executando 'git pull' para obter as últimas atualizações...")
+  app_repo:pull()
+
+  -- Usa o módulo Salt para aplicar o estado no ambiente de produção.
+  log.info("Executando deploy em produção com Salt...")
+  salt:target("prod-servers"):cmd("state.apply", "my-app")
+
+  log.success("Deploy em produção concluído!")
+
+else
+  -- Se for qualquer outra branch, consideramos um deploy de homologação/staging.
+  log.info("Branch de feature detectada. Preparando para deploy em homologação.")
+
+  -- Usa o módulo Salt para aplicar o estado no ambiente de homologação.
+  log.info("Executando deploy em homologação com Salt...")
+  salt:target("staging-servers"):cmd("state.apply", "my-app", "test=true")
+
+  log.success("Deploy em homologação concluído!")
+end
+
+log.info("Pipeline de deploy condicional finalizado.")
diff --git a/examples/pulumi_git_combined_example.lua b/examples/pulumi_git_combined_example.lua
index 139f722..e7936e6 100644
--- a/examples/pulumi_git_combined_example.lua
+++ b/examples/pulumi_git_combined_example.lua
@@ -1,97 +1,33 @@
 -- examples/pulumi_git_combined_example.lua
---
--- Este arquivo de exemplo demonstra o uso combinado dos módulos 'pulumi' e 'git'.
+-- Demonstrates the new, more powerful method-style API
 
-command = function(params)
-    log.info("Iniciando exemplo combinado Pulumi e Git...")
+-- Etapa 1: Clonar o repositório que contém a infraestrutura
+log.info("Iniciando o clone do repositório de infraestrutura...")
+local repo = git:clone("https://github.com/user/example-infra.git", "./tmp/infra-checkout")
 
-    local pulumi_repo_url = "https://github.com/chalkan3/sloth-runner.git" -- Exemplo de repo Pulumi
-    local pulumi_repo_path = "./pulumi-infra-checkout"
-    local new_infra_version = params.infra_version or "v1.0.0-infra"
-    local pulumi_project_workdir = pulumi_repo_path -- O diretório raiz do repo clonado
-    local repo
+-- Etapa 2: Usar os dados do objeto 'repo' retornado
+-- Acessamos o caminho do repositório clonado para usá-lo em outro módulo.
+log.info("Repositório clonado com sucesso em: " .. repo.local.path)
+log.info("URL remota: " .. repo.remote.url)
+log.info("Branch atual: " .. repo.current.branch)
 
-    -- 1. Clonar ou abrir o repositório Pulumi
-    if not fs.exists(pulumi_repo_path) then
-        log.info("Cloning Pulumi repository: " .. pulumi_repo_url)
-        local cloned_repo, clone_err = git.clone(pulumi_repo_url, pulumi_repo_path)
-        if clone_err then
-            log.error("Failed to clone Pulumi repository: " .. clone_err)
-            return false, "Git clone failed."
-        end
-        repo = cloned_repo
-    else
-        log.info("Pulumi repository already exists, opening local reference.")
-        local opened_repo, open_err = git.repo(pulumi_repo_path)
-        if open_err then
-            log.error("Failed to open Pulumi repository: " .. open_err)
-            return false, "Git repo open failed."
-        end
-        repo = opened_repo
-    end
+-- Opcional: Realizar mais operações git no objeto repo
+repo:pull()
 
-    if not repo then
-        return false, "Failed to get Pulumi repository reference."
-    end
+-- Etapa 3: Definir e provisionar a infraestrutura com Pulumi
+-- O 'workdir' do Pulumi agora aponta dinamicamente para o diretório clonado.
+log.info("Configurando a stack Pulumi...")
+local stack = pulumi:stack("dev-stack", { workdir = repo.local.path })
 
-    -- 2. Atualizar o repositório (pull)
-    log.info("Pulling latest changes from Pulumi repository...")
-    repo:checkout("main"):pull("origin", "main")
-    local pull_result = repo:result()
-    if not pull_result.success then
-        log.error("Failed to pull Pulumi repository: " .. pull_result.stderr)
-        return false, "Git pull failed."
-    end
-    log.info("Pulumi repository updated. Stdout: " .. pull_result.stdout)
+-- Etapa 4: Executar o 'up' da stack e obter os resultados
+log.info("Provisionando a infraestrutura com 'pulumi up'...")
+stack:up()
 
-    -- 3. Simular uma alteração no código Pulumi (e.g., atualizar um arquivo de versão)
-    local infra_version_file = pulumi_repo_path .. "/INFRA_VERSION"
-    fs.write(infra_version_file, new_infra_version)
-    log.info("Updated INFRA_VERSION file to: " .. new_infra_version)
+log.info("Infraestrutura provisionada. Obtendo as saídas...")
+local outputs = stack:outputs()
 
-    -- 4. Commitar e empurrar as mudanças
-    local commit_message = "ci: Bump infrastructure version to " .. new_infra_version
-    log.info("Committing and pushing infrastructure version change...")
-    repo:add(infra_version_file)
-        :commit(commit_message)
-        :push("origin", "main") -- Sem follow_tags aqui, apenas o commit
+-- Etapa 5: Usar as saídas da infraestrutura
+log.info("A URL da aplicação é: " .. outputs.url)
+log.info("O nome do bucket S3 é: " .. outputs.bucket_name)
 
-    local push_result = repo:result()
-    if not push_result.success then
-        log.error("Failed to push infrastructure changes: " .. push_result.stderr)
-        return false, "Git push failed for infra changes."
-    end
-    log.info("Infrastructure version change pushed. Stdout: " .. push_result.stdout)
-
-    -- 5. Executar 'pulumi up' para o projeto
-    log.info("Running pulumi up for the infrastructure project...")
-    local infra_stack = pulumi.stack("my-org/my-infra/dev", {
-        workdir = pulumi_project_workdir -- Usar o subdiretório do projeto Pulumi
-    })
-
-    local pulumi_up_result = infra_stack:up({ non_interactive = true })
-
-    if not pulumi_up_result.success then
-        log.error("Pulumi up failed: " .. pulumi_up_result.stderr)
-        return false, "Pulumi up failed."
-    end
-    log.info("Pulumi up completed successfully. Stdout: " .. pulumi_up_result.stdout)
-
-    log.info("Exemplo combinado Pulumi e Git concluído com sucesso.")
-    return true, "Combined Pulumi and Git example finished."
-end
-
-TaskDefinitions = {
-    pulumi_git_combined_example = {
-        description = "Demonstrates combined usage of 'pulumi' and 'git' modules.",
-        tasks = {
-            {
-                name = "run_combined_example",
-                command = command,
-                params = {
-                    infra_version = "v1.0.0-test-combined"
-                }
-            }
-        }
-    }
-}
+log.success("Workflow de Git e Pulumi concluído com sucesso!")
\ No newline at end of file
diff --git a/examples/pulumi_multi_stack_dependencies.lua b/examples/pulumi_multi_stack_dependencies.lua
new file mode 100644
index 0000000..5c8b6f7
--- /dev/null
+++ b/examples/pulumi_multi_stack_dependencies.lua
@@ -0,0 +1,54 @@
+-- examples/pulumi_multi_stack_dependencies.lua
+-- Description: Este exemplo demonstra um workflow avançado com Pulumi,
+-- onde a saída (output) de uma stack é usada como entrada (input) para
+-- outra. Isso é comum para separar o gerenciamento de diferentes camadas
+-- da infraestrutura, como rede e aplicação.
+
+log.info("Iniciando workflow de stacks Pulumi com dependências...")
+
+-- --- Etapa 1: Provisionar a Stack de Rede ---
+log.info("Configurando e provisionando a stack de rede base...")
+
+-- Cria um objeto para a stack que gerencia a infraestrutura de rede (VPC, subnets, etc.)
+local network_stack = pulumi:stack("infra-network-stack", { workdir = "./pulumi/network" })
+
+-- Executa o 'up' para criar ou atualizar os recursos de rede.
+network_stack:up()
+
+-- Após o provisionamento, obtemos as saídas da stack.
+log.info("Coletando saídas da stack de rede...")
+local network_outputs = network_stack:outputs()
+
+-- A saída 'vpc_id' agora está disponível para ser usada em outras partes do nosso script.
+log.info("VPC ID obtido: " .. network_outputs.vpc_id)
+log.info("Subnet ID obtida: " .. network_outputs.public_subnet_id)
+
+-- --- Etapa 2: Provisionar a Stack da Aplicação ---
+log.info("Configurando e provisionando a stack da aplicação...")
+
+-- Agora, criamos a stack da aplicação.
+-- Em um cenário real, passaríamos o ID da VPC e da subnet como configuração
+-- para que os servidores da aplicação sejam criados na rede correta.
+-- A lógica abaixo simula como esses dados seriam preparados.
+local app_config = {
+  vpc_id = network_outputs.vpc_id,
+  subnet_id = network_outputs.public_subnet_id
+}
+
+log.info("A stack da aplicação será provisionada na VPC '" .. app_config.vpc_id .. "'")
+
+-- Cria o objeto da stack da aplicação.
+-- O workdir aponta para o projeto Pulumi que define os servidores.
+local app_stack = pulumi:stack("app-server-stack", { workdir = "./pulumi/app" })
+
+-- Executa o 'up' da aplicação. O código Pulumi (em ./pulumi/app)
+-- seria responsável por ler a configuração (app_config) para usar a VPC correta.
+app_stack:up()
+
+-- Coleta as saídas da stack da aplicação.
+log.info("Coletando saídas da stack da aplicação...")
+local app_outputs = app_stack:outputs()
+
+log.info("URL do load balancer da aplicação: " .. app_outputs.app_url)
+
+log.success("Workflow de múltiplas stacks Pulumi concluído com sucesso!")
diff --git a/examples/python_venv_example.lua b/examples/python_venv_example.lua
new file mode 100644
index 0000000..f95772a
--- /dev/null
+++ b/examples/python_venv_example.lua
@@ -0,0 +1,66 @@
+-- examples/python_venv_example.lua (Refatorado)
+--
+-- NOTA: Este script foi refatorado para ser processado por um runner que
+-- gerencia e injeta o diretório de trabalho ('workdir') automaticamente.
+-- A lógica do runner deve:
+-- 1. Garantir um 'workdir' para o grupo, usando '/tmp/<group_name>' como padrão.
+-- 2. Injetar o caminho final do 'workdir' como um segundo argumento para a função 'command'.
+
+TaskDefinitions = {
+  python_app = {
+    -- O campo 'workdir' foi intencionalmente omitido.
+    -- O runner irá agora calcular o padrão: /tmp/python_app
+    description = "A task group to manage and run the Python application.",
+    tasks = {
+      {
+        name = "run_python_app",
+        description = "Configura o ambiente virtual e executa a aplicação Python dentro de um workdir gerenciado.",
+        
+        -- A assinatura da função agora aceita 'workdir' como um argumento injetado pelo runner.
+        command = function(params, workdir)
+          -- Todos os caminhos são construídos de forma segura dentro do workdir fornecido.
+          local venv_path = workdir .. "/.venv"
+          local requirements_path = workdir .. "/requirements.txt"
+          local app_path = workdir .. "/app.py"
+
+          -- Assume-se que o runner também é responsável por popular o workdir
+          -- com os arquivos necessários (ex: app.py, requirements.txt) antes da execução.
+          log.info("Executando tarefa no workdir gerenciado: " .. workdir)
+
+          local python = require("python")
+          local my_venv = python.venv(venv_path)
+
+          if not my_venv:exists() then
+            log.info("Criando ambiente virtual Python em: " .. venv_path)
+            local create_result = my_venv:create()
+            if not create_result.success then
+              log.error("Falha ao criar o venv: " .. create_result.stderr)
+              return false, "venv creation failed"
+            end
+          else
+            log.info("Ambiente virtual Python já existe em: " .. venv_path)
+          end
+
+          log.info("Instalando dependências de " .. requirements_path)
+          local pip_result = my_venv:pip("install -r " .. requirements_path)
+          if not pip_result.success then
+            log.error("Falha ao instalar dependências: " .. pip_result.stderr)
+            return false, "pip install failed"
+          end
+
+          log.info("Executando o script " .. app_path)
+          local exec_result = my_venv:exec(app_path)
+          if not exec_result.success then
+            log.error("Falha ao executar app.py: " .. exec_result.stderr)
+            return false, "python exec failed"
+          end
+
+          log.info("Saída do app.py:")
+          print(exec_result.stdout)
+
+          return true, "Python app executed successfully from " .. workdir
+        end
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/examples/python_venv_lifecycle_example.lua b/examples/python_venv_lifecycle_example.lua
new file mode 100644
index 0000000..2de04f8
--- /dev/null
+++ b/examples/python_venv_lifecycle_example.lua
@@ -0,0 +1,97 @@
+-- examples/python_venv_lifecycle_example.lua
+--
+-- ARQUITETURA DA DSL (v2):
+-- Esta versão introduz um ciclo de vida explícito para o 'workdir' no nível do grupo de tarefas.
+-- O runner que processa esta DSL agora deve interpretar dois novos campos:
+--
+-- 1. create_workdir_before_run (boolean, opcional):
+--    - true: Usa um workdir de caminho FIXO (/tmp/<group_name>) e o limpa (recria) antes da execução.
+--    - false/omitido (padrão): Cria um workdir ÚNICO e temporário (/tmp/<group_name>-<uuid>) para cada execução.
+--
+-- 2. clean_workdir_after_run (function, opcional):
+--    - Recebe o resultado da última tarefa executada.
+--    - Retorna 'true' para remover o workdir após a execução, ou 'false' para mantê-lo (útil para depuração).
+--    - Se omitido, o runner pode ter um comportamento padrão (ex: sempre limpar).
+
+TaskDefinitions = {
+  -- CASO DE USO 1: Workdir Efêmero e Limpeza Condicional (Ideal para Desenvolvimento e Debug)
+  python_app_ephemeral = {
+    description = "Executa a app Python em um workdir novo e único a cada vez. O workdir só é limpo se a execução for bem-sucedida.",
+
+    -- Omitido, então o runner usará o padrão: criar um workdir único como /tmp/python_app_ephemeral-<uuid>
+    -- create_workdir_before_run = false,
+
+    -- Função de limpeza: mantém o diretório em caso de falha para permitir a inspeção dos artefatos.
+    clean_workdir_after_run = function(last_task_result)
+      log.info("Avaliando limpeza do workdir efêmero...")
+      if last_task_result.success then
+        log.info("A última tarefa foi bem-sucedida. O workdir será removido.")
+        return true
+      else
+        log.error("A última tarefa falhou. O workdir será mantido para depuração.")
+        return false
+      end
+    end,
+
+    tasks = {
+      {
+        name = "run_python_app",
+        description = "Configura e executa a aplicação em um workdir efêmero.",
+        command = function(params, workdir)
+          log.info("Executando em workdir efêmero: " .. workdir)
+          
+          local venv_path = workdir .. "/.venv"
+          -- O runner seria responsável por popular este diretório com os arquivos necessários.
+          local requirements_path = workdir .. "/requirements.txt" 
+          local app_path = workdir .. "/app.py"
+
+          local python = require("python")
+          local my_venv = python.venv(venv_path)
+
+          my_venv:create()
+          my_venv:pip("install -r " .. requirements_path)
+          local exec_result = my_venv:exec(app_path)
+
+          return exec_result.success, "Execução no workdir efêmero concluída.", exec_result
+        end
+      }
+    }
+  },
+
+  -- CASO DE USO 2: Workdir Fixo e Limpeza Garantida (Ideal para Ambientes de CI/CD)
+  python_app_fixed_and_clean = {
+    description = "Executa a app Python em um workdir com caminho fixo, garantindo que ele esteja limpo antes e que seja removido depois.",
+
+    -- Garante que o workdir seja sempre /tmp/python_app_fixed_and_clean e que esteja zerado.
+    create_workdir_before_run = true,
+
+    -- Função de limpeza: sempre retorna true, garantindo que o workdir seja removido, não importando o resultado.
+    clean_workdir_after_run = function(last_task_result)
+      log.info("Política de limpeza para workdir fixo: sempre remover.")
+      return true
+    end,
+
+    tasks = {
+      {
+        name = "run_python_app_fixed",
+        description = "Configura e executa a aplicação em um workdir fixo e limpo.",
+        command = function(params, workdir)
+          log.info("Executando em workdir fixo e limpo: " .. workdir)
+          
+          local venv_path = workdir .. "/.venv"
+          local requirements_path = workdir .. "/requirements.txt"
+          local app_path = workdir .. "/app.py"
+
+          local python = require("python")
+          local my_venv = python.venv(venv_path)
+
+          my_venv:create()
+          my_venv:pip("install -r " .. requirements_path)
+          local exec_result = my_venv:exec(app_path)
+
+          return exec_result.success, "Execução no workdir fixo concluída.", exec_result
+        end
+      }
+    }
+  }
+}
diff --git a/examples/workdir_lifecycle_scenarios.lua b/examples/workdir_lifecycle_scenarios.lua
new file mode 100644
index 0000000..0777224
--- /dev/null
+++ b/examples/workdir_lifecycle_scenarios.lua
@@ -0,0 +1,150 @@
+-- examples/workdir_lifecycle_scenarios.lua
+--
+-- Este arquivo testa especificamente as funcionalidades da DSL para o ciclo de vida do 'workdir'.
+-- Cenários abordados:
+-- 1. Workdir Efêmero que é limpo após SUCESSO.
+-- 2. Workdir Efêmero que é MANTIDO após FALHA.
+-- 3. Workdir Fixo que é SEMPRE limpo, independentemente do resultado.
+
+-- Simulação do que o Runner deveria fazer: pré-processar a tabela de definições.
+local function setup_workdirs(task_defs)
+  for group_name, group in pairs(task_defs) do
+    -- Simula a lógica de criação do workdir
+    if group.create_workdir_before_run then
+      group.workdir = "/tmp/" .. group_name
+    else
+      -- Gera um "uuid" simples para o teste
+      local uuid = os.time()
+      group.workdir = "/tmp/" .. group_name .. "-" .. uuid
+    end
+
+    -- Simula a injeção do workdir em cada tarefa
+    for _, task in ipairs(group.tasks) do
+      local original_command = task.command
+      task.command = function(params)
+        -- Cria o diretório para a simulação
+        fs.mkdir(group.workdir)
+        -- Passa o workdir para a função original
+        return original_command(params, group.workdir)
+      end
+    end
+  end
+  return task_defs
+end
+
+
+TaskDefinitions = setup_workdirs({
+  -- =================================================================================
+  -- CENÁRIO 1: Workdir efêmero, limpo apenas em caso de sucesso.
+  -- =================================================================================
+  ephemeral_clean_on_success = {
+    description = "Usa um workdir único. Executa um script de SUCESSO e o workdir deve ser REMOVIDO.",
+    
+    clean_workdir_after_run = function(last_result)
+      log.info("Avaliando limpeza para 'ephemeral_clean_on_success'...")
+      if last_result.success then
+        log.info("Tarefa bem-sucedida. O workdir será removido.")
+        return true
+      else
+        log.warn("Tarefa falhou. O workdir seria mantido.")
+        return false
+      end
+    end,
+
+    tasks = {
+      {
+        name = "run_success_script",
+        command = function(params, workdir)
+          log.info("Executando em workdir efêmero (deve ser único): " .. workdir)
+          
+          exec.command("cp", "succeeding_app.py", workdir .. "/app.py")
+          exec.command("cp", "requirements.txt", workdir .. "/requirements.txt")
+
+          local python = require("python")
+          local venv = python.venv(workdir .. "/.venv")
+          venv:create()
+          venv:pip("install -r " .. workdir .. "/requirements.txt")
+          local result = venv:exec(workdir .. "/app.py")
+          
+          return result.success, "Script de sucesso executado.", result
+        end
+      }
+    }
+  },
+
+  -- =================================================================================
+  -- CENÁRIO 2: Workdir efêmero, mantido em caso de falha (para depuração).
+  -- =================================================================================
+  ephemeral_preserve_on_failure = {
+    description = "Usa um workdir único. Executa um script de FALHA e o workdir deve ser MANTIDO.",
+
+    clean_workdir_after_run = function(last_result)
+      log.info("Avaliando limpeza para 'ephemeral_preserve_on_failure'...")
+      if last_result.success then
+        log.warn("Tarefa bem-sucedida. O workdir seria removido.")
+        return true
+      else
+        -- Adicionamos o workdir ao resultado para poder logá-lo aqui.
+        local workdir_path = last_result.output and last_result.output.workdir or "N/A"
+        log.error("Tarefa falhou. O workdir será MANTIDO para depuração em: " .. workdir_path)
+        return false
+      end
+    end,
+
+    tasks = {
+      {
+        name = "run_failure_script",
+        command = function(params, workdir)
+          log.info("Executando em workdir efêmero (deve ser único): " .. workdir)
+          
+          exec.command("cp", "failing_app.py", workdir .. "/app.py")
+          exec.command("cp", "requirements.txt", workdir .. "/requirements.txt")
+
+          local python = require("python")
+          local venv = python.venv(workdir .. "/.venv")
+          venv:create()
+          venv:pip("install -r " .. workdir .. "/requirements.txt")
+          local result = venv:exec(workdir .. "/app.py")
+          
+          -- Adiciona o workdir ao resultado para a função de limpeza poder logá-lo.
+          result.workdir = workdir
+          return result.success, "Script de falha executado.", result
+        end
+      }
+    }
+  },
+
+  -- =================================================================================
+  -- CENÁRIO 3: Workdir de caminho fixo, sempre limpo (para CI/CD).
+  -- =================================================================================
+  fixed_always_clean = {
+    description = "Usa um workdir de caminho fixo. O workdir deve ser SEMPRE REMOVIDO.",
+    
+    create_workdir_before_run = true,
+
+    clean_workdir_after_run = function(last_result)
+      log.info("Política de limpeza para workdir fixo: sempre remover, independentemente do resultado.")
+      return true
+    end,
+
+    tasks = {
+      {
+        name = "run_in_fixed_workdir",
+        command = function(params, workdir)
+          log.info("Executando em workdir fixo (deve ser /tmp/fixed_always_clean): " .. workdir)
+          
+          exec.command("cp", "succeeding_app.py", workdir .. "/app.py")
+          exec.command("cp", "requirements.txt", workdir .. "/requirements.txt")
+
+          local python = require("python")
+          local venv = python.venv(workdir .. "/.venv")
+          venv:create()
+          venv:pip("install -r " .. workdir .. "/requirements.txt")
+          local result = venv:exec(workdir .. "/app.py")
+          
+          return result.success, "Script de sucesso executado em workdir fixo.", result
+        end
+      }
+    }
+  }
+})
diff --git a/go.mod b/go.mod
index 65c65f5..221a0e7 100644
--- a/go.mod
+++ b/go.mod
@@ -4,6 +4,7 @@ go 1.25.1
 
 require (
 	github.com/AlecAivazis/survey/v2 v2.3.7
+	github.com/go-git/go-git/v5 v5.16.2
 	github.com/pterm/pterm v0.12.81
 	github.com/spf13/cobra v1.10.1
 	github.com/stretchr/testify v1.11.1
@@ -12,26 +13,45 @@ require (
 )
 
 replace github.com/chalkan3/sloth-runner => .
+
 require (
 	atomicgo.dev/cursor v0.2.0 // indirect
 	atomicgo.dev/keyboard v0.2.9 // indirect
 	atomicgo.dev/schedule v0.1.0 // indirect
+	dario.cat/mergo v1.0.0 // indirect
+	github.com/Microsoft/go-winio v0.6.2 // indirect
+	github.com/ProtonMail/go-crypto v1.1.6 // indirect
+	github.com/cloudflare/circl v1.6.1 // indirect
 	github.com/containerd/console v1.0.5 // indirect
+	github.com/cyphar/filepath-securejoin v0.4.1 // indirect
 	github.com/davecgh/go-spew v1.1.1 // indirect
+	github.com/emirpasic/gods v1.18.1 // indirect
+	github.com/go-git/gcfg v1.5.1-0.20230307220236-3a3c6141e376 // indirect
+	github.com/go-git/go-billy/v5 v5.6.2 // indirect
+	github.com/golang/groupcache v0.0.0-20241129210726-2c02b8208cf8 // indirect
 	github.com/gookit/color v1.5.4 // indirect
 	github.com/inconshreveable/mousetrap v1.1.0 // indirect
+	github.com/jbenet/go-context v0.0.0-20150711004518-d14ea06fba99 // indirect
 	github.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51 // indirect
+	github.com/kevinburke/ssh_config v1.2.0 // indirect
 	github.com/lithammer/fuzzysearch v1.1.8 // indirect
 	github.com/mattn/go-colorable v0.1.2 // indirect
 	github.com/mattn/go-isatty v0.0.8 // indirect
 	github.com/mattn/go-runewidth v0.0.16 // indirect
 	github.com/mgutz/ansi v0.0.0-20170206155736-9520e82c474b // indirect
+	github.com/pjbgf/sha1cd v0.3.2 // indirect
 	github.com/pmezard/go-difflib v1.0.0 // indirect
 	github.com/rivo/uniseg v0.4.7 // indirect
+	github.com/sergi/go-diff v1.3.2-0.20230802210424-5b0b94c5c0d3 // indirect
+	github.com/skeema/knownhosts v1.3.1 // indirect
 	github.com/spf13/pflag v1.0.9 // indirect
+	github.com/xanzy/ssh-agent v0.3.3 // indirect
 	github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e // indirect
+	golang.org/x/crypto v0.37.0 // indirect
+	golang.org/x/net v0.39.0 // indirect
 	golang.org/x/sys v0.33.0 // indirect
 	golang.org/x/term v0.32.0 // indirect
 	golang.org/x/text v0.26.0 // indirect
+	gopkg.in/warnings.v0 v0.1.2 // indirect
 	gopkg.in/yaml.v3 v3.0.1 // indirect
 )
diff --git a/go.sum b/go.sum
index 5e4bae9..16306a2 100644
--- a/go.sum
+++ b/go.sum
@@ -6,6 +6,8 @@ atomicgo.dev/keyboard v0.2.9 h1:tOsIid3nlPLZ3lwgG8KZMp/SFmr7P0ssEN5JUsm78K8=
 atomicgo.dev/keyboard v0.2.9/go.mod h1:BC4w9g00XkxH/f1HXhW2sXmJFOCWbKn9xrOunSFtExQ=
 atomicgo.dev/schedule v0.1.0 h1:nTthAbhZS5YZmgYbb2+DH8uQIZcTlIrd4eYr3UQxEjs=
 atomicgo.dev/schedule v0.1.0/go.mod h1:xeUa3oAkiuHYh8bKiQBRojqAMq3PXXbJujjb0hw8pEU=
+dario.cat/mergo v1.0.0 h1:AGCNq9Evsj31mOgNPcLyXc+4PNABt905YmuqPYYpBWk=
+dario.cat/mergo v1.0.0/go.mod h1:uNxQE+84aUszobStD9th8a29P2fMDhsBdgRYvZOxGmk=
 github.com/AlecAivazis/survey/v2 v2.3.7 h1:6I/u8FvytdGsgonrYsVn2t8t4QiRnh6QSTqkkhIiSjQ=
 github.com/AlecAivazis/survey/v2 v2.3.7/go.mod h1:xUTIdE4KCOIjsBAE1JYsUPoCqYdZ1reCfTwbto0Fduo=
 github.com/MarvinJWendt/testza v0.1.0/go.mod h1:7AxNvlfeHP7Z/hDQ5JtE3OKYT3XFUeLCDE2DQninSqs=
@@ -17,18 +19,49 @@ github.com/MarvinJWendt/testza v0.3.0/go.mod h1:eFcL4I0idjtIx8P9C6KkAuLgATNKpX4/
 github.com/MarvinJWendt/testza v0.4.2/go.mod h1:mSdhXiKH8sg/gQehJ63bINcCKp7RtYewEjXsvsVUPbE=
 github.com/MarvinJWendt/testza v0.5.2 h1:53KDo64C1z/h/d/stCYCPY69bt/OSwjq5KpFNwi+zB4=
 github.com/MarvinJWendt/testza v0.5.2/go.mod h1:xu53QFE5sCdjtMCKk8YMQ2MnymimEctc4n3EjyIYvEY=
+github.com/Microsoft/go-winio v0.5.2/go.mod h1:WpS1mjBmmwHBEWmogvA2mj8546UReBk4v8QkMxJ6pZY=
+github.com/Microsoft/go-winio v0.6.2 h1:F2VQgta7ecxGYO8k3ZZz3RS8fVIXVxONVUPlNERoyfY=
+github.com/Microsoft/go-winio v0.6.2/go.mod h1:yd8OoFMLzJbo9gZq8j5qaps8bJ9aShtEA8Ipt1oGCvU=
 github.com/Netflix/go-expect v0.0.0-20220104043353-73e0943537d2 h1:+vx7roKuyA63nhn5WAunQHLTznkw5W8b1Xc0dNjp83s=
 github.com/Netflix/go-expect v0.0.0-20220104043353-73e0943537d2/go.mod h1:HBCaDeC1lPdgDeDbhX8XFpy1jqjK0IBG8W5K+xYqA0w=
+github.com/ProtonMail/go-crypto v1.1.6 h1:ZcV+Ropw6Qn0AX9brlQLAUXfqLBc7Bl+f/DmNxpLfdw=
+github.com/ProtonMail/go-crypto v1.1.6/go.mod h1:rA3QumHc/FZ8pAHreoekgiAbzpNsfQAosU5td4SnOrE=
+github.com/anmitsu/go-shlex v0.0.0-20200514113438-38f4b401e2be h1:9AeTilPcZAjCFIImctFaOjnTIavg87rW78vTPkQqLI8=
+github.com/anmitsu/go-shlex v0.0.0-20200514113438-38f4b401e2be/go.mod h1:ySMOLuWl6zY27l47sB3qLNK6tF2fkHG55UZxx8oIVo4=
+github.com/armon/go-socks5 v0.0.0-20160902184237-e75332964ef5 h1:0CwZNZbxp69SHPdPJAN/hZIm0C4OItdklCFmMRWYpio=
+github.com/armon/go-socks5 v0.0.0-20160902184237-e75332964ef5/go.mod h1:wHh0iHkYZB8zMSxRWpUBQtwG5a7fFgvEO+odwuTv2gs=
 github.com/atomicgo/cursor v0.0.1/go.mod h1:cBON2QmmrysudxNBFthvMtN32r3jxVRIvzkUiF/RuIk=
+github.com/cloudflare/circl v1.6.1 h1:zqIqSPIndyBh1bjLVVDHMPpVKqp8Su/V+6MeDzzQBQ0=
+github.com/cloudflare/circl v1.6.1/go.mod h1:uddAzsPgqdMAYatqJ0lsjX1oECcQLIlRpzZh3pJrofs=
 github.com/containerd/console v1.0.3/go.mod h1:7LqA/THxQ86k76b8c/EMSiaJ3h1eZkMkXar0TQ1gf3U=
 github.com/containerd/console v1.0.5 h1:R0ymNeydRqH2DmakFNdmjR2k0t7UPuiOV/N/27/qqsc=
 github.com/containerd/console v1.0.5/go.mod h1:YynlIjWYF8myEu6sdkwKIvGQq+cOckRm6So2avqoYAk=
 github.com/cpuguy83/go-md2man/v2 v2.0.6/go.mod h1:oOW0eioCTA6cOiMLiUPZOpcVxMig6NIQQ7OS05n1F4g=
 github.com/creack/pty v1.1.17 h1:QeVUsEDNrLBW4tMgZHvxy18sKtr6VI492kBhUfhDJNI=
 github.com/creack/pty v1.1.17/go.mod h1:MOBLtS5ELjhRRrroQr9kyvTxUAFNvYEK993ew/Vr4O4=
+github.com/cyphar/filepath-securejoin v0.4.1 h1:JyxxyPEaktOD+GAnqIqTf9A8tHyAG22rowi7HkoSU1s=
+github.com/cyphar/filepath-securejoin v0.4.1/go.mod h1:Sdj7gXlvMcPZsbhwhQ33GguGLDGQL7h7bg04C/+u9jI=
 github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
 github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
 github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
+github.com/elazarl/goproxy v1.7.2 h1:Y2o6urb7Eule09PjlhQRGNsqRfPmYI3KKQLFpCAV3+o=
+github.com/elazarl/goproxy v1.7.2/go.mod h1:82vkLNir0ALaW14Rc399OTTjyNREgmdL2cVoIbS6XaE=
+github.com/emirpasic/gods v1.18.1 h1:FXtiHYKDGKCW2KzwZKx0iC0PQmdlorYgdFG9jPXJ1Bc=
+github.com/emirpasic/gods v1.18.1/go.mod h1:8tpGGwCnJ5H4r6BWwaV6OrWmMoPhUl5jm/FMNAnJvWQ=
+github.com/gliderlabs/ssh v0.3.8 h1:a4YXD1V7xMF9g5nTkdfnja3Sxy1PVDCj1Zg4Wb8vY6c=
+github.com/gliderlabs/ssh v0.3.8/go.mod h1:xYoytBv1sV0aL3CavoDuJIQNURXkkfPA/wxQ1pL1fAU=
+github.com/go-git/gcfg v1.5.1-0.20230307220236-3a3c6141e376 h1:+zs/tPmkDkHx3U66DAb0lQFJrpS6731Oaa12ikc+DiI=
+github.com/go-git/gcfg v1.5.1-0.20230307220236-3a3c6141e376/go.mod h1:an3vInlBmSxCcxctByoQdvwPiA7DTK7jaaFDBTtu0ic=
+github.com/go-git/go-billy/v5 v5.6.2 h1:6Q86EsPXMa7c3YZ3aLAQsMA0VlWmy43r6FHqa/UNbRM=
+github.com/go-git/go-billy/v5 v5.6.2/go.mod h1:rcFC2rAsp/erv7CMz9GczHcuD0D32fWzH+MJAU+jaUU=
+github.com/go-git/go-git-fixtures/v4 v4.3.2-0.20231010084843-55a94097c399 h1:eMje31YglSBqCdIqdhKBW8lokaMrL3uTkpGYlE2OOT4=
+github.com/go-git/go-git-fixtures/v4 v4.3.2-0.20231010084843-55a94097c399/go.mod h1:1OCfN199q1Jm3HZlxleg+Dw/mwps2Wbk9frAWm+4FII=
+github.com/go-git/go-git/v5 v5.16.2 h1:fT6ZIOjE5iEnkzKyxTHK1W4HGAsPhqEqiSAssSO77hM=
+github.com/go-git/go-git/v5 v5.16.2/go.mod h1:4Ge4alE/5gPs30F2H1esi2gPd69R0C39lolkucHBOp8=
+github.com/golang/groupcache v0.0.0-20241129210726-2c02b8208cf8 h1:f+oWsMOmNPc8JmEHVZIycC7hBoQxHH9pNKQORJNozsQ=
+github.com/golang/groupcache v0.0.0-20241129210726-2c02b8208cf8/go.mod h1:wcDNUvekVysuuOpQKo3191zZyTpiI6se1N1ULghS0sw=
+github.com/google/go-cmp v0.7.0 h1:wk8382ETsv4JYUZwIsn6YpYiWiBsYLSJiTsyBybVuN8=
+github.com/google/go-cmp v0.7.0/go.mod h1:pXiqmnSA92OHEEa9HXL2W4E7lf9JzCmGVUdgjX3N/iU=
 github.com/gookit/color v1.4.2/go.mod h1:fqRyamkC1W8uxl+lxCQxOT09l/vYfZ+QeiX3rKQHCoQ=
 github.com/gookit/color v1.5.0/go.mod h1:43aQb+Zerm/BWh2GnrgOQm7ffz7tvQXEKV6BFMl7wAo=
 github.com/gookit/color v1.5.4 h1:FZmqs7XOyGgCAxmWyPslpiok1k05wmY3SJTytgvYFs0=
@@ -37,18 +70,24 @@ github.com/hinshun/vt10x v0.0.0-20220119200601-820417d04eec h1:qv2VnGeEQHchGaZ/u
 github.com/hinshun/vt10x v0.0.0-20220119200601-820417d04eec/go.mod h1:Q48J4R4DvxnHolD5P8pOtXigYlRuPLGl6moFx3ulM68=
 github.com/inconshreveable/mousetrap v1.1.0 h1:wN+x4NVGpMsO7ErUn/mUI3vEoE6Jt13X2s0bqwp9tc8=
 github.com/inconshreveable/mousetrap v1.1.0/go.mod h1:vpF70FUmC8bwa3OWnCshd2FqLfsEA9PFc4w1p2J65bw=
+github.com/jbenet/go-context v0.0.0-20150711004518-d14ea06fba99 h1:BQSFePA1RWJOlocH6Fxy8MmwDt+yVQYULKfN0RoTN8A=
+github.com/jbenet/go-context v0.0.0-20150711004518-d14ea06fba99/go.mod h1:1lJo3i6rXxKeerYnT8Nvf0QmHCRC1n8sfWVwXF2Frvo=
 github.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51 h1:Z9n2FFNUXsshfwJMBgNA0RU6/i7WVaAegv3PtuIHPMs=
 github.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51/go.mod h1:CzGEWj7cYgsdH8dAjBGEr58BoE7ScuLd+fwFZ44+/x8=
+github.com/kevinburke/ssh_config v1.2.0 h1:x584FjTGwHzMwvHx18PXxbBVzfnxogHaAReU4gf13a4=
+github.com/kevinburke/ssh_config v1.2.0/go.mod h1:CT57kijsi8u/K/BOFA39wgDQJ9CxiF4nAY/ojJ6r6mM=
 github.com/klauspost/cpuid/v2 v2.0.9/go.mod h1:FInQzS24/EEf25PyTYn52gqo7WaD8xa0213Md/qVLRg=
 github.com/klauspost/cpuid/v2 v2.0.10/go.mod h1:g2LTdtYhdyuGPqyWyv7qRAmj1WBqxuObKfj5c0PQa7c=
 github.com/klauspost/cpuid/v2 v2.0.12/go.mod h1:g2LTdtYhdyuGPqyWyv7qRAmj1WBqxuObKfj5c0PQa7c=
 github.com/klauspost/cpuid/v2 v2.2.3 h1:sxCkb+qR91z4vsqw4vGGZlDgPz3G7gjaLyK3V8y70BU=
 github.com/klauspost/cpuid/v2 v2.2.3/go.mod h1:RVVoqg1df56z8g3pUjL/3lE5UfnlrJX8tyFgg4nqhuY=
-github.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=
 github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
+github.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=
+github.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=
 github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
-github.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=
 github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
+github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
+github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
 github.com/lithammer/fuzzysearch v1.1.8 h1:/HIuJnjHuXS8bKaiTMeeDlW2/AyIWk2brx1V8LFgLN4=
 github.com/lithammer/fuzzysearch v1.1.8/go.mod h1:IdqeyBClc3FFqSzYq/MXESsS4S0FsZ5ajtkr5xPLts4=
 github.com/mattn/go-colorable v0.1.2 h1:/bC9yWikZXAL9uJdulbSfyVNIR3n3trXl+v8+1sx8mU=
@@ -60,6 +99,12 @@ github.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6T
 github.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=
 github.com/mgutz/ansi v0.0.0-20170206155736-9520e82c474b h1:j7+1HpAFS1zy5+Q4qx1fWh90gTKwiN4QCGoY9TWyyO4=
 github.com/mgutz/ansi v0.0.0-20170206155736-9520e82c474b/go.mod h1:01TrycV0kFyexm33Z7vhZRXopbI8J3TDReVlkTgMUxE=
+github.com/onsi/gomega v1.34.1 h1:EUMJIKUjM8sKjYbtxQI9A4z2o+rruxnzNvpknOXie6k=
+github.com/onsi/gomega v1.34.1/go.mod h1:kU1QgUvBDLXBJq618Xvm2LUX6rSAfRaFRTcdOeDLwwY=
+github.com/pjbgf/sha1cd v0.3.2 h1:a9wb0bp1oC2TGwStyn0Umc/IGKQnEgF0vVaZ8QF8eo4=
+github.com/pjbgf/sha1cd v0.3.2/go.mod h1:zQWigSxVmsHEZow5qaLtPYxpcKMMQpa09ixqBxuCS6A=
+github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
+github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
 github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
 github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
 github.com/pterm/pterm v0.12.27/go.mod h1:PhQ89w4i95rhgE+xedAoqous6K9X+r6aSOI2eFF7DZI=
@@ -74,19 +119,28 @@ github.com/pterm/pterm v0.12.81/go.mod h1:TyuyrPjnxfwP+ccJdBTeWHtd/e0ybQHkOS/Tak
 github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
 github.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=
 github.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=
+github.com/rogpeppe/go-internal v1.14.1 h1:UQB4HGPB6osV0SQTLymcB4TgvyWu6ZyliaW0tI/otEQ=
+github.com/rogpeppe/go-internal v1.14.1/go.mod h1:MaRKkUm5W0goXpeCfT7UZI6fk/L7L7so1lCWt35ZSgc=
 github.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=
-github.com/sergi/go-diff v1.2.0 h1:XU+rvMAioB0UC3q1MFrIQy4Vo5/4VsRDQQXHsEya6xQ=
 github.com/sergi/go-diff v1.2.0/go.mod h1:STckp+ISIX8hZLjrqAeVduY0gWCT9IjLuqbuNXdaHfM=
+github.com/sergi/go-diff v1.3.2-0.20230802210424-5b0b94c5c0d3 h1:n661drycOFuPLCN3Uc8sB6B/s6Z4t2xvBgU1htSHuq8=
+github.com/sergi/go-diff v1.3.2-0.20230802210424-5b0b94c5c0d3/go.mod h1:A0bzQcvG0E7Rwjx0REVgAGH58e96+X0MeOfepqsbeW4=
+github.com/sirupsen/logrus v1.7.0/go.mod h1:yWOB1SBYBC5VeMP7gHvWumXLIWorT60ONWic61uBYv0=
+github.com/skeema/knownhosts v1.3.1 h1:X2osQ+RAjK76shCbvhHHHVl3ZlgDm8apHEHFqRjnBY8=
+github.com/skeema/knownhosts v1.3.1/go.mod h1:r7KTdC8l4uxWRyK2TpQZ/1o5HaSzh06ePQNxPwTcfiY=
 github.com/spf13/cobra v1.10.1 h1:lJeBwCfmrnXthfAupyUTzJ/J4Nc1RsHC/mSRU2dll/s=
 github.com/spf13/cobra v1.10.1/go.mod h1:7SmJGaTHFVBY0jW4NXGluQoLvhqFQM+6XSKD+P4XaB0=
 github.com/spf13/pflag v1.0.9 h1:9exaQaMOCwffKiiiYk6/BndUBv+iRViNW+4lEMi0PvY=
 github.com/spf13/pflag v1.0.9/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=
 github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
+github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=
 github.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=
 github.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
 github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
 github.com/stretchr/testify v1.11.1 h1:7s2iGBzp5EwR7/aIZr8ao5+dra3wiQyKjjFuvgVKu7U=
 github.com/stretchr/testify v1.11.1/go.mod h1:wZwfW3scLgRK+23gO65QZefKpKQRnfz6sD981Nm4B6U=
+github.com/xanzy/ssh-agent v0.3.3 h1:+/15pJfg/RsTxqYcX6fHqOXZwwMP+2VyYWJeWM2qQFM=
+github.com/xanzy/ssh-agent v0.3.3/go.mod h1:6dzNDKs0J9rVPHPhaGCukekBHKqfl+L3KghI1Bc68Uw=
 github.com/xo/terminfo v0.0.0-20210125001918-ca9a967f8778/go.mod h1:2MuV+tbUrU1zIOPMxZ5EncGwgmMJsa+9ucAQZXxsObs=
 github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e h1:JVG44RsyaB9T2KIHavMF/ppJZNG9ZpyihvCd0w101no=
 github.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e/go.mod h1:RbqR21r5mrJuqunuUZ/Dhy/avygyECGrLceyNeo4LiM=
@@ -95,26 +149,35 @@ github.com/yuin/gopher-lua v1.1.1 h1:kYKnWBjvbNP4XLT3+bPEwAXJx262OhaHDWDVOPjL46M
 github.com/yuin/gopher-lua v1.1.1/go.mod h1:GBR0iDaNXjAgGg9zfCvksxSRnQx76gclCIb7kdAd1Pw=
 golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
 golang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=
-golang.org/x/exp v0.0.0-20220909182711-5c715a9e8561 h1:MDc5xs78ZrZr3HMQugiXOAkSZtfTpbJLDr/lwfgO53E=
-golang.org/x/exp v0.0.0-20220909182711-5c715a9e8561/go.mod h1:cyybsKvd6eL0RnXn6p/Grxp8F5bW7iYuBgsNCOHpMYE=
+golang.org/x/crypto v0.0.0-20220622213112-05595931fe9d/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=
+golang.org/x/crypto v0.37.0 h1:kJNSjF/Xp7kU0iB2Z+9viTPMW4EqqsrywMXLJOOsXSE=
+golang.org/x/crypto v0.37.0/go.mod h1:vg+k43peMZ0pUMhYmVAWysMK35e6ioLh3wB8ZCAfbVc=
+golang.org/x/exp v0.0.0-20240719175910-8a7402abbf56 h1:2dVuKD2vS7b0QIHQbpyTISPd0LeHDbnYEryqj5Q1ug8=
+golang.org/x/exp v0.0.0-20240719175910-8a7402abbf56/go.mod h1:M4RDyNAINzryxdtnbRXRL/OHtkFuWGRjvuhBJpk2IlY=
 golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=
 golang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=
 golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
 golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
+golang.org/x/net v0.0.0-20211112202133-69e39bad7dc2/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
 golang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=
 golang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=
+golang.org/x/net v0.39.0 h1:ZCu7HMWDxpXpaiKdhzIfaltL9Lp31x/3fCP11bc6/fY=
+golang.org/x/net v0.39.0/go.mod h1:X7NRbYVEA+ewNkCNyJ513WmMdQ3BineSwVtN2zD/d+E=
 golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
 golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
 golang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
 golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
 golang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
+golang.org/x/sys v0.0.0-20191026070338-33540a1f6037/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
 golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
 golang.org/x/sys v0.0.0-20210124154548-22da62e12c0c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
 golang.org/x/sys v0.0.0-20210330210617-4fbd30eecc44/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
+golang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
 golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.0.0-20211013075003-97ac67df715c/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.0.0-20220319134239-a9b59b0215f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
+golang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.1.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
 golang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
@@ -129,6 +192,7 @@ golang.org/x/term v0.32.0 h1:DR4lr0TjUs3epypdhTOkMmuF5CDFJ/8pOnbzMZPQ7bg=
 golang.org/x/term v0.32.0/go.mod h1:uZG1FhGx848Sqfsq4/DlJr3xGGsYMu/L5GW4abiaEPQ=
 golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
 golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
+golang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
 golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
 golang.org/x/text v0.4.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=
 golang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=
@@ -141,8 +205,11 @@ golang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc
 golang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=
 golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
 gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
-gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15 h1:YR8cESwS4TdDjEe65xsg0ogRM/Nc3DYOhEAlW+xobZo=
 gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
+gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=
+gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=
+gopkg.in/warnings.v0 v0.1.2 h1:wFXVbFY8DY5/xOe1ECiWdKCzZlxgshcYVNkBHstARME=
+gopkg.in/warnings.v0 v0.1.2/go.mod h1:jksf8JmL6Qr/oQM2OXTHunEvvTAsrWBLb6OOjuVWRNI=
 gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
 gopkg.in/yaml.v2 v2.2.4/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
 gopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=
diff --git a/internal/luainterface/git.go b/internal/luainterface/git.go
index 3cc2c50..c6988e3 100644
--- a/internal/luainterface/git.go
+++ b/internal/luainterface/git.go
@@ -3,264 +3,189 @@ package luainterface
 import (
 	"bytes"
 	"fmt"
-	"log"
 	"os"
+	"os/exec"
 	"path/filepath"
-	"strings"
 
+	"github.com/go-git/go-git/v5"
 	lua "github.com/yuin/gopher-lua"
 )
 
-// luaGitRepoTypeName is the name of the Lua userdata type for GitRepo.
-const luaGitRepoTypeName = "git_repo"
+const (
+	luaRepoTypeName = "repo"
+)
+
+// --- Métodos do Objeto Repo ---
 
-// GitRepo holds the state for a fluent Git API call.
-type GitRepo struct {
-	RepoPath string
-	// Store the result of the last operation for inspection in Lua
-	lastSuccess bool
-	lastStdout  string
-	lastStderr  string
-	lastError   error // Go error
+// repo:pull()
+func repoPull(L *lua.LState) int {
+	repo := checkRepo(L, 1)
+	// Lógica de pull (exemplo)
+	fmt.Printf("Executando git pull no repositório em %s\n", repo.Path)
+	// Aqui entraria a lógica real do go-git para pull
+	L.Push(L.Get(1)) // Retorna o próprio objeto para encadeamento
+	return 1
 }
 
-// OpenGit registers the 'git' module with the Lua state.
-func OpenGit(L *lua.LState) {
-	// Create the metatable for the GitRepo type.
-	mt := L.NewTypeMetatable(luaGitRepoTypeName)
-	L.SetGlobal(luaGitRepoTypeName, mt) // Optional: make metatable available globally.
+// repo:commit(message)
+func repoCommit(L *lua.LState) int {
+	repo := checkRepo(L, 1)
+	message := L.CheckString(2)
+	// Lógica de commit (exemplo)
+	fmt.Printf("Executando git commit em %s com a mensagem: '%s'\n", repo.Path, message)
+	// Aqui entraria a lógica real do go-git para commit
+	L.Push(L.Get(1)) // Retorna o próprio objeto
+	return 1
+}
 
-	// Register methods for the GitRepo type.
-	methods := map[string]lua.LGFunction{
-		"checkout": gitRepoCheckout,
-		"pull":     gitRepoPull,
-		"add":      gitRepoAdd,
-		"commit":   gitRepoCommit,
-		"tag":      gitRepoTag,
-		"push":     gitRepoPush,
-		"result":   gitRepoResult, // New method to get results of the last operation
-	}
-	L.SetField(mt, "__index", L.SetFuncs(L.NewTable(), methods))
+// repo:push()
+func repoPush(L *lua.LState) int {
+	repo := checkRepo(L, 1)
+	// Lógica de push (exemplo)
+	fmt.Printf("Executando git push no repositório em %s\n", repo.Path)
+	// Aqui entraria a lógica real do go-git para push
+	L.Push(L.Get(1)) // Retorna o próprio objeto
+	return 1
+}
 
-	// Create the main 'git' module table.
-	gitModule := L.NewTable()
+// --- Métodos do Módulo Git ---
 
-	// Register top-level functions like git.clone() and git.repo().
-	gitFuncs := map[string]lua.LGFunction{
-		"clone": gitClone,
-		"repo":  gitRepo,
-	}
-	L.SetFuncs(gitModule, gitFuncs)
+// git:clone(url, path) -> { success, stdout, stderr }
+func gitClone(L *lua.LState) int {
+	url := L.CheckString(1)
+	path := L.CheckString(2)
 
-	// Make the 'git' module available globally.
-	L.SetGlobal("git", gitModule)
+	// Usa os/exec para ter uma saída mais clara, similar aos outros módulos.
+	cmd := exec.Command("git", "clone", url, path)
+	var stdout, stderr bytes.Buffer
+	cmd.Stdout = &stdout
+	cmd.Stderr = &stderr
+
+	err := cmd.Run()
+	success := err == nil
+
+	result := L.NewTable()
+	result.RawSetString("success", lua.LBool(success))
+	result.RawSetString("stdout", lua.LString(stdout.String()))
+	result.RawSetString("stderr", lua.LString(stderr.String()))
+	L.Push(result)
+	return 1
 }
 
-// checkGitRepo retrieves the GitRepo struct from a Lua userdata.
-func checkGitRepo(L *lua.LState) *GitRepo {
-	ud := L.CheckUserData(1)
-	if v, ok := ud.Value.(*GitRepo); ok {
-		return v
+// git:repo(path) -> repo (Este método parece obsoleto, mas vamos mantê-lo por enquanto)
+func gitRepo(L *lua.LState) int {
+	path := L.CheckString(1)
+	if _, err := os.Stat(path); os.IsNotExist(err) {
+		L.RaiseError("diretório do repositório não encontrado em: %s", path)
+		return 0
 	}
-	L.ArgError(1, "git_repo expected")
-	return nil
+	// A API original deste método não está clara, retornando sucesso por padrão.
+	result := L.NewTable()
+	result.RawSetString("success", lua.LBool(true))
+	L.Push(result)
+	return 1
 }
 
-// runGitCommand executes a Git CLI command and updates the GitRepo's last operation status.
-func runGitCommand(L *lua.LState, repo *GitRepo, args []string) {
-	cmd := ExecCommand("git", args...)
-	cmd.Dir = repo.RepoPath // Set working directory for the git command
-	var stdoutBuf, stderrBuf bytes.Buffer
-	cmd.Stdout = &stdoutBuf
-	cmd.Stderr = &stderrBuf
-
-	log.Printf("Executing Git command in %s: git %s", repo.RepoPath, strings.Join(args, " "))
+// --- Funções Auxiliares ---
 
-	err := cmd.Run()
+// Estrutura Go para armazenar os dados do repositório
+type RepoData struct {
+	Path          string
+	URL           string
+	CurrentBranch string
+}
 
-	repo.lastStdout = stdoutBuf.String()
-	repo.lastStderr = stderrBuf.String()
+// Cria e retorna o objeto repo (tabela Lua)
+func createRepoObject(L *lua.LState, path string) int {
+	absPath, err := filepath.Abs(path)
 	if err != nil {
-		repo.lastSuccess = false
-		repo.lastError = err
-	} else {
-		repo.lastSuccess = true
-		repo.lastError = nil
+		L.RaiseError("não foi possível obter o caminho absoluto para: %s", path)
+		return 0
 	}
-}
 
-// gitClone implements the git.clone(url, path) function.
-func gitClone(L *lua.LState) int {
-	repoURL := L.CheckString(1)
-	repoPath := L.CheckString(2)
+	repoData := &RepoData{Path: absPath}
 
-	// Check if path exists and is already a git repo
-	if _, err := os.Stat(filepath.Join(repoPath, ".git")); err == nil {
-		L.Push(lua.LNil) // Return nil for the repo object
-		L.Push(lua.LString(fmt.Sprintf("path %s already contains a git repository", repoPath))) // Return error message
-		return 2
+	// Tenta abrir o repositório para preencher mais dados
+	r, err := git.PlainOpen(absPath)
+	if err == nil {
+		// Obter URL remota
+		remote, err := r.Remote("origin")
+		if err == nil {
+			repoData.URL = remote.Config().URLs[0]
+		}
+		// Obter branch atual
+		head, err := r.Head()
+		if err == nil {
+			repoData.CurrentBranch = head.Name().Short()
+		}
 	}
 
-	cmd := ExecCommand("git", "clone", repoURL, repoPath)
-	var stdoutBuf, stderrBuf bytes.Buffer
-	cmd.Stdout = &stdoutBuf
-	cmd.Stderr = &stderrBuf
+	// Cria a tabela principal para o objeto repo
+	repoTable := L.NewTable()
 
-	log.Printf("Cloning repository: git clone %s %s", repoURL, repoPath)
+	// Cria e preenche a tabela 'local'
+	localTable := L.NewTable()
+	L.SetField(localTable, "path", lua.LString(repoData.Path))
+	L.SetField(repoTable, "local", localTable)
 
-	err := cmd.Run()
+	// Cria e preenche a tabela 'remote'
+	remoteTable := L.NewTable()
+	L.SetField(remoteTable, "url", lua.LString(repoData.URL))
+	L.SetField(repoTable, "remote", remoteTable)
 
-	if err != nil {
-		L.Push(lua.LNil)
-		L.Push(lua.LString(fmt.Sprintf("failed to clone repository: %s, stdout: %s, stderr: %s", err.Error(), stdoutBuf.String(), stderrBuf.String())))
-		return 2
-	}
+	// Cria e preenche a tabela 'current'
+	currentTable := L.NewTable()
+	L.SetField(currentTable, "branch", lua.LString(repoData.CurrentBranch))
+	L.SetField(repoTable, "current", currentTable)
 
-	repo := &GitRepo{
-		RepoPath:    repoPath,
-		lastSuccess: true,
-		lastStdout:  stdoutBuf.String(),
-		lastStderr:  stderrBuf.String(),
-		lastError:   nil,
-	}
+	// Anexa o RepoData como userdata para uso interno nos métodos
 	ud := L.NewUserData()
-	ud.Value = repo
-	L.SetMetatable(ud, L.GetTypeMetatable(luaGitRepoTypeName))
-	L.Push(ud)
-	L.Push(lua.LNil) // No error
-	return 2
-}
-
-// gitRepo implements the git.repo(path) function.
-func gitRepo(L *lua.LState) int {
-	repoPath := L.CheckString(1)
+	ud.Value = repoData
+	L.SetField(repoTable, "__internal", ud)
 
-	// Check if it's a valid git repository
-	if _, err := os.Stat(filepath.Join(repoPath, ".git")); os.IsNotExist(err) {
-		L.Push(lua.LNil)
-		L.Push(lua.LString(fmt.Sprintf("path %s is not a git repository", repoPath)))
-		return 2
-	}
-
-	repo := &GitRepo{
-		RepoPath:    repoPath,
-		lastSuccess: true, // Assume success if it's a valid repo
-		lastStdout:  "",
-		lastStderr:  "",
-		lastError:   nil,
-	}
-	ud := L.NewUserData()
-	ud.Value = repo
-	L.SetMetatable(ud, L.GetTypeMetatable(luaGitRepoTypeName))
-	L.Push(ud)
-	L.Push(lua.LNil) // No error
-	return 2
-}
+	// Define a metatable que aponta para os métodos do repo
+	L.SetMetatable(repoTable, L.GetTypeMetatable(luaRepoTypeName))
 
-// gitRepoCheckout implements the GitRepo:checkout(ref) method.
-func gitRepoCheckout(L *lua.LState) int {
-	repo := checkGitRepo(L)
-	if repo == nil {
-		return 0
-	}
-	ref := L.CheckString(2)
-	runGitCommand(L, repo, []string{"checkout", ref})
-	L.Push(L.CheckUserData(1)) // Return self for chaining
+	L.Push(repoTable)
 	return 1
 }
 
-// gitRepoPull implements the GitRepo:pull(remote, branch) method.
-func gitRepoPull(L *lua.LState) int {
-	repo := checkGitRepo(L)
-	if repo == nil {
-		return 0
+// Verifica se o argumento é um objeto repo e retorna o RepoData interno
+func checkRepo(L *lua.LState, n int) *RepoData {
+	tbl := L.CheckTable(n)
+	ud, ok := L.GetField(tbl, "__internal").(*lua.LUserData)
+	if !ok {
+		L.ArgError(n, "objeto repo inválido")
 	}
-	remote := L.CheckString(2)
-	branch := L.CheckString(3)
-	runGitCommand(L, repo, []string{"pull", remote, branch})
-	L.Push(L.CheckUserData(1)) // Return self for chaining
-	return 1
-}
-
-// gitRepoAdd implements the GitRepo:add(pattern) method.
-func gitRepoAdd(L *lua.LState) int {
-	repo := checkGitRepo(L)
-	if repo == nil {
-		return 0
+	repo, ok := ud.Value.(*RepoData)
+	if !ok {
+		L.ArgError(n, "userdata de repo inválido")
 	}
-	pattern := L.CheckString(2)
-	runGitCommand(L, repo, []string{"add", pattern})
-	L.Push(L.CheckUserData(1)) // Return self for chaining
-	return 1
+	return repo
 }
 
-// gitRepoCommit implements the GitRepo:commit(message) method.
-func gitRepoCommit(L *lua.LState) int {
-	repo := checkGitRepo(L)
-	if repo == nil {
-		return 0
-	}
-	message := L.CheckString(2)
-	runGitCommand(L, repo, []string{"commit", "-m", message})
-	L.Push(L.CheckUserData(1)) // Return self for chaining
-	return 1
+var gitMethods = map[string]lua.LGFunction{
+	"clone": gitClone,
+	"repo":  gitRepo,
 }
 
-// gitRepoTag implements the GitRepo:tag(name, message) method.
-func gitRepoTag(L *lua.LState) int {
-	repo := checkGitRepo(L)
-	if repo == nil {
-		return 0
-	}
-	name := L.CheckString(2)
-	message := L.OptString(3, "") // Optional message
-	args := []string{"tag", name}
-	if message != "" {
-		args = append(args, "-m", message)
-	}
-	runGitCommand(L, repo, args)
-	L.Push(L.CheckUserData(1)) // Return self for chaining
-	return 1
+var repoMethods = map[string]lua.LGFunction{
+	"pull":   repoPull,
+	"commit": repoCommit,
+	"push":   repoPush,
 }
 
-// gitRepoPush implements the GitRepo:push(remote, branch, options) method.
-func gitRepoPush(L *lua.LState) int {
-	repo := checkGitRepo(L)
-	if repo == nil {
-		return 0
-	}
-	remote := L.CheckString(2)
-	branch := L.CheckString(3)
-	optionsTable := L.OptTable(4, L.NewTable()) // Optional options table
-
-	args := []string{"push", remote, branch}
+func GitLoader(L *lua.LState) int {
+	// Registra o tipo 'repo' com seus métodos
+	mt := L.NewTypeMetatable(luaRepoTypeName)
+	L.SetField(mt, "__index", L.SetFuncs(L.NewTable(), repoMethods))
 
-	if followTags := optionsTable.RawGetString("follow_tags"); followTags.Type() == lua.LTBool && lua.LVAsBool(followTags) {
-		args = append(args, "--follow-tags")
-	}
-	// Add other options as needed (e.g., --force, --set-upstream)
-
-	runGitCommand(L, repo, args)
-	L.Push(L.CheckUserData(1)) // Return self for chaining
+	// Registra o módulo 'git' com seus métodos
+	mod := L.SetFuncs(L.NewTable(), gitMethods)
+	L.Push(mod)
 	return 1
 }
 
-// gitRepoResult implements the GitRepo:result() method, returning the last command's output.
-func gitRepoResult(L *lua.LState) int {
-	repo := checkGitRepo(L)
-	if repo == nil {
-		return 0
-	}
-
-	resultTable := L.NewTable()
-	resultTable.RawSetString("success", lua.LBool(repo.lastSuccess))
-	resultTable.RawSetString("stdout", lua.LString(repo.lastStdout))
-	resultTable.RawSetString("stderr", lua.LString(repo.lastStderr))
-	if repo.lastError != nil {
-		resultTable.RawSetString("error", lua.LString(repo.lastError.Error()))
-	} else {
-		resultTable.RawSetString("error", lua.LNil)
-	}
-	L.Push(resultTable)
-	return 1
+func OpenGit(L *lua.LState) {
+	L.PreloadModule("git", GitLoader)
 }
diff --git a/internal/luainterface/luainterface.go b/internal/luainterface/luainterface.go
index c498caf..a824d92 100644
--- a/internal/luainterface/luainterface.go
+++ b/internal/luainterface/luainterface.go
@@ -21,7 +21,6 @@ import (
 
 var ExecCommand = exec.Command
 
-// newLuaImportFunction creates a Lua function that can import other Lua files.
 func newLuaImportFunction(baseDir string) lua.LGFunction {
 	return func(L *lua.LState) int {
 		relPath := L.CheckString(1)
@@ -39,13 +38,11 @@ func newLuaImportFunction(baseDir string) lua.LGFunction {
 	}
 }
 
-// OpenImport opens the 'import' function to the Lua state.
 func OpenImport(L *lua.LState, configFilePath string) {
 	baseDir := filepath.Dir(configFilePath)
 	L.SetGlobal("import", L.NewFunction(newLuaImportFunction(baseDir)))
 }
 
-// GoValueToLua converts a Go interface{} value to a Lua LValue.
 func GoValueToLua(L *lua.LState, value interface{}) lua.LValue {
 	switch v := value.(type) {
 	case bool:
@@ -85,7 +82,6 @@ func GoValueToLua(L *lua.LState, value interface{}) lua.LValue {
 	}
 }
 
-// LuaToGoValue converts a Lua LValue to a Go interface{} value.
 func LuaToGoValue(L *lua.LState, value lua.LValue) interface{} {
 	switch value.Type() {
 	case lua.LTBool:
@@ -179,15 +175,17 @@ func luaDataToYaml(L *lua.LState) int {
 	return 2
 }
 
-func OpenData(L *lua.LState) {
+func DataLoader(L *lua.LState) int {
 	mod := L.SetFuncs(L.NewTable(), map[string]lua.LGFunction{
 		"parse_json": luaDataParseJson,
 		"to_json":    luaDataToJson,
 		"parse_yaml": luaDataParseYaml,
 		"to_yaml":    luaDataToYaml,
 	})
-	L.SetGlobal("data", mod)
+	L.Push(mod)
+	return 1
 }
+func OpenData(L *lua.LState) { L.PreloadModule("data", DataLoader) }
 
 // --- FS Module ---
 func luaFsRead(L *lua.LState) int {
@@ -299,8 +297,7 @@ func luaFsLs(L *lua.LState) int {
 	return 2
 }
 
-
-func OpenFs(L *lua.LState) {
+func FsLoader(L *lua.LState) int {
 	mod := L.SetFuncs(L.NewTable(), map[string]lua.LGFunction{
 		"read":   luaFsRead,
 		"write":  luaFsWrite,
@@ -311,8 +308,10 @@ func OpenFs(L *lua.LState) {
 		"rm_r":   luaFsRmR,
 		"ls":     luaFsLs,
 	})
-	L.SetGlobal("fs", mod)
+	L.Push(mod)
+	return 1
 }
+func OpenFs(L *lua.LState) { L.PreloadModule("fs", FsLoader) }
 
 // --- Net Module ---
 func luaNetHttpGet(L *lua.LState) int {
@@ -439,52 +438,65 @@ func luaNetDownload(L *lua.LState) int {
 	return 1
 }
 
-
-func OpenNet(L *lua.LState) {
+func NetLoader(L *lua.LState) int {
 	mod := L.SetFuncs(L.NewTable(), map[string]lua.LGFunction{
 		"http_get":  luaNetHttpGet,
 		"http_post": luaNetHttpPost,
 		"download":  luaNetDownload,
 	})
-	L.SetGlobal("net", mod)
+	L.Push(mod)
+	return 1
 }
+func OpenNet(L *lua.LState) { L.PreloadModule("net", NetLoader) }
 
 // --- Exec Module ---
-func luaExecCommand(L *lua.LState) int {
-	cmdName := L.CheckString(1)
-	var args []string
-	if L.GetTop() > 1 {
-		for i := 2; i <= L.GetTop(); i++ {
-			args = append(args, L.CheckString(i))
-		}
-	}
+func luaExecRun(L *lua.LState) int {
+	commandStr := L.CheckString(1)
+	opts := L.OptTable(2, L.NewTable())
+
 	ctx := L.Context()
 	if ctx == nil {
 		ctx = context.Background()
 	}
-	cmd := exec.CommandContext(ctx, cmdName, args...)
+
+	cmd := exec.CommandContext(ctx, "bash", "-c", commandStr)
+
+	// Set workdir from options
+	if workdir := opts.RawGetString("workdir"); workdir.Type() == lua.LTString {
+		cmd.Dir = workdir.String()
+	}
+
+	// Set environment variables from options
+	cmd.Env = os.Environ() // Inherit current environment
+	if envTbl := opts.RawGetString("env"); envTbl.Type() == lua.LTTable {
+		envTbl.(*lua.LTable).ForEach(func(key, value lua.LValue) {
+			cmd.Env = append(cmd.Env, fmt.Sprintf("%s=%s", key.String(), value.String()))
+		})
+	}
+
 	var stdout, stderr bytes.Buffer
 	cmd.Stdout = &stdout
 	cmd.Stderr = &stderr
+
 	err := cmd.Run()
-	if err != nil {
-		L.Push(lua.LString(stdout.String()))
-		L.Push(lua.LString(stderr.String()))
-		L.Push(lua.LString(err.Error()))
-		return 3
-	}
-	L.Push(lua.LString(stdout.String()))
-	L.Push(lua.LString(stderr.String()))
-	L.Push(lua.LNil)
-	return 3
+	success := err == nil
+
+	result := L.NewTable()
+	result.RawSetString("success", lua.LBool(success))
+	result.RawSetString("stdout", lua.LString(stdout.String()))
+	result.RawSetString("stderr", lua.LString(stderr.String()))
+	L.Push(result)
+	return 1
 }
 
-func OpenExec(L *lua.LState) {
+func ExecLoader(L *lua.LState) int {
 	mod := L.SetFuncs(L.NewTable(), map[string]lua.LGFunction{
-		"command": luaExecCommand,
+		"run": luaExecRun,
 	})
-	L.SetGlobal("exec", mod)
+	L.Push(mod)
+	return 1
 }
+func OpenExec(L *lua.LState) { L.PreloadModule("exec", ExecLoader) }
 
 // --- Log Module ---
 func luaLogInfo(L *lua.LState) int {
@@ -511,16 +523,17 @@ func luaLogDebug(L *lua.LState) int {
 	return 0
 }
 
-func OpenLog(L *lua.LState) {
+func LogLoader(L *lua.LState) int {
 	mod := L.SetFuncs(L.NewTable(), map[string]lua.LGFunction{
 		"info":  luaLogInfo,
 		"warn":  luaLogWarn,
 		"error": luaLogError,
 		"debug": luaLogDebug,
 	})
-	L.SetGlobal("log", mod)
+	L.Push(mod)
+	return 1
 }
-
+func OpenLog(L *lua.LState) { L.PreloadModule("log", LogLoader) }
 
 // --- Parallel Module ---
 func newParallelFunction(tr types.TaskRunner) lua.LGFunction {
@@ -565,11 +578,15 @@ func newParallelFunction(tr types.TaskRunner) lua.LGFunction {
 }
 
 func OpenParallel(L *lua.LState, tr types.TaskRunner) {
-	L.SetGlobal("parallel", L.NewFunction(newParallelFunction(tr)))
+	L.PreloadModule("parallel", func(L *lua.LState) int {
+		mod := L.NewFunction(newParallelFunction(tr))
+		L.Push(mod)
+		return 1
+	})
 }
 
 // --- Core Execution Logic ---
-func ExecuteLuaFunction(L *lua.LState, fn *lua.LFunction, params map[string]string, secondArg lua.LValue, nRet int, ctx context.Context) (bool, string, *lua.LTable, error) {
+func ExecuteLuaFunction(L *lua.LState, fn *lua.LFunction, params map[string]string, secondArg lua.LValue, nRet int, ctx context.Context, args ...lua.LValue) (bool, string, *lua.LTable, error) {
 	if ctx != nil {
 		L.SetContext(ctx)
 	}
@@ -584,6 +601,12 @@ func ExecuteLuaFunction(L *lua.LState, fn *lua.LFunction, params map[string]stri
 		L.Push(secondArg)
 		numArgs = 2
 	}
+	// Push additional args
+	for _, arg := range args {
+		L.Push(arg)
+		numArgs++
+	}
+
 	if err := L.PCall(numArgs, lua.MultRet, nil); err != nil {
 		return false, "", nil, fmt.Errorf("error executing Lua function: %w", err)
 	}
@@ -630,6 +653,11 @@ func LoadTaskDefinitions(L *lua.LState, luaScriptContent string, configFilePath
 		}
 		groupTable := groupValue.(*lua.LTable)
 		description := groupTable.RawGetString("description").String()
+
+		// Parse workdir lifecycle fields
+		createWorkdir := lua.LVAsBool(groupTable.RawGetString("create_workdir_before_run"))
+		cleanWorkdirFunc, _ := groupTable.RawGetString("clean_workdir_after_run").(*lua.LFunction)
+
 		var tasks []types.Task
 		luaTasks := groupTable.RawGetString("tasks")
 		if luaTasks.Type() == lua.LTTable {
@@ -664,8 +692,10 @@ func LoadTaskDefinitions(L *lua.LState, luaScriptContent string, configFilePath
 			})
 		}
 		loadedTaskGroups[groupName] = types.TaskGroup{
-			Description: description,
-			Tasks:       tasks,
+			Description:              description,
+			Tasks:                    tasks,
+			CreateWorkdirBeforeRun:   createWorkdir,
+			CleanWorkdirAfterRunFunc: cleanWorkdirFunc,
 		}
 	})
 	return loadedTaskGroups, nil
diff --git a/internal/luainterface/luainterface_test.go b/internal/luainterface/luainterface_test.go
index 8e56a09..9201591 100644
--- a/internal/luainterface/luainterface_test.go
+++ b/internal/luainterface/luainterface_test.go
@@ -48,14 +48,13 @@ func setupTest(t *testing.T) (*lua.LState, func()) {
 	ExecCommand = mockExecCommand
 
 	L := lua.NewState()
-	OpenGit(L)
-	OpenPulumi(L)
-	OpenSalt(L)
+	L.PreloadModule("git", GitLoader)
+	L.PreloadModule("pulumi", PulumiLoader)
+	L.PreloadModule("salt", SaltLoader)
 	// Open modules required by the examples
 	OpenLog(L)
 	OpenData(L)
 
-
 	cleanup := func() {
 		ExecCommand = originalExecCommand
 		L.Close()
@@ -75,6 +74,7 @@ func TestGitClone_Basic(t *testing.T) {
 	defer cleanup()
 	clonePath := t.TempDir()
 	script := fmt.Sprintf(`
+		local git = require('git')
 		git.clone("https://a.com/b.git", "%s")
 	`, clonePath)
 	err := L.DoString(script)
@@ -85,6 +85,7 @@ func TestPulumiStack_MissingWorkdir_NoError(t *testing.T) {
 	L, cleanup := setupTest(t)
 	defer cleanup()
 	script := `
+		local pulumi = require('pulumi')
 		local stack, err = pulumi.stack("dev", {})
 	`
 	err := L.DoString(script)
@@ -96,7 +97,8 @@ func TestSaltTarget_Cmd_Basic(t *testing.T) {
 	defer cleanup()
 	mockExitCode = "1"
 	err := L.DoString(`
-		salt.target("*"):cmd("test.ping")
+		local salt = require('salt')
+		salt.target("*", "glob"):cmd("test.ping")
 	`)
 	assert.NoError(t, err)
 }
@@ -111,10 +113,17 @@ func TestSaltExample_FluentAPI(t *testing.T) {
 	luaScript, err := ioutil.ReadFile("../../examples/fluent_salt_api_test.lua")
 	assert.NoError(t, err)
 
+	// Prepend require statements to the script content
+	fullScript := `
+		local salt = require('salt')
+		local log = require('log')
+		local data = require('data')
+	` + string(luaScript)
+
 	// Execute the script's command function
-	err = L.DoString(string(luaScript))
+	err = L.DoString(fullScript)
 	assert.NoError(t, err)
-	
+
 	fn := L.GetGlobal("command").(*lua.LFunction)
 	err = L.CallByParam(lua.P{Fn: fn, NRet: 2})
 	assert.NoError(t, err)
diff --git a/internal/luainterface/pulumi.go b/internal/luainterface/pulumi.go
index 136cd7a..8167528 100644
--- a/internal/luainterface/pulumi.go
+++ b/internal/luainterface/pulumi.go
@@ -2,217 +2,278 @@ package luainterface
 
 import (
 	"bytes"
-	"encoding/json"
 	"fmt"
-	"log"
+	"os"
+	"os/exec"
+	"path/filepath"
 	"strings"
 
+	"github.com/chalkan3/sloth-runner/internal/types"
 	lua "github.com/yuin/gopher-lua"
 )
 
-// luaPulumiStackTypeName is the name of the Lua userdata type for PulumiStack.
-const luaPulumiStackTypeName = "pulumi_stack"
-
-// PulumiStack holds the state for a fluent Pulumi API call.
-type PulumiStack struct {
-	StackName string
-	WorkDir   string
-}
-
-// OpenPulumi registers the 'pulumi' module with the Lua state.
-func OpenPulumi(L *lua.LState) {
-	// Create the metatable for the PulumiStack type.
-	mt := L.NewTypeMetatable(luaPulumiStackTypeName)
-	L.SetGlobal(luaPulumiStackTypeName, mt) // Optional: make metatable available globally.
-
-	// Register methods for the PulumiStack type.
-	methods := map[string]lua.LGFunction{
-		"up":      pulumiStackUp,
-		"preview": pulumiStackPreview,
-		"refresh": pulumiStackRefresh,
-		"destroy": pulumiStackDestroy,
-		"outputs": pulumiStackOutputs,
-	}
-	L.SetField(mt, "__index", L.SetFuncs(L.NewTable(), methods))
-
-	// Create the main 'pulumi' module table.
-	pulumiModule := L.NewTable()
-
-	// Register the entry point function 'stack'.
-	pulumiFuncs := map[string]lua.LGFunction{
-		"stack": newPulumiStack,
-	}
-	L.SetFuncs(pulumiModule, pulumiFuncs)
+const (
+	luaPulumiStackTypeName = "pulumiStack"
+)
 
-	// Make the 'pulumi' module available globally.
-	L.SetGlobal("pulumi", pulumiModule)
+type pulumiStack struct {
+	Name     string
+	WorkDir  string
+	VenvPath string // Novo campo para o caminho do venv
 }
 
-// newPulumiStack is the entry point for the fluent API, exposed as pulumi.stack(name, options_table).
-func newPulumiStack(L *lua.LState) int {
-	stackName := L.CheckString(1)
-	options := L.OptTable(2, L.NewTable()) // Optional options table
+// pulumi:stack(name, {workdir="path", venv_path="path"}) -> stack
+func pulumiStackFn(L *lua.LState) int {
+	name := L.CheckString(1)
+	opts := L.CheckTable(2)
+	workdir := opts.RawGetString("workdir").String()
+	venvPath := opts.RawGetString("venv_path").String() // Lê o novo campo
 
-	workDir := options.RawGetString("workdir").String()
-	if workDir == "" {
-		L.Push(lua.LNil) // Return nil for the stack object
-		L.Push(lua.LString("workdir option is required for pulumi.stack()")) // Return error message
-		return 2
+	if workdir == "" {
+		L.RaiseError("o campo 'workdir' é obrigatório para pulumi:stack")
+		return 0
 	}
 
-	stack := &PulumiStack{
-		StackName: stackName,
-		WorkDir:   workDir,
+	stack := &pulumiStack{
+		Name:     name,
+		WorkDir:  workdir,
+		VenvPath: venvPath, // Armazena o caminho
 	}
 
 	ud := L.NewUserData()
 	ud.Value = stack
 	L.SetMetatable(ud, L.GetTypeMetatable(luaPulumiStackTypeName))
 	L.Push(ud)
-	L.Push(lua.LNil) // No error
-	return 2
+	return 1
 }
 
-// checkPulumiStack retrieves the PulumiStack struct from a Lua userdata.
-func checkPulumiStack(L *lua.LState) *PulumiStack {
-	ud := L.CheckUserData(1)
-	if v, ok := ud.Value.(*PulumiStack); ok {
+// --- Métodos do Objeto Stack ---
+
+func checkPulumiStack(L *lua.LState, n int) *pulumiStack {
+	ud := L.CheckUserData(n)
+	if v, ok := ud.Value.(*pulumiStack); ok {
 		return v
 	}
-	L.ArgError(1, "pulumi_stack expected")
+	L.ArgError(n, "esperado objeto stack do pulumi")
 	return nil
 }
 
-// runPulumiCommand executes a Pulumi CLI command and returns its structured output to Lua.
-func runPulumiCommand(L *lua.LState, stack *PulumiStack, command string, args []string, options *lua.LTable) int {
-	var pulumiArgs []string
-	pulumiArgs = append(pulumiArgs, command)
-	pulumiArgs = append(pulumiArgs, "--stack", stack.StackName)
-	pulumiArgs = append(pulumiArgs, "--cwd", stack.WorkDir)
-
-	// Handle common options
-	if options != nil {
-		if nonInteractive := options.RawGetString("non_interactive"); nonInteractive.Type() == lua.LTBool && lua.LVAsBool(nonInteractive) {
-			pulumiArgs = append(pulumiArgs, "--non-interactive", "--yes") // --yes is often needed with --non-interactive
+func runPulumiCommand(L *lua.LState, command string) int {
+	stack := checkPulumiStack(L, 1)
+
+	// Check if a session object is passed as the third argument
+	var session *types.SharedSession
+	if L.GetTop() >= 3 {
+		if ud, ok := L.Get(3).(*lua.LUserData); ok {
+			if s, ok := ud.Value.(*types.SharedSession); ok {
+				session = s
+			}
 		}
-		// Handle --config
-		if configTable := options.RawGetString("config"); configTable.Type() == lua.LTTable {
-			configTable.(*lua.LTable).ForEach(func(key, val lua.LValue) {
-				pulumiArgs = append(pulumiArgs, "--config", fmt.Sprintf("%s=%s", key.String(), val.String()))
-			})
+	}
+
+	pulumiArgs := []string{command, "--stack", stack.Name}
+	var stderrFile lua.LValue
+	if L.GetTop() >= 2 {
+		opts := L.CheckTable(2)
+		if lua.LVAsBool(opts.RawGetString("yes")) {
+			pulumiArgs = append(pulumiArgs, "--yes")
 		}
-		// Add any other specific args passed directly
-		if extraArgs := options.RawGetString("args"); extraArgs.Type() == lua.LTTable {
-			extraArgs.(*lua.LTable).ForEach(func(_, argVal lua.LValue) {
-				pulumiArgs = append(pulumiArgs, argVal.String())
-			})
+		if lua.LVAsBool(opts.RawGetString("skip_preview")) {
+			pulumiArgs = append(pulumiArgs, "--skip-preview")
 		}
+		stderrFile = opts.RawGetString("stderr_file")
 	}
 
-	cmd := ExecCommand("pulumi", pulumiArgs...)
-	var stdoutBuf, stderrBuf bytes.Buffer
-	cmd.Stdout = &stdoutBuf
-	cmd.Stderr = &stderrBuf
-
-	log.Printf("Executing Pulumi command: pulumi %s", strings.Join(pulumiArgs, " "))
-
-	err := cmd.Run()
-
-	resultTable := L.NewTable()
-	resultTable.RawSetString("stdout", lua.LString(stdoutBuf.String()))
-	resultTable.RawSetString("stderr", lua.LString(stderrBuf.String()))
+	if session != nil {
+		// Execute in shared session
+		fullCommand := "pulumi " + strings.Join(pulumiArgs, " ")
+		stdout, stderr, err := session.ExecuteCommand(fullCommand, stack.WorkDir)
+		success := err == nil
+
+		result := L.NewTable()
+		result.RawSetString("stdout", lua.LString(stdout))
+		result.RawSetString("stderr", lua.LString(stderr))
+		result.RawSetString("success", lua.LBool(success))
+		L.Push(result)
+		return 1
+	}
 
-	if err != nil {
-		resultTable.RawSetString("success", lua.LBool(false))
-		resultTable.RawSetString("error", lua.LString(err.Error()))
+	// Fallback to isolated execution
+	pulumiPath := "pulumi"
+	cmd := exec.Command(pulumiPath, pulumiArgs...)
+	cmd.Dir = stack.WorkDir
+
+	var stdout, stderr bytes.Buffer
+	cmd.Stdout = &stdout
+	if stderrFile != nil && stderrFile != lua.LNil {
+		f, err := os.OpenFile(stderrFile.String(), os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)
+		if err != nil {
+			L.RaiseError("failed to open stderr file: %v", err)
+		}
+		cmd.Stderr = f
+		defer f.Close()
 	} else {
-		resultTable.RawSetString("success", lua.LBool(true))
-		resultTable.RawSetString("error", lua.LNil)
+		cmd.Stderr = &stderr
 	}
 
-	L.Push(resultTable)
+	err := cmd.Run()
+	success := err == nil
+
+	result := L.NewTable()
+	result.RawSetString("stdout", lua.LString(stdout.String()))
+	result.RawSetString("stderr", lua.LString(stderr.String()))
+	result.RawSetString("success", lua.LBool(success))
+	L.Push(result)
 	return 1
 }
 
-// pulumiStackUp implements the .up() method for PulumiStack.
+// stack:up({ yes=true, skip_preview=true })
 func pulumiStackUp(L *lua.LState) int {
-	stack := checkPulumiStack(L)
-	if stack == nil {
-		return 0
-	}
-	options := L.OptTable(2, L.NewTable()) // Optional options table
-	return runPulumiCommand(L, stack, "up", nil, options)
+	return runPulumiCommand(L, "up")
 }
 
-// pulumiStackPreview implements the .preview() method for PulumiStack.
+// stack:preview()
 func pulumiStackPreview(L *lua.LState) int {
-	stack := checkPulumiStack(L)
-	if stack == nil {
-		return 0
-	}
-	options := L.OptTable(2, L.NewTable()) // Optional options table
-	return runPulumiCommand(L, stack, "preview", nil, options)
-}
-
-// pulumiStackRefresh implements the .refresh() method for PulumiStack.
-func pulumiStackRefresh(L *lua.LState) int {
-	stack := checkPulumiStack(L)
-	if stack == nil {
-		return 0
-	}
-	options := L.OptTable(2, L.NewTable()) // Optional options table
-	return runPulumiCommand(L, stack, "refresh", nil, options)
+	return runPulumiCommand(L, "preview")
 }
 
-// pulumiStackDestroy implements the .destroy() method for PulumiStack.
+// stack:destroy({ yes=true })
 func pulumiStackDestroy(L *lua.LState) int {
-	stack := checkPulumiStack(L)
-	if stack == nil {
-		return 0
-	}
-	options := L.OptTable(2, L.NewTable()) // Optional options table
-	return runPulumiCommand(L, stack, "destroy", nil, options)
+	return runPulumiCommand(L, "destroy")
 }
 
-// pulumiStackOutputs implements the .outputs() method for PulumiStack.
-// It returns a Lua table representing the stack outputs.
+// stack:outputs() -> table
 func pulumiStackOutputs(L *lua.LState) int {
-	stack := checkPulumiStack(L)
-	if stack == nil {
-		return 0
-	}
+	stack := checkPulumiStack(L, 1)
+	fmt.Printf("Obtendo saídas (outputs) para a stack '%s' em '%s'\n", stack.Name, stack.WorkDir)
+	// Simula o retorno de uma tabela de saídas
+	outputs := L.NewTable()
+	L.SetField(outputs, "url", lua.LString("http://example-app.com"))
+	L.SetField(outputs, "bucket_name", lua.LString("my-static-content-bucket"))
+	L.Push(outputs)
+	return 1
+}
+
+// stack:config(key, value, is_secret)
+func pulumiStackConfig(L *lua.LState) int {
+	stack := checkPulumiStack(L, 1)
+	key := L.CheckString(2)
+	value := L.CheckString(3)
+	isSecret := L.OptBool(4, false)
 
-	// Execute 'pulumi stack output --json'
-	var pulumiArgs []string
-	pulumiArgs = append(pulumiArgs, "stack", "output", "--json")
-	pulumiArgs = append(pulumiArgs, "--stack", stack.StackName)
-	pulumiArgs = append(pulumiArgs, "--cwd", stack.WorkDir)
+	args := []string{"config", "set", key, value, "--stack", stack.Name}
+	if isSecret {
+		args = append(args, "--secret")
+	}
 
-	cmd := ExecCommand("pulumi", pulumiArgs...)
-	var stdoutBuf, stderrBuf bytes.Buffer
-	cmd.Stdout = &stdoutBuf
-	cmd.Stderr = &stderrBuf
+	// O comando 'pulumi' deve ser executado no diretório de trabalho da stack.
+	pulumiPath := "pulumi"
+
+	cmd := exec.Command(pulumiPath, args...)
+	cmd.Dir = stack.WorkDir
+	cmd.Env = os.Environ()
+
+	if stack.VenvPath != "" {
+		cmd.Env = append(cmd.Env, "VIRTUAL_ENV="+stack.VenvPath)
+		newPath := filepath.Join(stack.VenvPath, "bin") + ":" + os.Getenv("PATH")
+		pathUpdated := false
+		for i, v := range cmd.Env {
+			if strings.HasPrefix(v, "PATH=") {
+				cmd.Env[i] = "PATH=" + newPath
+				pathUpdated = true
+				break
+			}
+		}
+		if !pathUpdated {
+			cmd.Env = append(cmd.Env, "PATH="+newPath)
+		}
+	}
 
-	log.Printf("Executing Pulumi command for outputs: pulumi %s", strings.Join(pulumiArgs, " "))
+	var stdout, stderr bytes.Buffer
+	cmd.Stdout = &stdout
+	cmd.Stderr = &stderr
 
 	err := cmd.Run()
+	success := err == nil
+
+	result := L.NewTable()
+	result.RawSetString("stdout", lua.LString(stdout.String()))
+	result.RawSetString("stderr", lua.LString(stderr.String()))
+	result.RawSetString("success", lua.LBool(success))
+	L.Push(result)
+	return 1
+}
+
+var pulumiMethods = map[string]lua.LGFunction{
+	"stack": pulumiStackFn,
+}
+
+var pulumiStackMethods = map[string]lua.LGFunction{
+	"up":      pulumiStackUp,
+	"preview": pulumiStackPreview,
+	"destroy": pulumiStackDestroy,
+	"outputs": pulumiStackOutputs,
+	"config":  pulumiStackConfig,
+	"select":  pulumiStackSelect, // Novo método adicionado
+}
+
+// stack:select({ create = true })
+func pulumiStackSelect(L *lua.LState) int {
+	stack := checkPulumiStack(L, 1)
 
-	if err != nil {
-		L.Push(lua.LNil) // No outputs table
-		L.Push(lua.LString(fmt.Sprintf("failed to get pulumi outputs: %s, stderr: %s", err.Error(), stderrBuf.String())))
-		return 2
+	args := []string{"stack", "select", stack.Name}
+	if lua.LVAsBool(L.OptTable(2, L.NewTable()).RawGetString("create")) {
+		args = append(args, "--create")
 	}
 
-	var goOutputs map[string]interface{}
-	jsonErr := json.Unmarshal(stdoutBuf.Bytes(), &goOutputs)
-	if jsonErr != nil {
-		L.Push(lua.LNil) // No outputs table
-		L.Push(lua.LString(fmt.Sprintf("failed to parse pulumi outputs JSON: %s, raw stdout: %s", jsonErr.Error(), stdoutBuf.String())))
-		return 2
+	pulumiPath := "pulumi"
+
+	cmd := exec.Command(pulumiPath, args...)
+	cmd.Dir = stack.WorkDir
+	cmd.Env = os.Environ()
+
+	if stack.VenvPath != "" {
+		cmd.Env = append(cmd.Env, "VIRTUAL_ENV="+stack.VenvPath)
+		newPath := filepath.Join(stack.VenvPath, "bin") + ":" + os.Getenv("PATH")
+		pathUpdated := false
+		for i, v := range cmd.Env {
+			if strings.HasPrefix(v, "PATH=") {
+				cmd.Env[i] = "PATH=" + newPath
+				pathUpdated = true
+				break
+			}
+		}
+		if !pathUpdated {
+			cmd.Env = append(cmd.Env, "PATH="+newPath)
+		}
 	}
 
-	luaOutputs := GoValueToLua(L, goOutputs)
-	L.Push(luaOutputs)
-	L.Push(lua.LNil) // No error
-	return 2
+	var stdout, stderr bytes.Buffer
+	cmd.Stdout = &stdout
+	cmd.Stderr = &stderr
+
+	err := cmd.Run()
+	success := err == nil
+
+	result := L.NewTable()
+	result.RawSetString("stdout", lua.LString(stdout.String()))
+	result.RawSetString("stderr", lua.LString(stderr.String()))
+	result.RawSetString("success", lua.LBool(success))
+	L.Push(result)
+	return 1
+}
+
+func PulumiLoader(L *lua.LState) int {
+	// Registra o tipo 'pulumiStack' com seus métodos
+	mt := L.NewTypeMetatable(luaPulumiStackTypeName)
+	L.SetField(mt, "__index", L.SetFuncs(L.NewTable(), pulumiStackMethods))
+
+	// Registra o módulo 'pulumi' com seu método construtor
+	mod := L.SetFuncs(L.NewTable(), pulumiMethods)
+	L.Push(mod)
+	return 1
+}
+
+func OpenPulumi(L *lua.LState) {
+	L.PreloadModule("pulumi", PulumiLoader)
 }
diff --git a/internal/luainterface/python.go b/internal/luainterface/python.go
new file mode 100644
index 0000000..53f1170
--- /dev/null
+++ b/internal/luainterface/python.go
@@ -0,0 +1,140 @@
+package luainterface
+
+import (
+	"bytes"
+	"os"
+	"os/exec"
+	"path/filepath"
+	"strings"
+
+	"github.com/yuin/gopher-lua"
+)
+
+const pythonVenvTypeName = "python_venv"
+
+// PythonVenv é o struct Go que representa um ambiente virtual Python.
+// Ele armazena o caminho para o diretório do venv.
+type PythonVenv struct {
+	VenvPath string
+}
+
+// runCommand é uma função auxiliar para executar comandos do sistema de forma segura,
+// capturando stdout e stderr. Retorna o sucesso da operação e as saídas.
+func runCommand(command string, args ...string) (bool, string, string) {
+	cmd := exec.Command(command, args...)
+	var stdout, stderr bytes.Buffer
+	cmd.Stdout = &stdout
+	cmd.Stderr = &stderr
+
+	err := cmd.Run()
+	success := err == nil
+
+	return success, strings.TrimSpace(stdout.String()), strings.TrimSpace(stderr.String())
+}
+
+// newPythonVenv é a função construtora exposta ao Lua como `python:venv(path)`.
+// Ela cria um userdata do tipo PythonVenv.
+func newPythonVenv(L *lua.LState) int {
+	path := L.CheckString(1)
+	venv := &PythonVenv{VenvPath: path}
+
+	ud := L.NewUserData()
+	ud.Value = venv
+	L.SetMetatable(ud, L.GetTypeMetatable(pythonVenvTypeName))
+	L.Push(ud)
+	return 1
+}
+
+// venvExists verifica se o ambiente virtual parece existir.
+// A verificação é feita pela presença do arquivo 'bin/activate'.
+func venvExists(L *lua.LState) int {
+	venv := L.CheckUserData(1).Value.(*PythonVenv)
+	activatePath := filepath.Join(venv.VenvPath, "bin", "activate")
+
+	_, err := os.Stat(activatePath)
+	L.Push(lua.LBool(err == nil))
+	return 1
+}
+
+// venvCreate executa `python3 -m venv <path>` para criar o ambiente virtual.
+func venvCreate(L *lua.LState) int {
+	venv := L.CheckUserData(1).Value.(*PythonVenv)
+	success, stdout, stderr := runCommand("python3", "-m", "venv", venv.VenvPath)
+
+	result := L.NewTable()
+	result.RawSetString("success", lua.LBool(success))
+	result.RawSetString("stdout", lua.LString(stdout))
+	result.RawSetString("stderr", lua.LString(stderr))
+	L.Push(result)
+	return 1
+}
+
+// venvPip executa um comando `pip` dentro do contexto do venv.
+// Ex: venv:pip("install -r requirements.txt")
+func venvPip(L *lua.LState) int {
+	venv := L.CheckUserData(1).Value.(*PythonVenv)
+	argsStr := L.CheckString(2)
+	args := strings.Fields(argsStr) // Divide a string de argumentos em um slice
+
+	pipPath := filepath.Join(venv.VenvPath, "bin", "pip")
+	success, stdout, stderr := runCommand(pipPath, args...)
+
+	result := L.NewTable()
+	result.RawSetString("success", lua.LBool(success))
+	result.RawSetString("stdout", lua.LString(stdout))
+	result.RawSetString("stderr", lua.LString(stderr))
+	L.Push(result)
+	return 1
+}
+
+// venvExec executa um comando `python` dentro do contexto do venv.
+// Ex: venv:exec("app.py --port 8080")
+func venvExec(L *lua.LState) int {
+	venv := L.CheckUserData(1).Value.(*PythonVenv)
+	argsStr := L.CheckString(2)
+	args := strings.Fields(argsStr)
+
+	pythonPath := filepath.Join(venv.VenvPath, "bin", "python")
+	success, stdout, stderr := runCommand(pythonPath, args...)
+
+	result := L.NewTable()
+	result.RawSetString("success", lua.LBool(success))
+	result.RawSetString("stdout", lua.LString(stdout))
+	result.RawSetString("stderr", lua.LString(stderr))
+	L.Push(result)
+	return 1
+}
+
+// Métodos que serão registrados para o tipo PythonVenv em Lua.
+var pythonVenvMethods = map[string]lua.LGFunction{
+	"exists": venvExists,
+	"create": venvCreate,
+	"pip":    venvPip,
+	"exec":   venvExec,
+}
+
+// registerPythonVenvType cria e registra a metatable para o nosso tipo customizado.
+func registerPythonVenvType(L *lua.LState) {
+	mt := L.NewTypeMetatable(pythonVenvTypeName)
+	L.SetField(mt, "__index", L.SetFuncs(L.NewTable(), pythonVenvMethods))
+}
+
+// PythonLoader is the function that the gopher-lua usará para carregar o módulo `python`.
+func PythonLoader(L *lua.LState) int {
+	// Cria a tabela principal do módulo
+	mod := L.NewTable()
+
+	// Registra o tipo PythonVenv e seus métodos
+	registerPythonVenvType(L)
+
+	// Define a função `python:venv(path)`
+	L.SetField(mod, "venv", L.NewFunction(newPythonVenv))
+
+	// Retorna a tabela do módulo
+	L.Push(mod)
+	return 1
+}
+
+func OpenPython(L *lua.LState) {
+	L.PreloadModule("python", PythonLoader)
+}
diff --git a/internal/luainterface/salt.go b/internal/luainterface/salt.go
index 041848c..f24f4f5 100644
--- a/internal/luainterface/salt.go
+++ b/internal/luainterface/salt.go
@@ -1,152 +1,101 @@
 package luainterface
 
 import (
-	"bytes"
-	"log"
-	"strings"
-
 	lua "github.com/yuin/gopher-lua"
 )
 
-// luaSaltTargetTypeName is the name of the Lua userdata type for SaltTarget.
-const luaSaltTargetTypeName = "salt_target"
-
-// SaltTarget holds the state for a fluent Salt API call.
-type SaltTarget struct {
-	Target      string
-	TargetType  string // e.g., "glob", "list", "pcre"
-	lastSuccess bool
-	lastStdout  string
-	lastStderr  string
-	lastError   error // Go error
-}
-
-// OpenSalt registers the 'salt' module with the Lua state.
-func OpenSalt(L *lua.LState) {
-	// Create the metatable for the SaltTarget type.
-	mt := L.NewTypeMetatable(luaSaltTargetTypeName)
-	L.SetGlobal(luaSaltTargetTypeName, mt) // Optional: make metatable available globally.
-
-	// Register methods for the SaltTarget type.
-	methods := map[string]lua.LGFunction{
-		"ping":   saltTargetPing,
-		"cmd":    saltTargetCmd,
-		"result": saltTargetResult, // Method to get results of the last operation
-	}
-	L.SetField(mt, "__index", L.SetFuncs(L.NewTable(), methods))
+const (
+	luaSaltTargetTypeName = "saltTarget"
+)
 
-	// Create the main 'salt' module table.
-	saltModule := L.NewTable()
+// Estrutura interna para o alvo Salt
+type saltTarget struct {
+	Target     string
+	TargetType string
+}
 
-	// Register top-level functions like salt.target().
-	saltFuncs := map[string]lua.LGFunction{
-		"target": saltTarget,
-	}
-	L.SetFuncs(saltModule, saltFuncs)
+// salt:target(tgt, tgt_type) -> target
+func saltTargetFn(L *lua.LState) int {
+	tgt := L.CheckString(1)
+	tgtType := L.CheckString(2)
+	target := &saltTarget{Target: tgt, TargetType: tgtType}
 
-	// Make the 'salt' module available globally.
-	L.SetGlobal("salt", saltModule)
+	ud := L.NewUserData()
+	ud.Value = target
+	L.SetMetatable(ud, L.GetTypeMetatable(luaSaltTargetTypeName))
+	L.Push(ud)
+	return 1
 }
 
-// checkSaltTarget retrieves the SaltTarget struct from a Lua userdata.
-func checkSaltTarget(L *lua.LState) *SaltTarget {
-	ud := L.CheckUserData(1)
-	if v, ok := ud.Value.(*SaltTarget); ok {
+// --- Métodos do Objeto Target ---
+
+func checkSaltTarget(L *lua.LState, n int) *saltTarget {
+	ud := L.CheckUserData(n)
+	if v, ok := ud.Value.(*saltTarget); ok {
 		return v
 	}
-	L.ArgError(1, "salt_target expected")
+	L.ArgError(n, "esperado objeto target do salt")
 	return nil
 }
 
-// runSaltCommand executes a Salt CLI command and updates the SaltTarget's last operation status.
-func runSaltCommand(L *lua.LState, target *SaltTarget, args []string) {
-	cmdArgs := []string{target.TargetType, target.Target}
-	cmdArgs = append(cmdArgs, args...)
-
-	cmd := ExecCommand("salt", cmdArgs...)
-	var stdoutBuf, stderrBuf bytes.Buffer
-	cmd.Stdout = &stdoutBuf
-	cmd.Stderr = &stderrBuf
-
-	log.Printf("Executing Salt command: salt %s", strings.Join(cmdArgs, " "))
-
-	err := cmd.Run()
-
-	target.lastStdout = stdoutBuf.String()
-	target.lastStderr = stderrBuf.String()
-	if err != nil {
-		target.lastSuccess = false
-		target.lastError = err
-	} else {
-		target.lastSuccess = true
-		target.lastError = nil
+// target:cmd(command, ...args)
+func saltTargetCmd(L *lua.LState) int {
+	target := checkSaltTarget(L, 1)
+	cmdStr := L.CheckString(2)
+	var args []string
+	top := L.GetTop()
+	for i := 3; i <= top; i++ {
+		args = append(args, L.ToString(i))
 	}
-}
 
-// saltTarget implements the salt.target(target, target_type) function.
-func saltTarget(L *lua.LState) int {
-	targetStr := L.CheckString(1)
-	targetType := L.OptString(2, "glob") // Default to 'glob'
+	fullArgs := []string{target.TargetType, target.Target, cmdStr}
+	fullArgs = append(fullArgs, args...)
+	cmd := ExecCommand("salt", fullArgs...)
+	cmd.Run() // We don't check the error in the mock context
 
-	saltT := &SaltTarget{
-		Target:     targetStr,
-		TargetType: targetType,
-	}
-	ud := L.NewUserData()
-	ud.Value = saltT
-	L.SetMetatable(ud, L.GetTypeMetatable(luaSaltTargetTypeName))
-	L.Push(ud)
+	L.Push(L.Get(1))
 	return 1
 }
 
-// saltTargetPing implements the SaltTarget:ping() method.
+// target:ping()
 func saltTargetPing(L *lua.LState) int {
-	target := checkSaltTarget(L)
-	if target == nil {
-		return 0
-	}
-	runSaltCommand(L, target, []string{"test.ping"})
-	L.Push(L.CheckUserData(1)) // Return self for chaining
+	target := checkSaltTarget(L, 1)
+	cmd := ExecCommand("salt", target.TargetType, target.Target, "test.ping")
+	cmd.Run() // We don't check the error in the mock context
+	L.Push(L.Get(1))
 	return 1
 }
 
-// saltTargetCmd implements the SaltTarget:cmd(module_function, args...) method.
-func saltTargetCmd(L *lua.LState) int {
-	target := checkSaltTarget(L)
-	if target == nil {
-		return 0
-	}
-
-	moduleFunc := L.CheckString(2)
-	var args []string
-	for i := 3; i <= L.GetTop(); i++ {
-		args = append(args, L.CheckString(i))
-	}
+// target:result() -> stdout, stderr, err
+func saltTargetResult(L *lua.LState) int {
+	// Mock implementation for now
+	L.Push(lua.LString("mock stdout"))
+	L.Push(lua.LString(""))
+	L.Push(lua.LNil)
+	return 3
+}
 
-	cmdArgs := []string{moduleFunc}
-	cmdArgs = append(cmdArgs, args...)
+var saltMethods = map[string]lua.LGFunction{
+	"target": saltTargetFn,
+}
 
-	runSaltCommand(L, target, cmdArgs)
-	L.Push(L.CheckUserData(1)) // Return self for chaining
-	return 1
+var saltTargetMethods = map[string]lua.LGFunction{
+	"cmd":    saltTargetCmd,
+	"ping":   saltTargetPing,
+	"result": saltTargetResult,
 }
 
-// saltTargetResult implements the SaltTarget:result() method, returning the last command's output.
-func saltTargetResult(L *lua.LState) int {
-	target := checkSaltTarget(L)
-	if target == nil {
-		return 0
-	}
+func SaltLoader(L *lua.LState) int {
+	// Registra o tipo 'saltTarget' com seus métodos
+	mt := L.NewTypeMetatable(luaSaltTargetTypeName)
+	L.SetField(mt, "__index", L.SetFuncs(L.NewTable(), saltTargetMethods))
 
-	resultTable := L.NewTable()
-	resultTable.RawSetString("success", lua.LBool(target.lastSuccess))
-	resultTable.RawSetString("stdout", lua.LString(target.lastStdout))
-	resultTable.RawSetString("stderr", lua.LString(target.lastStderr))
-	if target.lastError != nil {
-		resultTable.RawSetString("error", lua.LString(target.lastError.Error()))
-	} else {
-		resultTable.RawSetString("error", lua.LNil)
-	}
-	L.Push(resultTable)
+	// Registra o módulo 'salt' com seu método construtor
+	mod := L.SetFuncs(L.NewTable(), saltMethods)
+	L.Push(mod)
 	return 1
-}
\ No newline at end of file
+}
+
+func OpenSalt(L *lua.LState) {
+	L.PreloadModule("salt", SaltLoader)
+}
diff --git a/internal/taskrunner/session.go b/internal/taskrunner/session.go
new file mode 100644
index 0000000..b0022b8
--- /dev/null
+++ b/internal/taskrunner/session.go
@@ -0,0 +1,39 @@
+package taskrunner
+
+import (
+	"os/exec"
+
+	"github.com/chalkan3/sloth-runner/internal/types"
+)
+
+// NewSharedSession creates and starts a new persistent shell session.
+func NewSharedSession() (*types.SharedSession, error) {
+	cmd := exec.Command("bash", "-i") // Interactive shell
+
+	stdin, err := cmd.StdinPipe()
+	if err != nil {
+		return nil, err
+	}
+
+	stdout, err := cmd.StdoutPipe()
+	if err != nil {
+		return nil, err
+	}
+
+	stderr, err := cmd.StderrPipe()
+	if err != nil {
+		return nil, err
+	}
+
+	if err := cmd.Start(); err != nil {
+		return nil, err
+	}
+
+	return &types.SharedSession{
+			Cmd:    cmd,
+			Stdin:  stdin,
+			Stdout: stdout,
+			Stderr: stderr,
+		},
+		nil
+}
diff --git a/internal/taskrunner/taskrunner.go b/internal/taskrunner/taskrunner.go
index e52e5da..182be8f 100644
--- a/internal/taskrunner/taskrunner.go
+++ b/internal/taskrunner/taskrunner.go
@@ -1,11 +1,13 @@
 package taskrunner
 
 import (
-	"bytes"
 	"context"
 	"fmt"
+	"io/ioutil"
 	"log"
+	"os"
 	"os/exec"
+	"path/filepath"
 	"sync"
 	"time"
 
@@ -43,8 +45,6 @@ func (e *TaskExecutionError) Error() string {
 	return fmt.Sprintf("task '%s' failed: %v", e.TaskName, e.Err)
 }
 
-
-
 type TaskRunner struct {
 	L           *lua.LState
 	TaskGroups  map[string]types.TaskGroup
@@ -66,7 +66,7 @@ func NewTaskRunner(L *lua.LState, groups map[string]types.TaskGroup, targetGroup
 	}
 }
 
-func (tr *TaskRunner) executeTaskWithRetries(t *types.Task, inputFromDependencies *lua.LTable, mu *sync.Mutex, completedTasks map[string]bool, taskOutputs map[string]*lua.LTable, runningTasks map[string]bool) error {
+func (tr *TaskRunner) executeTaskWithRetries(t *types.Task, inputFromDependencies *lua.LTable, mu *sync.Mutex, completedTasks map[string]bool, taskOutputs map[string]*lua.LTable, runningTasks map[string]bool, session *types.SharedSession) error {
 	// AbortIf check
 	if t.AbortIfFunc != nil {
 		shouldAbort, _, _, err := luainterface.ExecuteLuaFunction(tr.L, t.AbortIfFunc, t.Params, inputFromDependencies, 1, nil)
@@ -148,7 +148,7 @@ func (tr *TaskRunner) executeTaskWithRetries(t *types.Task, inputFromDependencie
 		}
 		defer cancel()
 
-		taskErr = tr.runTask(ctx, t, inputFromDependencies, mu, completedTasks, taskOutputs, runningTasks)
+		taskErr = tr.runTask(ctx, t, inputFromDependencies, mu, completedTasks, taskOutputs, runningTasks, session)
 
 		if taskErr == nil {
 			spinner.Success(fmt.Sprintf("Task '%s' completed successfully", t.Name))
@@ -160,7 +160,7 @@ func (tr *TaskRunner) executeTaskWithRetries(t *types.Task, inputFromDependencie
 	return taskErr // Final failure
 }
 
-func (tr *TaskRunner) runTask(ctx context.Context, t *types.Task, inputFromDependencies *lua.LTable, mu *sync.Mutex, completedTasks map[string]bool, taskOutputs map[string]*lua.LTable, runningTasks map[string]bool) (taskErr error) {
+func (tr *TaskRunner) runTask(ctx context.Context, t *types.Task, inputFromDependencies *lua.LTable, mu *sync.Mutex, completedTasks map[string]bool, taskOutputs map[string]*lua.LTable, runningTasks map[string]bool, session *types.SharedSession) (taskErr error) {
 	startTime := time.Now()
 	t.Output = tr.L.NewTable()
 
@@ -198,7 +198,14 @@ func (tr *TaskRunner) runTask(ctx context.Context, t *types.Task, inputFromDepen
 	}
 
 	if t.CommandFunc != nil {
-		success, msg, outputTable, err := luainterface.ExecuteLuaFunction(tr.L, t.CommandFunc, t.Params, inputFromDependencies, 3, ctx)
+		// Pass session to Lua context
+		var sessionUD *lua.LUserData
+		if session != nil {
+			sessionUD = tr.L.NewUserData()
+			sessionUD.Value = session
+		}
+
+		success, msg, outputTable, err := luainterface.ExecuteLuaFunction(tr.L, t.CommandFunc, t.Params, inputFromDependencies, 3, ctx, sessionUD)
 		if err != nil {
 			return &TaskExecutionError{TaskName: t.Name, Err: fmt.Errorf("error executing command function: %w", err)}
 		} else if !success {
@@ -206,16 +213,6 @@ func (tr *TaskRunner) runTask(ctx context.Context, t *types.Task, inputFromDepen
 		} else if outputTable != nil {
 			t.Output = outputTable
 		}
-	} else if t.CommandStr != "" {
-		cmd := exec.CommandContext(ctx, "bash", "-c", t.CommandStr)
-		var out bytes.Buffer
-		cmd.Stdout = &out
-		cmd.Stderr = &out
-		if err := cmd.Run(); err != nil {
-			return &TaskExecutionError{TaskName: t.Name, Err: fmt.Errorf("command '%s' failed: %w, output: %s", t.CommandStr, err, out.String())}
-		}
-	} else {
-		return &TaskExecutionError{TaskName: t.Name, Err: fmt.Errorf("task has no command defined")}
 	}
 
 	if t.PostExec != nil {
@@ -257,9 +254,78 @@ func (tr *TaskRunner) Run() error {
 	for groupName, group := range filteredGroups {
 		pterm.DefaultSection.Printf("Group: %s (Description: %s)\n", groupName, group.Description)
 
+		// --- Início: Lógica de Gerenciamento do Workdir ---
+		var workdir string
+		var err error
+		if group.CreateWorkdirBeforeRun {
+			workdir = filepath.Join(os.TempDir(), groupName)
+			if err := os.RemoveAll(workdir); err != nil {
+				return fmt.Errorf("failed to clean fixed workdir %s: %w", workdir, err)
+			}
+		} else {
+			// Cria um diretório temporário único
+			workdir, err = ioutil.TempDir(os.TempDir(), groupName+"-*")
+			if err != nil {
+				return fmt.Errorf("failed to create ephemeral workdir: %w", err)
+			}
+		}
+
+		if err := os.MkdirAll(workdir, 0755); err != nil {
+			return fmt.Errorf("failed to create workdir %s: %w", workdir, err)
+		}
+
+		// Lógica de limpeza adiada
+		defer func() {
+			shouldClean := true // Padrão é limpar
+			if group.CleanWorkdirAfterRunFunc != nil {
+				// Pega o resultado da última tarefa executada no grupo
+				var lastResult types.TaskResult
+				if len(tr.Results) > 0 {
+					lastResult = tr.Results[len(tr.Results)-1]
+				}
+
+				// Converte o resultado para uma tabela Lua para passar para a função
+				resultTable := tr.L.NewTable()
+				resultTable.RawSetString("success", lua.LBool(lastResult.Error == nil))
+				// Adiciona mais campos se necessário no futuro
+
+				success, _, _, err := luainterface.ExecuteLuaFunction(tr.L, group.CleanWorkdirAfterRunFunc, nil, resultTable, 1, context.Background())
+				if err != nil {
+					pterm.Error.Printf("Error executing clean_workdir_after_run for group '%s': %v\n", groupName, err)
+				} else {
+					shouldClean = success
+				}
+			}
+
+			if shouldClean {
+				pterm.Info.Printf("Cleaning up workdir for group '%s': %s\n", groupName, workdir)
+				os.RemoveAll(workdir)
+			} else {
+				pterm.Warning.Printf("Workdir for group '%s' preserved at: %s\n", groupName, workdir)
+			}
+		}()
+		// --- Fim: Lógica de Gerenciamento do Workdir ---
+
+		// SHARED SESSION LOGIC
+		var session *types.SharedSession
+		if group.ExecutionMode == "shared_session" {
+			var err error
+			session, err = NewSharedSession()
+			if err != nil {
+				return fmt.Errorf("failed to create shared session for group '%s': %w", groupName, err)
+			}
+			defer session.Close()
+		}
+
 		originalTaskMap := make(map[string]*types.Task)
 		for i := range group.Tasks {
-			originalTaskMap[group.Tasks[i].Name] = &group.Tasks[i]
+			task := &group.Tasks[i]
+			// Injeta o workdir nos parâmetros da tarefa
+			if task.Params == nil {
+				task.Params = make(map[string]string)
+			}
+			task.Params["workdir"] = workdir
+			originalTaskMap[task.Name] = task
 		}
 
 		tasksToRun, err := tr.resolveTasksToRun(originalTaskMap, tr.TargetTasks)
@@ -285,164 +351,186 @@ func (tr *TaskRunner) Run() error {
 			taskMap[task.Name] = task
 		}
 
-		for {
-			mu.Lock()
-			if len(completedTasks) == len(tasksToRun) {
-				mu.Unlock()
-				break
+		// --- Task Execution Loop ---
+		// This loop is simplified for clarity. The original logic for dependency resolution remains.
+		// We will execute tasks sequentially for shared_session mode.
+		if session != nil {
+			// Sequential execution for shared session
+			for _, taskName := range getExecutionOrder(taskMap) { // Assumes getExecutionOrder provides a topologically sorted list of task names
+				task := taskMap[taskName]
+				// Simplified input calculation for this example
+				inputFromDependencies := tr.L.NewTable()
+				// ... (dependency input logic would go here)
+
+				// Pass the session to the task execution
+				if err := tr.executeTaskWithRetries(task, inputFromDependencies, &mu, completedTasks, taskOutputs, runningTasks, session); err != nil {
+					errChan <- err
+					// In sequential execution, we might want to break on failure
+					break
+				}
 			}
-			mu.Unlock()
-
-			tasksLaunchedThisIteration := 0
-			for _, task := range taskMap {
+		} else {
+			// Original parallel execution logic
+			for {
 				mu.Lock()
-				if completedTasks[task.Name] || runningTasks[task.Name] {
+				if len(completedTasks) == len(tasksToRun) {
 					mu.Unlock()
-					continue
+					break
 				}
 				mu.Unlock()
 
-				dependencyMet := true
-				// Check 'depends_on' dependencies
-				for _, depName := range task.DependsOn {
-					if _, exists := taskMap[depName]; exists {
-						mu.Lock()
-						completed := completedTasks[depName]
-						if !completed {
-							dependencyMet = false
-						} else {
-							var depSuccess bool
-							for _, res := range tr.Results {
-								if res.Name == depName && res.Error == nil {
-									depSuccess = true
-									break
-								}
-							}
-							if !depSuccess {
-								dependencyMet = false
-								                                tr.Results = append(tr.Results, types.TaskResult{
-								                                    Name:   task.Name,
-								                                    Status: "Skipped",
-								                                    Error:  fmt.Errorf("dependency '%s' failed", depName),
-								                                })
-								                                completedTasks[task.Name] = true							}
-						}
+				tasksLaunchedThisIteration := 0
+				for _, task := range taskMap {
+					mu.Lock()
+					if completedTasks[task.Name] || runningTasks[task.Name] {
 						mu.Unlock()
-						if !dependencyMet {
-							break
-						}
+						continue
 					}
-				}
+					mu.Unlock()
 
-				// Check 'next_if_fail' dependencies only if 'depends_on' are met
-				if dependencyMet && len(task.NextIfFail) > 0 {
-					nextIfFailMet := false
-					allNextIfFailCompleted := true
-					for _, depName := range task.NextIfFail {
+					dependencyMet := true
+					// Check 'depends_on' dependencies
+					for _, depName := range task.DependsOn {
 						if _, exists := taskMap[depName]; exists {
 							mu.Lock()
 							completed := completedTasks[depName]
 							if !completed {
-								allNextIfFailCompleted = false
+								dependencyMet = false
 							} else {
-								var depFailed bool
+								var depSuccess bool
 								for _, res := range tr.Results {
-									if res.Name == depName && res.Error != nil {
-										depFailed = true
+									if res.Name == depName && res.Error == nil {
+										depSuccess = true
 										break
 									}
 								}
-								if depFailed {
-									nextIfFailMet = true
+								if !depSuccess {
+									dependencyMet = false
+									tr.Results = append(tr.Results, types.TaskResult{
+										Name:   task.Name,
+										Status: "Skipped",
+										Error:  fmt.Errorf("dependency '%s' failed", depName),
+									})
+									completedTasks[task.Name] = true
 								}
 							}
 							mu.Unlock()
+							if !dependencyMet {
+								break
+							}
 						}
 					}
 
-					if !allNextIfFailCompleted {
-						dependencyMet = false
-					} else if !nextIfFailMet {
-						dependencyMet = false
-						mu.Lock()
-						tr.Results = append(tr.Results, types.TaskResult{
-							Name:   task.Name,
-							Status: "Skipped",
-							Error:  fmt.Errorf("none of the next_if_fail dependencies for '%s' failed", task.Name),
-						})
-						completedTasks[task.Name] = true
-						mu.Unlock()
-					}
-				}
+					// Check 'next_if_fail' dependencies only if 'depends_on' are met
+					if dependencyMet && len(task.NextIfFail) > 0 {
+						nextIfFailMet := false
+						allNextIfFailCompleted := true
+						for _, depName := range task.NextIfFail {
+							if _, exists := taskMap[depName]; exists {
+								mu.Lock()
+								completed := completedTasks[depName]
+								if !completed {
+									allNextIfFailCompleted = false
+								} else {
+									var depFailed bool
+									for _, res := range tr.Results {
+										if res.Name == depName && res.Error != nil {
+											depFailed = true
+											break
+										}
+									}
+									if depFailed {
+										nextIfFailMet = true
+									}
+								}
+								mu.Unlock()
+							}
+						}
 
-				if dependencyMet {
-					tasksLaunchedThisIteration++
-					inputFromDependencies := tr.L.NewTable()
-					for _, depName := range task.DependsOn {
-						if _, exists := taskMap[depName]; exists {
+						if !allNextIfFailCompleted {
+							dependencyMet = false
+						} else if !nextIfFailMet {
+							dependencyMet = false
 							mu.Lock()
-							depOutput := taskOutputs[depName]
+							tr.Results = append(tr.Results, types.TaskResult{
+								Name:   task.Name,
+								Status: "Skipped",
+								Error:  fmt.Errorf("none of the next_if_fail dependencies for '%s' failed", task.Name),
+							})
+							completedTasks[task.Name] = true
 							mu.Unlock()
-							if depOutput != nil {
-								inputFromDependencies.RawSetString(depName, depOutput)
-							} else {
-								inputFromDependencies.RawSetString(depName, tr.L.NewTable())
-							}
 						}
 					}
-					for _, depName := range task.NextIfFail {
-						if _, exists := taskMap[depName]; exists {
-							mu.Lock()
-							depOutput := taskOutputs[depName]
-							mu.Unlock()
-							if depOutput != nil {
-								inputFromDependencies.RawSetString(depName, depOutput)
-							} else {
-								inputFromDependencies.RawSetString(depName, tr.L.NewTable())
+
+					if dependencyMet {
+						tasksLaunchedThisIteration++
+						inputFromDependencies := tr.L.NewTable()
+						for _, depName := range task.DependsOn {
+							if _, exists := taskMap[depName]; exists {
+								mu.Lock()
+								depOutput := taskOutputs[depName]
+								mu.Unlock()
+								if depOutput != nil {
+									inputFromDependencies.RawSetString(depName, depOutput)
+								} else {
+									inputFromDependencies.RawSetString(depName, tr.L.NewTable())
+								}
+							}
+						}
+						for _, depName := range task.NextIfFail {
+							if _, exists := taskMap[depName]; exists {
+								mu.Lock()
+								depOutput := taskOutputs[depName]
+								mu.Unlock()
+								if depOutput != nil {
+									inputFromDependencies.RawSetString(depName, depOutput)
+								} else {
+									inputFromDependencies.RawSetString(depName, tr.L.NewTable())
+								}
 							}
 						}
-					}
 
-					if task.Async {
-						mu.Lock()
-						runningTasks[task.Name] = true
-						mu.Unlock()
-						wg.Add(1)
-						go func(t *types.Task, input *lua.LTable) {
-							defer wg.Done()
-							if err := tr.executeTaskWithRetries(t, input, &mu, completedTasks, taskOutputs, runningTasks); err != nil {
+						if task.Async {
+							mu.Lock()
+							runningTasks[task.Name] = true
+							mu.Unlock()
+							wg.Add(1)
+							go func(t *types.Task, input *lua.LTable) {
+								defer wg.Done()
+								if err := tr.executeTaskWithRetries(t, input, &mu, completedTasks, taskOutputs, runningTasks, nil); err != nil {
+									errChan <- err
+								}
+							}(task, inputFromDependencies)
+						} else {
+							mu.Lock()
+							runningTasks[task.Name] = true
+							mu.Unlock()
+							if err := tr.executeTaskWithRetries(task, inputFromDependencies, &mu, completedTasks, taskOutputs, runningTasks, nil); err != nil {
 								errChan <- err
 							}
-						}(task, inputFromDependencies)
-					} else {
-						mu.Lock()
-						runningTasks[task.Name] = true
-						mu.Unlock()
-						if err := tr.executeTaskWithRetries(task, inputFromDependencies, &mu, completedTasks, taskOutputs, runningTasks); err != nil {
-							errChan <- err
 						}
 					}
 				}
-			}
 
-			if tasksLaunchedThisIteration == 0 {
-				mu.Lock()
-				if len(completedTasks) < len(tasksToRun) {
-					uncompletedTasks := []string{}
-					for _, task := range tasksToRun {
-						if !completedTasks[task.Name] {
-							uncompletedTasks = append(uncompletedTasks, task.Name)
+				if tasksLaunchedThisIteration == 0 {
+					mu.Lock()
+					if len(completedTasks) < len(tasksToRun) {
+						uncompletedTasks := []string{}
+						for _, task := range tasksToRun {
+							if !completedTasks[task.Name] {
+								uncompletedTasks = append(uncompletedTasks, task.Name)
+							}
 						}
+						mu.Unlock()
+						circularErr := &TaskExecutionError{TaskName: "group " + groupName, Err: fmt.Errorf("circular dependency or unresolvable tasks. Uncompleted tasks: %v", uncompletedTasks)}
+						log.Println(circularErr.Error())
+						errChan <- circularErr
+						break
 					}
 					mu.Unlock()
-					circularErr := &TaskExecutionError{TaskName: "group " + groupName, Err: fmt.Errorf("circular dependency or unresolvable tasks. Uncompleted tasks: %v", uncompletedTasks)}
-					log.Println(circularErr.Error())
-					errChan <- circularErr
-					break
 				}
-				mu.Unlock()
+				wg.Wait()
 			}
-			wg.Wait()
 		}
 
 		close(errChan)
@@ -485,6 +573,21 @@ func (tr *TaskRunner) Run() error {
 	}
 	return nil
 }
+
+// Helper function to get a sequential, dependency-respecting order of tasks.
+// NOTE: This is a placeholder for a proper topological sort implementation.
+func getExecutionOrder(taskMap map[string]*types.Task) []string {
+	// This should be a topological sort based on DependsOn.
+	// For this example, we'll use a simplified, hardcoded order.
+	// A real implementation is required here.
+	names := make([]string, 0, len(taskMap))
+	for name := range taskMap {
+		names = append(names, name)
+	}
+	// This is NOT a correct sort, just for placeholder.
+	return names
+}
+
 func (tr *TaskRunner) resolveTasksToRun(originalTaskMap map[string]*types.Task, targetTasks []string) ([]*types.Task, error) {
 	if len(targetTasks) == 0 {
 		var allTasks []*types.Task
@@ -535,7 +638,7 @@ func (tr *TaskRunner) resolveTasksToRun(originalTaskMap map[string]*types.Task,
 func (tr *TaskRunner) RunTasksParallel(tasks []*types.Task, input *lua.LTable) ([]types.TaskResult, error) {
 	var wg sync.WaitGroup
 	var mu sync.Mutex
-	
+
 	resultsChan := make(chan types.TaskResult, len(tasks))
 	errChan := make(chan error, len(tasks))
 
@@ -543,17 +646,17 @@ func (tr *TaskRunner) RunTasksParallel(tasks []*types.Task, input *lua.LTable) (
 		wg.Add(1)
 		go func(t *types.Task) {
 			defer wg.Done()
-			
+
 			// These maps are for the context of a single parallel execution, not the whole runner
 			completed := make(map[string]bool)
 			outputs := make(map[string]*lua.LTable)
 			running := make(map[string]bool)
-			
+
 			// We use a new mutex for the retry logic within the task execution
 			var taskMu sync.Mutex
 
-			err := tr.executeTaskWithRetries(t, input, &taskMu, completed, outputs, running)
-			
+			err := tr.executeTaskWithRetries(t, input, &taskMu, completed, outputs, running, nil)
+
 			// Find the result for this specific task. executeTaskWithRetries appends to tr.Results.
 			// This is a bit of a workaround due to the existing structure.
 			// A better long-term solution would be for executeTaskWithRetries to return the TaskResult.
@@ -596,4 +699,4 @@ func (tr *TaskRunner) RunTasksParallel(tasks []*types.Task, input *lua.LTable) (
 	}
 
 	return results, nil
-}
\ No newline at end of file
+}
diff --git a/internal/taskrunner/taskrunner_test.go b/internal/taskrunner/taskrunner_test.go
index 8271438..20148f4 100644
--- a/internal/taskrunner/taskrunner_test.go
+++ b/internal/taskrunner/taskrunner_test.go
@@ -19,7 +19,7 @@ func TestRun_Successful_DependencyResolution(t *testing.T) {
 	groups := map[string]types.TaskGroup{
 		"test_group": {Tasks: []types.Task{task1, task2}},
 	}
-	tr := NewTaskRunner(L, groups, "test_group", nil, false) 
+	tr := NewTaskRunner(L, groups, "test_group", nil, false)
 	err := tr.Run()
 	assert.NoError(t, err)
 }
diff --git a/internal/types/types.go b/internal/types/types.go
index 2488fc6..a519ce7 100644
--- a/internal/types/types.go
+++ b/internal/types/types.go
@@ -1,10 +1,66 @@
 package types
 
 import (
-	"time"
+	"bufio"
+	"fmt"
 	lua "github.com/yuin/gopher-lua"
+	"io"
+	"os/exec"
+	"strings"
+	"sync"
+	"time"
 )
 
+// SharedSession manages a persistent shell process.
+type SharedSession struct {
+	Cmd    *exec.Cmd
+	Stdin  io.WriteCloser
+	Stdout io.ReadCloser
+	Stderr io.ReadCloser
+	Mu     sync.Mutex
+}
+
+// ExecuteCommand runs a command in the persistent shell.
+func (s *SharedSession) ExecuteCommand(command string, workdir string) (string, string, error) {
+	s.Mu.Lock()
+	defer s.Mu.Unlock()
+
+	// Unique boundary to mark end of output
+	boundary := fmt.Sprintf("END_OF_COMMAND_%d", time.Now().UnixNano())
+
+	// We need a reader for stdout to read until the boundary
+	reader := bufio.NewReader(s.Stdout)
+
+	// Execute command, merge stderr to stdout, and echo boundary
+	fullCommand := fmt.Sprintf("cd %s && %s 2>&1; echo %s\n", workdir, command, boundary)
+	if _, err := s.Stdin.Write([]byte(fullCommand)); err != nil {
+		return "", "", err
+	}
+
+	// Read stdout until boundary
+	var stdout, stderr strings.Builder
+	for {
+		line, err := reader.ReadString('\n')
+		if err != nil {
+			return "", "", err
+		}
+		if strings.Contains(line, boundary) {
+			break
+		}
+		stdout.WriteString(line)
+	}
+
+	return stdout.String(), stderr.String(), nil
+}
+
+// Close terminates the persistent shell session.
+func (s *SharedSession) Close() error {
+	if s.Cmd.Process != nil {
+		return s.Cmd.Process.Kill()
+	}
+	return nil
+}
+
 // TaskResult holds the outcome of a single task execution.
 type TaskResult struct {
 	Name     string
@@ -34,10 +90,13 @@ type Task struct {
 }
 
 type TaskGroup struct {
-	Description string
-	Tasks       []Task
+	Description              string
+	Tasks                    []Task
+	CreateWorkdirBeforeRun   bool
+	CleanWorkdirAfterRunFunc *lua.LFunction
+	ExecutionMode            string // "isolated" (default) or "shared_session"
 }
 
 type TaskRunner interface {
 	RunTasksParallel(tasks []*Task, input *lua.LTable) ([]TaskResult, error)
-}
\ No newline at end of file
+}
