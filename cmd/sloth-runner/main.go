package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"strconv"
	"strings"
	"text/tabwriter"
	"text/template"

	"github.com/AlecAivazis/survey/v2"
	"github.com/spf13/cobra"
	"gopkg.in/yaml.v2"

	"github.com/chalkan3/sloth-runner/internal/luainterface"
	"github.com/chalkan3/sloth-runner/internal/taskrunner"
	"github.com/chalkan3/sloth-runner/internal/types"
	lua "github.com/yuin/gopher-lua"
)

// --- Início: Definição Centralizada de Templates ---

// Template defines a structure for a scaffolding template.
type Template struct {
	Name        string
	Description string
	Content     string
}

// templateRegistry is the single source of truth for all available templates.
var templateRegistry = map[string]Template{
	"simple": {
		Name:        "simple",
		Description: "Generates a single group with a 'hello world' task. Ideal for getting started.",
		Content: `
-- Task definitions for group: {{.GroupName}}
-- Generated by: sloth-runner new (template: simple)
TaskDefinitions = {
  ["{{.GroupName}}"] = {
    description = "TODO: Add a description for the {{.GroupName}} task group.",
    tasks = {
      {
        name = "hello_task",
        description = "An example task. Modify or add new tasks here.",
        command = function(params)
          local workdir = params.workdir
          log.info("Running example task for group {{.GroupName}} in: " .. workdir)
          local stdout, stderr, err = exec.command("echo 'Hello from sloth-runner!'")
          if err then
            log.error("Failed to run example task: " .. stderr)
            return false, "Dummy task failed."
          else
            log.info("Example task completed successfully.")
            print("Command output: " .. stdout)
            return true, "Dummy task executed successfully."
          end
        end
      }
    }
  }
}
`,
	},
	"python": {
		Name:        "python",
		Description: "Creates a pipeline to set up a Python environment, install dependencies, and run a script.",
		Content: `
-- Task definitions for group: {{.GroupName}}
-- Generated by: sloth-runner new (template: python)
TaskDefinitions = {
  ["{{.GroupName}}"] = {
    description = "A pipeline to set up a Python environment and run a script.",
    clean_workdir_after_run = function(last_result)
      if not last_result.success then
        log.error("Task failed. The workdir will be kept for debugging at: " .. last_result.output.workdir)
      end
      return last_result.success
    end,
    tasks = {
      {
        name = "run_python_script",
        description = "Creates a venv, installs dependencies, and runs the main script.",
        command = function(params)
          local workdir = params.workdir
          log.info("Starting Python task in workdir: " .. workdir)
          fs.write(workdir .. "/requirements.txt", "requests")
          fs.write(workdir .. "/main.py", "import requests; print('Hello from Python! Requests version: %s' % requests.__version__)")
          local python = require("python")
          local venv = python.venv(workdir .. "/.venv")
          log.info("Creating virtual environment...")
          venv:create()
          log.info("Installing dependencies...")
          venv:pip("install -r " .. workdir .. "/requirements.txt")
          log.info("Running script...")
          local result = venv:exec(workdir .. "/main.py")
          result.workdir = workdir
          return result.success, "Python task finished.", result
        end
      }
    }
  }
}
`,
	},
	"parallel": {
		Name:        "parallel",
		Description: "Demonstrates how to run multiple tasks concurrently.",
		Content: `
-- Task definitions for group: {{.GroupName}}
-- Generated by: sloth-runner new (template: parallel)
TaskDefinitions = {
  ["{{.GroupName}}"] = {
    description = "An example of running tasks in parallel.",
    tasks = {
      { name = "short_task", command = "sleep 1 && echo 'Short task finished.'" },
      { name = "medium_task", command = "sleep 2 && echo 'Medium task finished.'" },
      { name = "long_task", command = "sleep 3 && echo 'Long task finished.'" },
      {
        name = "run_all_in_parallel",
        description = "Executes the sleep tasks concurrently.",
        command = function()
          log.info("Starting 3 tasks in parallel...")
          local results, err = parallel({
            { name = "short_task" },
            { name = "medium_task" },
            { name = "long_task" }
          })
          if err then
            log.error("Parallel execution encountered an error: " .. err)
            return false, "Parallel execution failed"
          end
          log.info("All parallel tasks have completed.")
          return true, "Parallel execution finished successfully.", results
        end
      }
    }
  }
}
`,
	},
	"python-pulumi": {
		Name:        "python-pulumi",
		Description: "Pipeline to deploy Pulumi infrastructure managed with Python.",
		Content: `
-- Task definitions for group: {{.GroupName}}
-- Generated by: sloth-runner new (template: python-pulumi)
TaskDefinitions = {
  ["{{.GroupName}}"] = {
    description = "A pipeline to deploy Pulumi infrastructure using a Python environment.",
    create_workdir_before_run = true,
    clean_workdir_after_run = function(last_result) return last_result.success end,
    tasks = {
      {
        name = "setup_and_deploy",
        description = "Sets up the Python environment and runs 'pulumi up'.",
        command = function(params)
          local workdir = params.workdir
          log.info("Starting Python+Pulumi pipeline in: " .. workdir)
          fs.write(workdir .. "/requirements.txt", "pulumi")
          fs.write(workdir .. "/__main__.py", "import pulumi\npulumi.export('urn', 'urn:pulumi:dev::{{.GroupName}}::pulumi:pulumi:Stack::{{.GroupName}}-dev')")
          fs.write(workdir .. "/Pulumi.yaml", "name: {{.GroupName}}\nruntime: python\ndescription: A minimal Python Pulumi program")
          local python = require("python")
          local venv = python.venv(workdir .. "/.venv")
          log.info("Creating venv...")
          venv:create()
          log.info("Installing Python dependencies...")
          venv:pip("install -r " .. workdir .. "/requirements.txt")
          local pulumi = require("pulumi")
          local stack = pulumi.stack("dev", { workdir = workdir })
          log.info("Running 'pulumi up'...")
          local up_result = stack:up({ yes = true })
          if not up_result.success then
            log.error("'pulumi up' failed: " .. up_result.stderr)
            return false, "Pulumi up failed", up_result
          end
          log.info("Pulumi up completed successfully.")
          local outputs = stack:outputs()
          return true, "Python+Pulumi pipeline finished.", outputs
        end
      }
    }
  }
}
`,
	},
	"python-pulumi-salt": {
		Name:        "python-pulumi-salt",
		Description: "Provisions infrastructure with Pulumi and configures it using SaltStack.",
		Content: `
-- Task definitions for group: {{.GroupName}}
-- Generated by: sloth-runner new (template: python-pulumi-salt)
TaskDefinitions = {
  ["{{.GroupName}}"] = {
    description = "Pipeline: Pulumi creates the infra, Salt configures it.",
    create_workdir_before_run = true,
    tasks = {
      {
        name = "deploy_infra",
        description = "Uses Python and Pulumi to create the infrastructure.",
        command = function(params)
          local workdir = params.workdir
          log.info("Starting infra deployment in: " .. workdir)
          fs.write(workdir .. "/requirements.txt", "pulumi")
          fs.write(workdir .. "/__main__.py", "import pulumi\npulumi.export('minion_id', 'test-minion-123')")
          fs.write(workdir .. "/Pulumi.yaml", "name: {{.GroupName}}\nruntime: python")
          require("python").venv(workdir .. "/.venv"):create()
          local stack = require("pulumi").stack("dev", { workdir = workdir })
          local up_result = stack:up({ yes = true })
          if not up_result.success then return false, "Pulumi up failed", up_result end
          return true, "Infrastructure created.", stack:outputs()
        end
      },
      {
        name = "configure_server",
        description = "Uses Salt to apply a highstate on the created minion.",
        depends_on = "deploy_infra",
        command = function(params, inputs)
          local minion_id = inputs.deploy_infra.minion_id
          if not minion_id then
            return false, "Minion ID not found in Pulumi outputs."
          end
          log.info("Configuring minion '" .. minion_id .. "' with Salt...")
          local salt = require("salt")
          local client = salt.client({ config_path = "/etc/salt/master" })
          local result = client:target(minion_id):cmd("state.apply")
          if not result.success then
            log.error("Failed to apply Salt state: " .. result.stderr)
            return false, "Salt state.apply failed", result
          end
          log.info("Salt configuration applied successfully.")
          return true, "Server configured.", result
        end
      }
    }
  }
}
`,
	},
	"git-python-pulumi": {
		Name:        "git-python-pulumi",
		Description: "CI/CD Pipeline: Clones a repo, sets up the environment, and deploys with Pulumi.",
		Content: `
-- Task definitions for group: {{.GroupName}}
-- Generated by: sloth-runner new (template: git-python-pulumi)
TaskDefinitions = {
  ["{{.GroupName}}"] = {
    description = "CI/CD Pipeline: Clones, sets up environment, and deploys with Pulumi.",
    create_workdir_before_run = true,
    clean_workdir_after_run = function(r) return r.success end,
    tasks = {
      {
        name = "clone_repository",
        description = "Clones the project repository.",
        command = function(params)
          local workdir = params.workdir
          log.info("Cloning repository into: " .. workdir)
          -- TODO: Replace with your repository URL
          local repo_url = "https://github.com/pulumi/examples.git"
          local result = require("git").repo(workdir):clone(repo_url)
          if not result.success then
            log.error("Failed to clone: " .. result.stderr)
            return false, "Git clone failed", result
          end
          return true, "Repository cloned."
        end
      },
      {
        name = "deploy_stack",
        description = "Installs dependencies and deploys the Pulumi stack from the repository.",
        depends_on = "clone_repository",
        command = function(params)
          local workdir = params.workdir .. "/aws-py-s3-folder" -- Example: subdirectory of the repo
          log.info("Running deployment from: " .. workdir)
          require("python").venv(workdir .. "/.venv"):create()
          local stack = require("pulumi").stack("dev", { workdir = workdir })
          local result = stack:up({ yes = true })
          return result.success, "Deployment finished.", result
        end
      }
    }
  }
}
`,
	},
}

// --- Fim: Definição de Templates ---

type TemplateData struct {
	Env          string
	IsProduction bool
	Shards       []int
}

var (
	configFilePath string
	env            string
	isProduction   bool
	shardsStr      string
	targetTasksStr string
	targetGroup    string
	valuesFilePath string
	dryRun         bool
	returnOutput   bool
	yes            bool
	outputFile     string
	templateName   string
	version        = "dev" // será substituído em tempo de compilação
)

var versionCmd = &cobra.Command{
	Use:   "version",
	Short: "Print the version number of sloth-runner",
	Long:  `All software has versions. This is sloth-runner's`,
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println(version)
	},
}

func loadAndRenderLuaConfig(L *lua.LState, configFilePath, env, shardsStr string, isProduction bool, valuesFilePath string, tr types.TaskRunner) (map[string]types.TaskGroup, error) {
	templateContent, err := ioutil.ReadFile(configFilePath)
	if err != nil {
		return nil, fmt.Errorf("error reading Lua template file %s: %w", configFilePath, err)
	}
	tmpl, err := template.New("lua_config").Parse(string(templateContent))
	if err != nil {
		return nil, fmt.Errorf("error parsing Lua template: %w", err)
	}
	var shards []int
	if shardsStr != "" {
		shardStrings := strings.Split(shardsStr, ",")
		for _, s := range shardStrings {
			shard, err := strconv.Atoi(strings.TrimSpace(s))
			if err != nil {
				return nil, fmt.Errorf("invalid shard number '%s': %w", s, err)
			}
			shards = append(shards, shard)
		}
	}
	data := TemplateData{
		Env:          env,
		IsProduction: isProduction,
		Shards:       shards,
	}
	var renderedLua bytes.Buffer
	if err := tmpl.Execute(&renderedLua, data); err != nil {
		return nil, fmt.Errorf("error executing Lua template: %w", err)
	}
	luainterface.OpenExec(L)
	luainterface.OpenFs(L)
	luainterface.OpenNet(L)
	luainterface.OpenData(L)
	luainterface.OpenLog(L)
	luainterface.OpenSalt(L)
	luainterface.OpenPulumi(L)
	luainterface.OpenGit(L)
	luainterface.OpenPython(L)
	luainterface.OpenImport(L, configFilePath)
	luainterface.OpenParallel(L, tr)
	if valuesFilePath != "" {
		valuesContent, err := ioutil.ReadFile(valuesFilePath)
		if err != nil {
			return nil, fmt.Errorf("error reading values file %s: %w", valuesFilePath, err)
		}
		var goValues map[string]interface{}
		if err := yaml.Unmarshal(valuesContent, &goValues); err != nil {
			return nil, fmt.Errorf("error parsing values YAML from %s: %w", valuesFilePath, err)
		}
		luaValues := luainterface.GoValueToLua(L, goValues)
		L.SetGlobal("values", luaValues)
	}
	taskGroups, err := luainterface.LoadTaskDefinitions(L, renderedLua.String(), configFilePath)
	if err != nil {
		return nil, fmt.Errorf("error loading task definitions: %w", err)
	}
	return taskGroups, nil
}

var rootCmd = &cobra.Command{
	Use:   "sloth-runner",
	Short: "A flexible sloth-runner with Lua scripting capabilities",
	Long: `sloth-runner is a command-line tool that allows you to define and execute
tasks using Lua scripts. It supports pipelines, workflows, dynamic task generation,
and output manipulation.`,
	Run: func(cmd *cobra.Command, args []string) {
		cmd.Help()
	},
}

var templateCmd = &cobra.Command{
	Use:   "template",
	Short: "Manage task templates",
	Long:  "Provides commands to list and manage available task templates.",
}

var templateListCmd = &cobra.Command{
	Use:   "list",
	Short: "Lists all available templates",
	Long:  "Displays a table of all available templates that can be used with the 'new' command.",
	RunE: func(cmd *cobra.Command, args []string) error {
		w := tabwriter.NewWriter(os.Stdout, 0, 0, 3, ' ', 0)
		fmt.Fprintln(w, "TEMPLATE NAME\tDESCRIPTION")
		fmt.Fprintln(w, "-------------\t-----------")

		for _, tmpl := range templateRegistry {
			fmt.Fprintf(w, "%s\t%s\n", tmpl.Name, tmpl.Description)
		}

		return w.Flush()
	},
}

var newCmd = &cobra.Command{
	Use:   "new <group-name>",
	Short: "Generates a new task definition file from a template",
	Long: `The new command creates a boilerplate Lua task definition file.
You can choose from different templates and specify an output file.
Run 'sloth-runner template list' to see all available templates.`,
	Args: cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		groupName := args[0]
		sanitizedGroupName := strings.ReplaceAll(groupName, " ", "-")

		tmpl, ok := templateRegistry[templateName]
		if !ok {
			return fmt.Errorf("invalid template '%s'. Use 'sloth-runner template list' to see the options", templateName)
		}

		data := struct {
			GroupName string
		}{
			GroupName: sanitizedGroupName,
		}
		t, err := template.New("new_task").Parse(tmpl.Content)
		if err != nil {
			return fmt.Errorf("internal error processing template: %w", err)
		}
		var output bytes.Buffer
		if err := t.Execute(&output, data); err != nil {
			return fmt.Errorf("error populating template: %w", err)
		}
		if outputFile != "" {
			if err := ioutil.WriteFile(outputFile, output.Bytes(), 0644); err != nil {
				return fmt.Errorf("failed to write to file %s: %w", outputFile, err)
			}
			fmt.Fprintf(os.Stderr, "✓ Task file '%s' generated successfully for group '%s'.\n", outputFile, sanitizedGroupName)
		} else {
			fmt.Println(output.String())
		}
		return nil
	},
}

var runCmd = &cobra.Command{
	Use:   "run",
	Short: "Executes tasks defined in a Lua template file",
	Long: `The run command executes tasks defined in a Lua template file.
You can specify the file, environment variables, and target specific tasks or groups.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		L := lua.NewState()
		defer L.Close()
		var dummyTr types.TaskRunner = nil
		taskGroups, err := loadAndRenderLuaConfig(L, configFilePath, env, shardsStr, isProduction, valuesFilePath, dummyTr)
		if err != nil {
			return err
		}
		var targetTasks []string
		if targetTasksStr != "" {
			targetTasks = strings.Split(targetTasksStr, ",")
			for i, task := range targetTasks {
				targetTasks[i] = strings.TrimSpace(task)
			}
		} else {
			var allTasks []string
			if targetGroup != "" {
				if group, ok := taskGroups[targetGroup]; ok {
					for _, task := range group.Tasks {
						allTasks = append(allTasks, task.Name)
					}
				} else {
					return fmt.Errorf("task group '%s' not found", targetGroup)
				}
			} else {
				for _, group := range taskGroups {
					for _, task := range group.Tasks {
						allTasks = append(allTasks, task.Name)
					}
				}
			}
			if len(allTasks) == 0 {
				fmt.Println("No tasks found to run.")
				return nil
			}
			if yes {
				targetTasks = allTasks
			} else {
				prompt := &survey.MultiSelect{
					Message: "Select tasks to run:",
					Options: allTasks,
				}
			survey.AskOne(prompt, &targetTasks)
			}
		}
		if len(targetTasks) == 0 {
			fmt.Println("No tasks selected.")
			return nil
		}
		tr := taskrunner.NewTaskRunner(L, taskGroups, targetGroup, targetTasks, dryRun)
		luainterface.OpenParallel(L, tr)
		if err := tr.Run(); err != nil {
			return fmt.Errorf("error running tasks: %w", err)
		}
		if returnOutput {
			finalOutputs := make(map[string]interface{})
			for _, taskName := range targetTasks {
				if output, ok := tr.Outputs[taskName]; ok {
					finalOutputs[taskName] = output
				}
			}
			var outputToMarshal interface{}
			if len(targetTasks) == 1 {
				if val, ok := finalOutputs[targetTasks[0]]; ok {
					outputToMarshal = val
				} else {
					outputToMarshal = make(map[string]interface{})
				}
			} else {
				outputToMarshal = finalOutputs
			}
			jsonOutput, err := json.Marshal(outputToMarshal)
			if err != nil {
				return fmt.Errorf("error marshaling final task output to JSON: %w", err)
			}
			fmt.Println(string(jsonOutput))
		}
		return nil
	},
}

var listCmd = &cobra.Command{
	Use:   "list",
	Short: "Lists all available task groups and tasks",
	Long:  `The list command displays all task groups and their respective tasks, along with their descriptions and dependencies.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		L := lua.NewState()
		defer L.Close()
		taskGroups, err := loadAndRenderLuaConfig(L, configFilePath, env, shardsStr, isProduction, valuesFilePath, nil)
		if err != nil {
			return err
		}
		if len(taskGroups) == 0 {
			fmt.Println("No task groups found.")
			return nil
		}
		fmt.Println("Available Task Groups and Tasks:")
		for groupName, group := range taskGroups {
			fmt.Printf("\n  Group: %s (Description: %s)\n", groupName, group.Description)
			if len(group.Tasks) == 0 {
				fmt.Println("    No tasks defined in this group.")
				continue
			}
			for _, task := range group.Tasks {
				fmt.Printf("    - Task: %s\n", task.Name)
				fmt.Printf("      Description: %s\n", task.Description)
				if len(task.DependsOn) > 0 {
					fmt.Printf("      Depends On: %s\n", strings.Join(task.DependsOn, ", "))
				}
				fmt.Printf("      Async: %t\n", task.Async)
			}
		}
		return nil
	},
}

var validateCmd = &cobra.Command{
	Use:   "validate",
	Short: "Validates the syntax and structure of a Lua task file",
	Long:  `The validate command checks a Lua task file for syntax errors and ensures that the TaskDefinitions table is correctly structured.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		L := lua.NewState()
		defer L.Close()
		_, err := loadAndRenderLuaConfig(L, configFilePath, env, shardsStr, isProduction, valuesFilePath, nil)
		if err != nil {
			return err
		}
		fmt.Println("✅ Configuration file is valid.")
		return nil
	},
}

func init() {
	rootCmd.AddCommand(versionCmd)
	rootCmd.AddCommand(templateCmd)
	templateCmd.AddCommand(templateListCmd)
	rootCmd.AddCommand(newCmd)
	rootCmd.AddCommand(runCmd)
	rootCmd.AddCommand(listCmd)
	rootCmd.AddCommand(validateCmd)
	newCmd.Flags().StringVarP(&outputFile, "output", "o", "", "Output file path (default: stdout)")
	newCmd.Flags().StringVarP(&templateName, "template", "t", "simple", "Template to use. See 'template list' for options.")
	runCmd.Flags().StringVarP(&configFilePath, "file", "f", "examples/basic_pipeline.lua", "Path to the Lua task configuration template file")
	runCmd.Flags().StringVarP(&env, "env", "e", "Development", "Environment for the tasks (e.g., Development, Production)")
	runCmd.Flags().BoolVarP(&isProduction, "prod", "p", false, "Set to true for production environment")
	runCmd.Flags().StringVar(&shardsStr, "shards", "1,2,3", "Comma-separated list of shard numbers (e.g., 1,2,3)")
	runCmd.Flags().StringVarP(&targetTasksStr, "tasks", "t", "", "Comma-separated list of specific tasks to run (e.g., task1,task2)")
	runCmd.Flags().StringVarP(&targetGroup, "group", "g", "", "Run tasks only from a specific task group")
	runCmd.Flags().StringVarP(&valuesFilePath, "values", "v", "", "Path to a YAML file with values to be passed to Lua tasks")
	runCmd.Flags().BoolVarP(&dryRun, "dry-run", "d", false, "Simulate the execution of tasks without actually running them")
	runCmd.Flags().BoolVar(&returnOutput, "return", false, "Return the output of the target tasks as JSON")
	runCmd.Flags().BoolVarP(&yes, "yes", "y", false, "Bypass interactive task selection and run all tasks")
	listCmd.Flags().StringVarP(&configFilePath, "file", "f", "examples/basic_pipeline.lua", "Path to the Lua task configuration template file")
	listCmd.Flags().StringVarP(&env, "env", "e", "Development", "Environment for the tasks (e.g., Development, Production)")
	listCmd.Flags().BoolVarP(&isProduction, "prod", "p", false, "Set to true for production environment")
	listCmd.Flags().StringVar(&shardsStr, "shards", "1,2,3", "Comma-separated list of shard numbers (e.g., 1,2,3)")
	listCmd.Flags().StringVarP(&valuesFilePath, "values", "v", "", "Path to a YAML file with values to be passed to Lua tasks")
	validateCmd.Flags().StringVarP(&configFilePath, "file", "f", "examples/basic_pipeline.lua", "Path to the Lua task configuration template file")
	validateCmd.Flags().StringVarP(&env, "env", "e", "Development", "Environment for the tasks (e.g., Development, Production)")
	validateCmd.Flags().BoolVarP(&isProduction, "prod", "p", false, "Set to true for production environment")
	validateCmd.Flags().StringVar(&shardsStr, "shards", "1,2,3", "Comma-separated list of shard numbers (e.g., 1,2,3)")
	validateCmd.Flags().StringVarP(&valuesFilePath, "values", "v", "", "Path to a YAML file with values to be passed to Lua tasks")
}

func main() {
	rootCmd.SilenceUsage = true // Suprime a ajuda em erros de execução
	if err := rootCmd.Execute(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}