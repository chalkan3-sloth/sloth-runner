package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log/slog"
	"os"
	"os/exec"
	"strconv"
	"strings"
	"text/tabwriter"
	"text/template"

	"github.com/AlecAivazis/survey/v2"
	"github.com/pterm/pterm"
	"github.com/spf13/cobra"
	"gopkg.in/yaml.v2"

	"github.com/chalkan3/sloth-runner/internal/luainterface"
	"github.com/chalkan3/sloth-runner/internal/repl"
	"github.com/chalkan3/sloth-runner/internal/taskrunner"
	"github.com/chalkan3/sloth-runner/internal/types"
	"github.com/chalkan3/sloth-runner/ui"
	lua "github.com/yuin/gopher-lua"
)

var uiCmd = &cobra.Command{
	Use:   "ui",
	Short: "Starts the web-based UI for viewing pipeline history",
	Long:  "The ui command starts a local web server to provide a graphical user interface for Sloth-Runner.",
	RunE: func(cmd *cobra.Command, args []string) error {
		db, err := ui.InitDB()
		if err != nil {
			return fmt.Errorf("failed to initialize database: %w", err)
		}
		defer db.Close()
		ui.StartServer(db)
		return nil
	},
}

var replCmd = &cobra.Command{
	Use:   "repl",
	Short: "Starts an interactive REPL session",
	Long: `The repl command starts an interactive Read-Eval-Print Loop that allows you
to execute Lua code and interact with all the built-in sloth-runner modules.
You can optionally load a workflow file to have its context available.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		workflowFile, _ := cmd.Flags().GetString("file")
		repl.Start(workflowFile)
		return nil
	},
}

// --- Start: Centralized Template Definitions ---

// Template defines a structure for a scaffolding template.
type Template struct {
	Name        string
	Description string
	Content     string
}

// templateRegistry is the single source of truth for all available templates.
var templateRegistry = map[string]Template{
	"simple": {
		Name:        "simple",
		Description: "Generates a single group with a 'hello world' task. Ideal for getting started.",
		Content: `
-- Task definitions for group: {{.GroupName}}
-- Generated by: sloth-runner new (template: simple)
TaskDefinitions = {
  ["{{.GroupName}}"] = {
    description = "TODO: Add a description for the {{.GroupName}} task group.",
    tasks = {
      {
        name = "hello_task",
        description = "An example task. Modify or add new tasks here.",
        command = function(params)
          local workdir = params.workdir
          log.info("Running example task for group {{.GroupName}} in: " .. workdir)
          local stdout, stderr, err = exec.command("echo 'Hello from sloth-runner!'")
          if err then
            log.error("Failed to run example task: " .. stderr)
            return false, "Dummy task failed."
          else
            log.info("Example task completed successfully.")
            print("Command output: " .. stdout)
            return true, "Dummy task executed successfully."
          end
        end
      }
    }
  }
}
`,
	},
	"python": {
		Name:        "python",
		Description: "Creates a pipeline to set up a Python environment, install dependencies, and run a script.",
		Content: `
-- Task definitions for group: {{.GroupName}}
-- Generated by: sloth-runner new (template: python)
TaskDefinitions = {
  ["{{.GroupName}}"] = {
    description = "A pipeline to set up a Python environment and run a script.",
    clean_workdir_after_run = function(last_result)
      if not last_result.success then
        log.error("Task failed. The workdir will be kept for debugging at: " .. last_result.output.workdir)
      end
      return last_result.success
    end,
    tasks = {
      {
        name = "run_python_script",
        description = "Creates a venv, installs dependencies, and runs the main script.",
        command = function(params)
          local workdir = params.workdir
          log.info("Starting Python task in workdir: " .. workdir)
          fs.write(workdir .. "/requirements.txt", "requests")
          fs.write(workdir .. "/main.py", "import requests; print('Hello from Python! Requests version: %s' % requests.__version__)")
          local python = require("python")
          local venv = python.venv(workdir .. "/.venv")
          log.info("Creating virtual environment...")
          venv:create()
          log.info("Installing dependencies...")
          venv:pip("install -r " .. workdir .. "/requirements.txt")
          log.info("Running script...")
          local result = venv:exec(workdir .. "/main.py")
          result.workdir = workdir
          return result.success, "Python task finished.", result
        end
      }
    }
  }
}
`,
	},
	"parallel": {
		Name:        "parallel",
		Description: "Demonstrates how to run multiple tasks concurrently.",
		Content: `
-- Task definitions for group: {{.GroupName}}
-- Generated by: sloth-runner new (template: parallel)
TaskDefinitions = {
  ["{{.GroupName}}"] = {
    description = "An example of running tasks in parallel.",
    tasks = {
      { name = "short_task", command = "sleep 1 && echo 'Short task finished.'" },
      { name = "medium_task", command = "sleep 2 && echo 'Medium task finished.'" },
      { name = "long_task", command = "sleep 3 && echo 'Long task finished.'" },
      {
        name = "run_all_in_parallel",
        description = "Executes the sleep tasks concurrently.",
        command = function()
          log.info("Starting 3 tasks in parallel...")
          local results, err = parallel({
            { name = "short_task" },
            { name = "medium_task" },
            { name = "long_task" }
          })
          if err then
            log.error("Parallel execution encountered an error: " .. err)
            return false, "Parallel execution failed"
          end
          log.info("All parallel tasks have completed.")
          return true, "Parallel execution finished successfully.", results
        end
      }
    }
  }
}
`,
	},
	"python-pulumi": {
		Name:        "python-pulumi",
		Description: "Pipeline to deploy Pulumi infrastructure managed with Python.",
		Content: `
-- Task definitions for group: {{.GroupName}}
-- Generated by: sloth-runner new (template: python-pulumi)
TaskDefinitions = {
  ["{{.GroupName}}"] = {
    description = "A pipeline to deploy Pulumi infrastructure using a Python environment.",
    create_workdir_before_run = true,
    clean_workdir_after_run = function(last_result) return last_result.success end,
    tasks = {
      {
        name = "setup_and_deploy",
        description = "Sets up the Python environment and runs 'pulumi up'.",
        command = function(params)
          local workdir = params.workdir
          log.info("Starting Python+Pulumi pipeline in: " .. workdir)
          fs.write(workdir .. "/requirements.txt", "pulumi")
          fs.write(workdir .. "/__main__.py", "import pulumi\npulumi.export('urn', 'urn:pulumi:dev::{{.GroupName}}::pulumi:pulumi:Stack::{{.GroupName}}-dev')")
          fs.write(workdir .. "/Pulumi.yaml", "name: {{.GroupName}}\nruntime: python\ndescription: A minimal Python Pulumi program")
          local python = require("python")
          local venv = python.venv(workdir .. "/.venv")
          log.info("Creating venv...")
          venv:create()
          log.info("Installing Python dependencies...")
          venv:pip("install -r " .. workdir .. "/requirements.txt")
          local pulumi = require("pulumi")
          local stack = pulumi.stack("dev", { workdir = workdir })
          log.info("Running 'pulumi up'...")
          local up_result = stack:up({ yes = true })
          if not up_result.success then
            log.error("'pulumi up' failed: " .. up_result.stderr)
            return false, "Pulumi up failed", up_result
          end
          log.info("Pulumi up completed successfully.")
          local outputs = stack:outputs()
          return true, "Python+Pulumi pipeline finished.", outputs
        end
      }
    }
  }
}
`,
	},
	"python-pulumi-salt": {
		Name:        "python-pulumi-salt",
		Description: "Provisions infrastructure with Pulumi and configures it using SaltStack.",
		Content: `
-- Task definitions for group: {{.GroupName}}
-- Generated by: sloth-runner new (template: python-pulumi-salt)
TaskDefinitions = {
  ["{{.GroupName}}"] = {
    description = "Pipeline: Pulumi creates the infra, Salt configures it.",
    create_workdir_before_run = true,
    tasks = {
      {
        name = "deploy_infra",
        description = "Uses Python and Pulumi to create the infrastructure.",
        command = function(params)
          local workdir = params.workdir
          log.info("Starting infra deployment in: " .. workdir)
          fs.write(workdir .. "/requirements.txt", "pulumi")
          fs.write(workdir .. "/__main__.py", "import pulumi\npulumi.export('minion_id', 'test-minion-123')")
          fs.write(workdir .. "/Pulumi.yaml", "name: {{.GroupName}}\nruntime: python")
          require("python").venv(workdir .. "/.venv"):create()
          local stack = require("pulumi").stack("dev", { workdir = workdir })
          local up_result = stack:up({ yes = true })
          if not up_result.success then return false, "Pulumi up failed", up_result end
          return true, "Infrastructure created.", stack:outputs()
        end
      },
      {
        name = "configure_server",
        description = "Uses Salt to apply a highstate on the created minion.",
        depends_on = "deploy_infra",
        command = function(params, inputs)
          local minion_id = inputs.deploy_infra.minion_id
          if not minion_id then
            return false, "Minion ID not found in Pulumi outputs."
          end
          log.info("Configuring minion '" .. minion_id .. "' with Salt...")
          local salt = require("salt")
          local client = salt.client({ config_path = "/etc/salt/master" })
          local result = client:target(minion_id):cmd("state.apply")
          if not result.success then
            log.error("Failed to apply Salt state: " .. result.stderr)
            return false, "Salt state.apply failed", result
          end
          log.info("Salt configuration applied successfully.")
          return true, "Server configured.", result
        end
      }
    }
  }
}
`,
	},
	"git-python-pulumi": {
		Name:        "git-python-pulumi",
		Description: "CI/CD Pipeline: Clones a repo, sets up the environment, and deploys with Pulumi.",
		Content: `
-- Task definitions for group: {{.GroupName}}
-- Generated by: sloth-runner new (template: git-python-pulumi)
TaskDefinitions = {
  ["{{.GroupName}}"] = {
    description = "CI/CD Pipeline: Clones, sets up environment, and deploys with Pulumi.",
    create_workdir_before_run = true,
    clean_workdir_after_run = function(r) return r.success end,
    tasks = {
      {
        name = "clone_repository",
        description = "Clones the project repository.",
        command = function(params)
          local workdir = params.workdir
          log.info("Cloning repository into: " .. workdir)
          -- TODO: Replace with your repository URL
          local repo_url = "https://github.com/pulumi/examples.git"
          local result = require("git").repo(workdir):clone(repo_url)
          if not result.success then
            log.error("Failed to clone: " .. result.stderr)
            return false, "Git clone failed", result
          end
          return true, "Repository cloned."
        end
      },
      {
        name = "deploy_stack",
        description = "Installs dependencies and deploys the Pulumi stack from the repository.",
        depends_on = "clone_repository",
        command = function(params)
          local workdir = params.workdir .. "/aws-py-s3-folder" -- Example: subdirectory of the repo
          log.info("Running deployment from: " .. workdir)
          require("python").venv(workdir .. "/.venv"):create()
          local stack = require("pulumi").stack("dev", { workdir = workdir })
          local result = stack:up({ yes = true })
          return result.success, "Deployment finished.", result
        end
      }
    }
  }
}
`,
	},
	"dummy": {
		Name:        "dummy",
		Description: "Generates a dummy task that does nothing.",
		Content: `
-- Task definitions for group: {{.GroupName}}
-- Generated by: sloth-runner new (template: dummy)
TaskDefinitions = {
  ["{{.GroupName}}"] = {
    description = "A dummy task group.",
    tasks = {
      {
        name = "dummy_task",
        description = "A dummy task that does nothing.",
        command = function()
          log.info("Hello from dummy task!")
          return true, "Dummy task executed successfully."
        end
      }
    }
  }
}
`,
	},
}

// --- Fim: Definição de Templates ---

type TemplateData struct {
	Env          string
	IsProduction bool
	Shards       []int
}

// MultiSlogHandler is a slog.Handler that dispatches records to multiple handlers.
type MultiSlogHandler struct {
	Handlers []slog.Handler
}

func (h MultiSlogHandler) Enabled(ctx context.Context, level slog.Level) bool {
	// Return true if any of the handlers are enabled.
	for _, handler := range h.Handlers {
		if handler.Enabled(ctx, level) {
			return true
		}
	}
	return false
}

func (h MultiSlogHandler) Handle(ctx context.Context, r slog.Record) error {
	for _, handler := range h.Handlers {
		if err := handler.Handle(ctx, r); err != nil {
			// In a real-world scenario, you might want to handle this error differently.
			fmt.Fprintf(os.Stderr, "Error from slog handler: %v\n", err)
		}
	}
	return nil
}

func (h MultiSlogHandler) WithAttrs(attrs []slog.Attr) slog.Handler {
	newHandlers := make([]slog.Handler, len(h.Handlers))
	for i, handler := range h.Handlers {
		newHandlers[i] = handler.WithAttrs(attrs)
	}
	return MultiSlogHandler{Handlers: newHandlers}
}

func (h MultiSlogHandler) WithGroup(name string) slog.Handler {
	newHandlers := make([]slog.Handler, len(h.Handlers))
	for i, handler := range h.Handlers {
		newHandlers[i] = handler.WithGroup(name)
	}
	return MultiSlogHandler{Handlers: newHandlers}
}

var (
	configFilePath string
	env            string
	isProduction   bool
	shardsStr      string
	targetTasksStr string
	targetGroup    string
	valuesFilePath string
	dryRun         bool
	returnOutput   bool
	yes            bool
	outputFile     string
	templateName   string
	version        = "dev" // será substituído em tempo de compilação
)

var versionCmd = &cobra.Command{
	Use:   "version",
	Short: "Print the version number of sloth-runner",
	Long:  `All software has versions. This is sloth-runner's`,
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println(version)
	},
}

func loadAndRenderLuaConfig(L *lua.LState, configFilePath, env, shardsStr string, isProduction bool, valuesFilePath string, tr types.TaskRunner) (map[string]types.TaskGroup, error) {
	templateContent, err := ioutil.ReadFile(configFilePath)
	if err != nil {
		return nil, fmt.Errorf("error reading Lua template file %s: %w", configFilePath, err)
	}
	tmpl, err := template.New("lua_config").Parse(string(templateContent))
	if err != nil {
		return nil, fmt.Errorf("error parsing Lua template: %w", err)
	}
	var shards []int
	if shardsStr != "" {
		shardStrings := strings.Split(shardsStr, ",")
		for _, s := range shardStrings {
			shard, err := strconv.Atoi(strings.TrimSpace(s))
			if err != nil {
				return nil, fmt.Errorf("invalid shard number '%s': %w", s, err)
			}
			shards = append(shards, shard)
		}
	}
	data := TemplateData{
		Env:          env,
		IsProduction: isProduction,
		Shards:       shards,
	}
	var renderedLua bytes.Buffer
	if err := tmpl.Execute(&renderedLua, data); err != nil {
		return nil, fmt.Errorf("error executing Lua template: %w", err)
	}
	luainterface.OpenAll(L) // Moved here
	luainterface.OpenImport(L, configFilePath)
	luainterface.OpenParallel(L, tr)
	if valuesFilePath != "" {
		valuesContent, err := ioutil.ReadFile(valuesFilePath)
		if err != nil {
			return nil, fmt.Errorf("error reading values file %s: %w", valuesFilePath, err)
		}
		var goValues map[string]interface{}
		if err := yaml.Unmarshal(valuesContent, &goValues); err != nil {
			return nil, fmt.Errorf("error parsing values YAML from %s: %w", valuesFilePath, err)
		}
		luaValues := luainterface.GoValueToLua(L, goValues)
		L.SetGlobal("values", luaValues)
	}
	taskGroups, err := luainterface.LoadTaskDefinitions(L, renderedLua.String(), configFilePath)
	if err != nil {
		return nil, fmt.Errorf("error loading task definitions: %w", err)
	}
	return taskGroups, nil
}

var rootCmd = &cobra.Command{
	Use:   "sloth-runner",
	Short: "A flexible sloth-runner with Lua scripting capabilities",
	Long: `sloth-runner is a command-line tool that allows you to define and execute
tasks using Lua scripts. It supports pipelines, workflows, dynamic task generation,
and output manipulation.`,
	Run: func(cmd *cobra.Command, args []string) {
		cmd.Help()
	},
}

var templateCmd = &cobra.Command{
	Use:   "template",
	Short: "Manage task templates",
	Long:  "Provides commands to list and manage available task templates.",
}

var templateListCmd = &cobra.Command{
	Use:   "list",
	Short: "Lists all available templates",
	Long:  "Displays a table of all available templates that can be used with the 'new' command.",
	RunE: func(cmd *cobra.Command, args []string) error {
		w := tabwriter.NewWriter(os.Stdout, 0, 0, 3, ' ', 0)
		fmt.Fprintln(w, "TEMPLATE NAME\tDESCRIPTION")
		fmt.Fprintln(w, "-------------\t-----------")

		for _, tmpl := range templateRegistry {
			fmt.Fprintf(w, "%s\t%s\n", tmpl.Name, tmpl.Description)
		}

		return w.Flush()
	},
}

var newCmd = &cobra.Command{
	Use:   "new <group-name>",
	Short: "Generates a new task definition file from a template",
	Long: `The new command creates a boilerplate Lua task definition file.
You can choose from different templates and specify an output file.
Run 'sloth-runner template list' to see all available templates.`,
	Args: cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		groupName := args[0]
		sanitizedGroupName := strings.ReplaceAll(groupName, " ", "-")

		tmpl, ok := templateRegistry[templateName]
		if !ok {
			return fmt.Errorf("invalid template '%s'. Use 'sloth-runner template list' to see the options", templateName)
		}

		data := struct {
			GroupName string
		}{
			GroupName: sanitizedGroupName,
		}
		t, err := template.New("new_task").Parse(tmpl.Content)
		if err != nil {
			return fmt.Errorf("internal error processing template: %w", err)
		}
		var output bytes.Buffer
		if err := t.Execute(&output, data); err != nil {
			return fmt.Errorf("error populating template: %w", err)
		}
		if outputFile != "" {
			if err := ioutil.WriteFile(outputFile, output.Bytes(), 0644); err != nil {
				return fmt.Errorf("failed to write to file %s: %w", outputFile, err)
			}
			fmt.Fprintf(os.Stderr, "✓ Task file '%s' generated successfully for group '%s'.\n", outputFile, sanitizedGroupName)
		} else {
			fmt.Println(output.String())
		}
		return nil
	},
}

var runCmd = &cobra.Command{
	Use:   "run",
	Short: "Executes tasks defined in a Lua template file",
	Long: `The run command executes tasks defined in a Lua template file.
You can specify the file, environment variables, and target specific tasks or groups.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		db, err := ui.InitDB()
		if err != nil {
			// If DB fails, just log it and continue without DB logging.
			slog.Warn("Could not initialize database for logging. Proceeding without history.", "error", err)
		}
		defer func() {
			if db != nil {
				db.Close()
			}
		}()

		var runID int64
		if db != nil {
			group := targetGroup
			if group == "" {
				group = "all" // Default group name if none is specified
			}
			runID, err = ui.CreateRunEntry(db, group)
			if err != nil {
				slog.Warn("Failed to create pipeline run entry in database.", "error", err)
				db = nil // Disable DB logging for this run
			}
		}

		// Setup multi-handler logging
		var handler slog.Handler
		consoleHandler := pterm.NewSlogHandler(&pterm.DefaultLogger)
		if db != nil {
			dbHandler := ui.NewDBHandler(db, runID)
			handler = MultiSlogHandler{Handlers: []slog.Handler{consoleHandler, dbHandler}}
		} else {
			handler = consoleHandler
		}
		slog.SetDefault(slog.New(handler))

		L := lua.NewState()
		defer L.Close()

		var dummyTr types.TaskRunner = nil
		taskGroups, err := loadAndRenderLuaConfig(L, configFilePath, env, shardsStr, isProduction, valuesFilePath, dummyTr)
		if err != nil {
			if db != nil {
				ui.UpdateRunStatus(db, runID, "failed")
			}
			return err
		}
		var targetTasks []string
		if targetTasksStr != "" {
			targetTasks = strings.Split(targetTasksStr, ",")
			for i, task := range targetTasks {
				targetTasks[i] = strings.TrimSpace(task)
			}
		} else {
			var allTasks []string
			if targetGroup != "" {
				if group, ok := taskGroups[targetGroup]; ok {
					for _, task := range group.Tasks {
						allTasks = append(allTasks, task.Name)
					}
				} else {
					if db != nil {
						ui.UpdateRunStatus(db, runID, "failed")
					}
					return fmt.Errorf("task group '%s' not found", targetGroup)
				}
			} else {
				for _, group := range taskGroups {
					for _, task := range group.Tasks {
						allTasks = append(allTasks, task.Name)
					}
				}
			}
			if len(allTasks) == 0 {
				fmt.Println("No tasks found to run.")
				if db != nil {
					ui.UpdateRunStatus(db, runID, "success")
				}
				return nil
			}
			if yes {
				targetTasks = allTasks
			} else {
				prompt := &survey.MultiSelect{
					Message: "Select tasks to run:",
					Options: allTasks,
				}
			survey.AskOne(prompt, &targetTasks)
			}
		}
		if len(targetTasks) == 0 {
			fmt.Println("No tasks selected.")
			if db != nil {
				ui.UpdateRunStatus(db, runID, "success")
			}
			return nil
		}
		tr := taskrunner.NewTaskRunner(L, taskGroups, targetGroup, targetTasks, dryRun)
		luainterface.OpenParallel(L, tr)
		luainterface.OpenSession(L, tr)
		if err := tr.Run(); err != nil {
			if db != nil {
				ui.UpdateRunStatus(db, runID, "failed")
			}
			return fmt.Errorf("error running tasks: %w", err)
		}
		if db != nil {
			ui.UpdateRunStatus(db, runID, "success")
		}

		if returnOutput {
			finalOutputs := make(map[string]interface{})
			for _, taskName := range targetTasks {
				if output, ok := tr.Outputs[taskName]; ok {
					finalOutputs[taskName] = output
				}
			}

			// Merge exported values, overwriting any task outputs with the same key
			for key, value := range tr.Exports {
				finalOutputs[key] = value
			}

			var outputToMarshal interface{}
			if len(targetTasks) == 1 && len(finalOutputs) == 1 {
				if val, ok := finalOutputs[targetTasks[0]]; ok {
					outputToMarshal = val
				} else {
					// If the only task has no output but there are exports, marshal the whole map
					outputToMarshal = finalOutputs
				}
			} else {
				outputToMarshal = finalOutputs
			}
			jsonOutput, err := json.Marshal(outputToMarshal)
			if err != nil {
				return fmt.Errorf("error marshaling final task output to JSON: %w", err)
			}
			fmt.Println(string(jsonOutput))
		}
		return nil
	},
}

var listCmd = &cobra.Command{
	Use:   "list",
	Short: "Lists all available task groups and tasks",
	Long:  `The list command displays all task groups and their respective tasks, along with their descriptions and dependencies.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		L := lua.NewState()
		defer L.Close()
		taskGroups, err := loadAndRenderLuaConfig(L, configFilePath, env, shardsStr, isProduction, valuesFilePath, nil)
		if err != nil {
			return err
		}
		if len(taskGroups) == 0 {
			fmt.Println("No task groups found.")
			return nil
		}
		fmt.Println("Available Task Groups and Tasks:")
		for groupName, group := range taskGroups {
			fmt.Printf("\n  Group: %s (Description: %s)\n", groupName, group.Description)
			if len(group.Tasks) == 0 {
				fmt.Println("    No tasks defined in this group.")
				continue
			}
			for _, task := range group.Tasks {
				fmt.Printf("    - Task: %s\n", task.Name)
				fmt.Printf("      Description: %s\n", task.Description)
				if len(task.DependsOn) > 0 {
					fmt.Printf("      Depends On: %s\n", strings.Join(task.DependsOn, ", "))
				}
				fmt.Printf("      Async: %t\n", task.Async)
			}
		}
		return nil
	},
}

var validateCmd = &cobra.Command{
	Use:   "validate",
	Short: "Validates the syntax and structure of a Lua task file",
	Long:  `The validate command checks a Lua task file for syntax errors and ensures that the TaskDefinitions table is correctly structured.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		L := lua.NewState()
		defer L.Close()
		_, err := loadAndRenderLuaConfig(L, configFilePath, env, shardsStr, isProduction, valuesFilePath, nil)
		if err != nil {
			return err
		}
		fmt.Println("✅ Configuration file is valid.")
		return nil
	},
}

var testCmd = &cobra.Command{
	Use:   "test -w <workflow-file> -f <test-file>",
	Short: "Executes a Lua test file for a task workflow",
	Long: `The test command runs a specified Lua test file against a workflow.
Inside the test file, you can use the 'test' and 'assert' modules to validate task behaviors.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		testFilePath, _ := cmd.Flags().GetString("file")
		workflowFilePath, _ := cmd.Flags().GetString("workflow")

		L := lua.NewState()
		defer L.Close()

		// Load the main workflow to get TaskDefinitions
		luainterface.OpenAll(L)
		taskGroups, err := loadAndRenderLuaConfig(L, workflowFilePath, env, shardsStr, isProduction, valuesFilePath, nil)
		if err != nil {
			return fmt.Errorf("could not load workflow file %s: %w", workflowFilePath, err)
		}

		// Setup the testing environment
		testState := &luainterface.TestState{}
		luainterface.OpenTesting(L, testState, taskGroups)
		luainterface.OverwriteModulesWithMocks(L, testState)

		// Execute the test file
		testFileContent, err := ioutil.ReadFile(testFilePath)
		if err != nil {
			return fmt.Errorf("could not read test file %s: %w", testFilePath, err)
		}
		if err := L.DoString(string(testFileContent)); err != nil {
			return fmt.Errorf("error executing test file %s: %w", testFilePath, err)
		}

		// Print results
		pterm.DefaultSection.Printf("Test Results for %s", testFilePath)
		for _, item := range testState.Results {
			// Simple printing instead of pterm leveled list
			fmt.Println(item.Text)
		}

		pterm.DefaultSection.Println("Summary")
		summaryData := pterm.TableData{
			{"Category", "Count"},
			{"Total Assertions", fmt.Sprintf("%d", testState.Assertions)},
			{"Passed", pterm.Green(fmt.Sprintf("%d", testState.Assertions-testState.Failed))},
			{"Failed", pterm.Red(fmt.Sprintf("%d", testState.Failed))},
		}
		pterm.DefaultTable.WithData(summaryData).Render()

		if testState.Failed > 0 {
			return fmt.Errorf("%d tests failed", testState.Failed)
		}
		return nil
	},
}

var checkCmd = &cobra.Command{
	Use:   "check",
	Short: "Run checks for the environment and configuration",
	Long:  "Provides commands to check for dependencies, configuration, and other environment requirements.",
}

var dependenciesCmd = &cobra.Command{
	Use:   "dependencies",
	Short: "Checks for required external CLI tools",
	Long:  "Verifies that all external command-line tools used by the various modules (e.g., docker, aws, doctl) are installed and available in the system's PATH.",
	RunE: func(cmd *cobra.Command, args []string) error {
		return checkDependencies()
	},
}

func checkDependencies() error {
	dependencies := []string{
		"docker",
		"aws",
		"doctl",
		"az",
		"terraform",
		"git",
		"pulumi",
		"salt",
	}

	pterm.DefaultSection.Println("Checking for required dependencies...")
	var missing []string

	for _, dep := range dependencies {
		_, err := exec.LookPath(dep)
		if err != nil {
			pterm.Error.Printf("✗ %s (missing)\n", dep)
			missing = append(missing, dep)
		} else {
			pterm.Success.Printf("✓ %s (found)\n", dep)
		}
	}

	if len(missing) > 0 {
		pterm.Warning.Printf("The following dependencies are missing: %s\n", strings.Join(missing, ", "))
		pterm.Println("Please install them to ensure all modules work correctly.")
		return fmt.Errorf("missing %d dependencies", len(missing))
	}

	pterm.Success.Println("All dependencies found!")
	return nil
}

func init() {
	rootCmd.AddCommand(versionCmd)
	rootCmd.AddCommand(templateCmd)
	templateCmd.AddCommand(templateListCmd)
	rootCmd.AddCommand(newCmd)
	rootCmd.AddCommand(runCmd)
	rootCmd.AddCommand(listCmd)
	rootCmd.AddCommand(validateCmd)
	rootCmd.AddCommand(testCmd)
	rootCmd.AddCommand(checkCmd)
	rootCmd.AddCommand(replCmd)
	rootCmd.AddCommand(uiCmd)
	checkCmd.AddCommand(dependenciesCmd)

	newCmd.Flags().StringVarP(&outputFile, "output", "o", "", "Output file path (default: stdout)")
	newCmd.Flags().StringVarP(&templateName, "template", "t", "simple", "Template to use. See 'template list' for options.")
	runCmd.Flags().StringVarP(&configFilePath, "file", "f", "examples/basic_pipeline.lua", "Path to the Lua task configuration template file")
	runCmd.Flags().StringVarP(&env, "env", "e", "Development", "Environment for the tasks (e.g., Development, Production)")
	runCmd.Flags().BoolVarP(&isProduction, "prod", "p", false, "Set to true for production environment")
	runCmd.Flags().StringVar(&shardsStr, "shards", "1,2,3", "Comma-separated list of shard numbers (e.g., 1,2,3)")
	runCmd.Flags().StringVarP(&targetTasksStr, "tasks", "t", "", "Comma-separated list of specific tasks to run (e.g., task1,task2)")
	runCmd.Flags().StringVarP(&targetGroup, "group", "g", "", "Run tasks only from a specific task group")
	runCmd.Flags().StringVarP(&valuesFilePath, "values", "v", "", "Path to a YAML file with values to be passed to Lua tasks")
	runCmd.Flags().BoolVarP(&dryRun, "dry-run", "d", false, "Simulate the execution of tasks without actually running them")
	runCmd.Flags().BoolVar(&returnOutput, "return", false, "Return the output of the target tasks as JSON")
	runCmd.Flags().BoolVarP(&yes, "yes", "y", false, "Bypass interactive task selection and run all tasks")
	listCmd.Flags().StringVarP(&configFilePath, "file", "f", "examples/basic_pipeline.lua", "Path to the Lua task configuration template file")
	listCmd.Flags().StringVarP(&env, "env", "e", "Development", "Environment for the tasks (e.g., Development, Production)")
	listCmd.Flags().BoolVarP(&isProduction, "prod", "p", false, "Set to true for production environment")
	listCmd.Flags().StringVar(&shardsStr, "shards", "1,2,3", "Comma-separated list of shard numbers (e.g., 1,2,3)")
	listCmd.Flags().StringVarP(&valuesFilePath, "values", "v", "", "Path to a YAML file with values to be passed to Lua tasks")
	validateCmd.Flags().StringVarP(&configFilePath, "file", "f", "examples/basic_pipeline.lua", "Path to the Lua task configuration template file")
	validateCmd.Flags().StringVarP(&env, "env", "e", "Development", "Environment for the tasks (e.g., Development, Production)")
	validateCmd.Flags().BoolVarP(&isProduction, "prod", "p", false, "Set to true for production environment")
	validateCmd.Flags().StringVar(&shardsStr, "shards", "1,2,3", "Comma-separated list of shard numbers (e.g., 1,2,3)")
	validateCmd.Flags().StringVarP(&valuesFilePath, "values", "v", "", "Path to a YAML file with values to be passed to Lua tasks")
	testCmd.Flags().StringP("file", "f", "", "Path to the Lua test file (required)")
	testCmd.Flags().StringP("workflow", "w", "", "Path to the Lua workflow file to be tested (required)")
	testCmd.MarkFlagRequired("file")
	testCmd.MarkFlagRequired("workflow")
	replCmd.Flags().StringP("file", "f", "", "Path to a Lua workflow file to load into the REPL session")
}

func main() {
	var filePath string
	var valuesPath string
	var yes bool
	var taskName string
	var listTasks bool

	flag.StringVar(&filePath, "file", "", "Path to the Lua script file")
	flag.StringVar(&valuesPath, "values", "", "Path to the YAML values file")
	flag.BoolVar(&yes, "yes", false, "Skip confirmation for destructive actions")
	flag.StringVar(&taskName, "task", "", "Specific task to run (optional)")
	flag.BoolVar(&listTasks, "list", false, "List all tasks in the file")
	flag.Parse()

	if filePath == "" {
		slog.Error("Error: --file is required")
		os.Exit(1)
	}

	// Load task definitions
	taskGroups, err := taskrunner.LoadTaskDefinitions(filePath, valuesPath)
	if err != nil {
		slog.Error("Error loading task definitions", "err", err)
		os.Exit(1)
	}

	if listTasks {
		taskrunner.ListTasks(taskGroups)
		return
	}

	// Determine which task group to run
	var groupToRun types.TaskGroup
	var found bool
	if taskName != "" {
		for _, group := range taskGroups {
			for _, task := range group.Tasks {
				if task.Name == taskName {
					groupToRun = group
					found = true
					break
				}
			}
			if found {
				break
			}
		}
		if !found {
			slog.Error("Error: Task not found", "task", taskName)
			os.Exit(1)
		}
	} else if len(taskGroups) == 1 {
		// If only one group, run it by default
		for _, group := range taskGroups {
			groupToRun = group
			found = true
			break
		}
	} else {
		slog.Error("Error: Multiple task groups found. Please specify one with --task or use --list to see available tasks.")
		os.Exit(1)
	}

	if !found {
		slog.Error("Error: No task group to run.")
		os.Exit(1)
	}

	tr := taskrunner.NewTaskRunner(lua.NewState(), taskGroups, groupToRun.Name, nil, false) // Initialize TaskRunner here

	// Run the task group
	err = tr.Run()
	if err != nil {
		slog.Error("Error running tasks", "err", err)
		os.Exit(1)
	}
}