package main

import (
	"archive/tar"
	"bytes"
	"context"
	// "encoding/json" // Removed
	"fmt"
	"io"
	"io/ioutil"
	"log/slog"
	"net"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
	"syscall"
	"text/tabwriter"
	"text/template"
	"time"

	"github.com/AlecAivazis/survey/v2"
	"github.com/pterm/pterm"
	"github.com/spf13/cobra"
	"gopkg.in/yaml.v2"

	"github.com/chalkan3/sloth-runner/internal/luainterface"
	"github.com/chalkan3/sloth-runner/internal/repl"
	"github.com/chalkan3/sloth-runner/internal/scheduler"
	"github.com/chalkan3/sloth-runner/internal/taskrunner"
	"github.com/chalkan3/sloth-runner/internal/types"
	pb "github.com/chalkan3/sloth-runner/proto"
	"google.golang.org/grpc"
	lua "github.com/yuin/gopher-lua"
)


var testOutputBuffer *bytes.Buffer

func SetTestOutputBuffer(buf *bytes.Buffer) {
	testOutputBuffer = buf
}

var replCmd = &cobra.Command{
	Use:   "repl",
	Short: "Starts an interactive REPL session",
	Long: `The repl command starts an interactive Read-Eval-Print Loop that allows you
	to execute Lua code and interact with all the built-in sloth-runner modules.
	You can optionally load a workflow file to have its context available.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		workflowFile, _ := cmd.Flags().GetString("file")
		repl.Start(workflowFile)
		return nil
	},
}

// --- Start: Centralized Template Definitions ---

// Template defines a structure for a scaffolding template.
type Template struct {
	Name        string
	Description string
	Content     string
}

// templateRegistry is the single source of truth for all available templates.
var templateRegistry = map[string]Template{
	"simple": {
		Name:        "simple",
		Description: "Generates a single group with a 'hello world' task. Ideal for getting started.",
		Content: `
-- Task definitions for group: {{.GroupName}}
-- Generated by: sloth-runner new (template: simple)
TaskDefinitions = {
  ["{{.GroupName}}"] = {
    description = "TODO: Add a description for the {{.GroupName}} task group.",
    tasks = {
      {
        name = "hello_task",
        description = "An example task. Modify or add new tasks here.",
        command = function(params) 
          local workdir = params.workdir
          log.info("Running example task for group {{.GroupName}} in: " .. workdir)
          local stdout, stderr, err = exec.command("echo 'Hello from sloth-runner!'")
          if err then
            log.error("Failed to run example task: " .. stderr)
            return false, "Dummy task failed."
          else
            log.info("Example task completed successfully.")
            print("Command output: " .. stdout)
            return true, "Dummy task executed successfully."
          end
        end
      }
    }
  }
}
`,
	},
	"python": {
		Name:        "python",
		Description: "Creates a pipeline to set up a Python environment, install dependencies, and run a script.",
		Content: `
-- Task definitions for group: {{.GroupName}}
-- Generated by: sloth-runner new (template: python)
TaskDefinitions = {
  ["{{.GroupName}}"] = {
    description = "A pipeline to set up a Python environment and run a script.",
    clean_workdir_after_run = function(last_result)
      if not last_result.success then
        log.error("Task failed. The workdir will be kept for debugging at: " .. last_result.output.workdir)
      end
      return last_result.success
    end,
    tasks = {
      {
        name = "run_python_script",
        description = "Creates a venv, installs dependencies, and runs the main script.",
        command = function(params)
          local workdir = params.workdir
          log.info("Starting Python task in workdir: " .. workdir)
          fs.write(workdir .. "/requirements.txt", "requests")
          fs.write(workdir .. "/main.py", "import requests; print('Hello from Python! Requests version: %s' % requests.__version__)")
          local python = require("python")
          local venv = python.venv(workdir .. "/.venv")
          log.info("Creating virtual environment...")
          venv:create()
          log.info("Installing dependencies...")
          venv:pip("install -r " .. workdir .. "/requirements.txt")
          log.info("Running script...")
          local result = venv:exec(workdir .. "/main.py")
          result.workdir = workdir
          return result.success, "Python task finished.", result
        end
      }
    }
  }
}
`,
	},
	"parallel": {
		Name:        "parallel",
		Description: "Demonstrates how to run multiple tasks concurrently.",
		Content: `
-- Task definitions for group: {{.GroupName}}
-- Generated by: sloth-runner new (template: parallel)
TaskDefinitions = {
  ["{{.GroupName}}"] = {
    description = "An example of running tasks in parallel.",
    tasks = {
      { name = "short_task", command = "sleep 1 && echo 'Short task finished.'" },
      { name = "medium_task", command = "sleep 2 && echo 'Medium task finished.'" },
      { name = "long_task", command = "sleep 3 && echo 'Long task finished.'" },
      {
        name = "run_all_in_parallel",
        description = "Executes the sleep tasks concurrently.",
        command = function()
          log.info("Starting 3 tasks in parallel...")
          local results, err = parallel({
            { name = "short_task" },
            { name = "medium_task" },
            { name = "long_task" }
          })
          if err then
            log.error("Parallel execution encountered an error: " .. err)
            return false, "Parallel execution failed"
          end
          log.info("All parallel tasks have completed.")
          return true, "Parallel execution finished successfully.", results
        end
      }
    }
  }
}
`,
	},
	"python-pulumi": {
		Name:        "python-pulumi",
		Description: "Pipeline to deploy Pulumi infrastructure managed with Python.",
		Content: `
-- Task definitions for group: {{.GroupName}}
-- Generated by: sloth-runner new (template: python-pulumi)
TaskDefinitions = {
  ["{{.GroupName}}"] = {
    description = "A pipeline to deploy Pulumi infrastructure using a Python environment.",
    create_workdir_before_run = true,
    clean_workdir_after_run = function(last_result) return last_result.success end,
    tasks = {
      {
        name = "setup_and_deploy",
        description = "Sets up the Python environment and runs 'pulumi up'.",
        command = function(params)
          local workdir = params.workdir
          log.info("Starting Python+Pulumi pipeline in: " .. workdir)
          fs.write(workdir .. "/requirements.txt", "pulumi")
          fs.write(workdir .. "/__main__.py", "import pulumi\npulumi.export('urn', 'urn:pulumi:dev::{{.GroupName}}::pulumi:pulumi:Stack::{{.GroupName}}-dev')")
          fs.write(workdir .. "/Pulumi.yaml", "name: {{.GroupName}}\nruntime: python\ndescription: A minimal Python Pulumi program")
          local python = require("python")
          local venv = python.venv(workdir .. "/.venv")
          log.info("Creating venv...")
          venv:create()
          log.info("Installing Python dependencies...")
          venv:pip("install -r " .. workdir .. "/requirements.txt")
          local pulumi = require("pulumi")
          local stack = pulumi.stack("dev", { workdir = workdir })
          log.info("Running 'pulumi up'...")
          local up_result = stack:up({ yes = true })
          if not up_result.success then
            log.error("'pulumi up' failed: " .. up_result.stderr)
            return false, "Pulumi up failed", up_result
          end
          log.info("Pulumi up completed successfully.")
          local outputs = stack:outputs()
          return true, "Python+Pulumi pipeline finished.", outputs
        end
      }
    }
  }
}
`,
	},
	"python-pulumi-salt": {
		Name:        "python-pulumi-salt",
		Description: "Provisions infrastructure with Pulumi and configures it using SaltStack.",
		Content: `
-- Task definitions for group: {{.GroupName}}
-- Generated by: sloth-runner new (template: python-pulumi-salt)
TaskDefinitions = {
  ["{{.GroupName}}"] = {
    description = "Pipeline: Pulumi creates the infra, Salt configures it.",
    create_workdir_before_run = true,
    tasks = {
      {
        name = "deploy_infra",
        description = "Uses Python and Pulumi to create the infrastructure.",
        command = function(params)
          local workdir = params.workdir
          log.info("Starting infra deployment in: " .. workdir)
          fs.write(workdir .. "/requirements.txt", "pulumi")
          fs.write(workdir .. "/__main__.py", "import pulumi\npulumi.export('minion_id', 'test-minion-123')")
          fs.write(workdir .. "/Pulumi.yaml", "name: {{.GroupName}}\nruntime: python")
          require("python").venv(workdir .. "/.venv"):create()
          local stack = require("pulumi").stack("dev", { workdir = workdir })
          local up_result = stack:up({ yes = true })
          if not up_result.success then return false, "Pulumi up failed", up_result end
          return true, "Infrastructure created.", stack:outputs()
        end
      },
      {
        name = "configure_server",
        description = "Uses Salt to apply a highstate on the created minion.",
        depends_on = "deploy_infra",
        command = function(params, inputs)
          local minion_id = inputs.deploy_infra.minion_id
          if not minion_id then
            return false, "Minion ID not found in Pulumi outputs."
          end
          log.info("Configuring minion '" .. minion_id .. "' with Salt...")
          local salt = require("salt")
          local client = salt.client({ config_path = "/etc/salt/master" })
          local result = client:target(minion_id):cmd("state.apply")
          if not result.success then
            log.error("Failed to apply Salt state: " .. result.stderr)
            return false, "Salt state.apply failed", result
          end
          log.info("Salt configuration applied successfully.")
          return true, "Server configured.", result
        end
      }
    }
  }
}
`,
	},
	"git-python-pulumi": {
		Name:        "git-python-pulumi",
		Description: "CI/CD Pipeline: Clones a repo, sets up the environment, and deploys with Pulumi.",
		Content: `
-- Task definitions for group: {{.GroupName}}
-- Generated by: sloth-runner new (template: git-python-pulumi)
TaskDefinitions = {
  ["{{.GroupName}}"] = {
    description = "CI/CD Pipeline: Clones, sets up environment, and deploys with Pulumi.",
    create_workdir_before_run = true,
    clean_workdir_after_run = function(r) return r.success end,
    tasks = {
      {
        name = "clone_repository",
        description = "Clones the project repository.",
        command = function(params)
          local workdir = params.workdir
          log.info("Cloning repository into: " .. workdir)
          -- TODO: Replace with your repository URL
          local repo_url = "https://github.com/pulumi/examples.git"
          local result = require("git").repo(workdir):clone(repo_url)
          if not result.success then
            log.error("Failed to clone: " .. result.stderr)
            return false, "Git clone failed", result
          end
          return true, "Repository cloned."
        end
      },
      {
        name = "deploy_stack",
        description = "Installs dependencies and deploys the Pulumi stack from the repository.",
        depends_on = "clone_repository",
        command = function(params)
          local workdir = params.workdir .. "/aws-py-s3-folder" -- Example: subdirectory of the repo
          log.info("Running deployment from: " .. workdir)
          require("python").venv(workdir .. "/.venv"):create()
          local stack = require("pulumi").stack("dev", { workdir = workdir })
          local result = stack:up({ yes = true })
          return result.success, "Deployment finished.", result
        end
      }
    }
  }
}
`,
	},
	"dummy": {
		Name:        "dummy",
		Description: "Generates a dummy task that does nothing.",
		Content: `
-- Task definitions for group: {{.GroupName}}
-- Generated by: sloth-runner new (template: dummy)
TaskDefinitions = {
  ["{{.GroupName}}"] = {
    description = "A dummy task group.",
    tasks = {
      {
        name = "dummy_task",
        description = "A dummy task that does nothing.",
        command = function()
          log.info("Hello from dummy task!")
          return true, "Dummy task executed successfully."
        end
      }
    }
  }
}
`,
	},
}

// --- Fim: Definição de Templates ---

type TemplateData struct {
	Env          string
	IsProduction bool
	Shards       []int
}


var (
	configFilePath string
	env            string
	isProduction   bool
	shardsStr      string
	targetTasksStr string
	targetGroup    string
	valuesFilePath string
	dryRun         bool
	returnOutput   bool
	yes            bool
	outputFile     string
	templateName   string
	schedulerConfigPath string
	runAsScheduler bool
	setFlags       []string // New: To store key-value pairs for template data
	interactive    bool     // New: To enable interactive mode for task execution
	version        = "dev" // será substituído em tempo de compilação
)

var schedulerPIDFile string

// Mockable functions for testing
var execCommand = exec.Command
var osFindProcess = os.FindProcess
var processSignal = func(p *os.Process, sig os.Signal) error {
	return p.Signal(sig)
}

// SetExecCommand allows tests to override the exec.Command function
func SetExecCommand(f func(name string, arg ...string) *exec.Cmd) {
	execCommand = f
}

// SetOSFindProcess allows tests to override the os.FindProcess function
func SetOSFindProcess(f func(pid int) (*os.Process, error)) {
	osFindProcess = f
}

// SetProcessSignal allows tests to override the process.Signal function
func SetProcessSignal(f func(p *os.Process, sig os.Signal) error) {
	processSignal = f
}

var versionCmd = &cobra.Command{
	Use:   "version",
	Short: "Print the version number of sloth-runner",
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println(version)
	},
}

func loadAndRenderLuaConfig(L *lua.LState, configFilePath, env, shardsStr string, isProduction bool, valuesFilePath string, tr types.TaskRunner) (map[string]types.TaskGroup, string, error) {
	templateContent, err := ioutil.ReadFile(configFilePath)
	if err != nil {
		return nil, "", fmt.Errorf("error reading Lua template file %s: %w", configFilePath, err)
	}
	tmpl, err := template.New("lua_config").Parse(string(templateContent))
	if err != nil {
		return nil, "", fmt.Errorf("error parsing Lua template: %w", err)
	}
	var shards []int
	if shardsStr != "" {
		shardStrings := strings.Split(shardsStr, ",")
		for _, s := range shardStrings {
			shard, err := strconv.Atoi(strings.TrimSpace(s))
			if err != nil {
				return nil, "", fmt.Errorf("invalid shard number '%s': %w", s, err)
			}
			shards = append(shards, shard)
		}
	}
	data := TemplateData{
		Env:          env,
		IsProduction: isProduction,
		Shards:       shards,
	}
	var renderedLua bytes.Buffer
	if err := tmpl.Execute(&renderedLua, data); err != nil {
		return nil, "", fmt.Errorf("error executing Lua template: %w", err)
	}

	// Add plugins to Lua path
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return nil, "", fmt.Errorf("failed to get user home directory: %w", err)
	}
	pluginsDir := filepath.Join(homeDir, ".sloth-runner", "plugins")

	if _, err := os.Stat(pluginsDir); !os.IsNotExist(err) {
		pluginDirs, err := ioutil.ReadDir(pluginsDir)
		if err != nil {
			return nil, "", fmt.Errorf("failed to read plugins directory: %w", err)
		}

		packagePath := L.GetGlobal("package").(*lua.LTable).RawGetString("path").String()
		for _, p := range pluginDirs {
			if p.IsDir() {
				pluginPath := filepath.Join(pluginsDir, p.Name(), "?.lua")
				packagePath = pluginPath + ";" + packagePath
			}
		}
		L.GetGlobal("package").(*lua.LTable).RawSetString("path", lua.LString(packagePath))
	}

	luainterface.OpenAll(L) // Moved here
	luainterface.OpenImport(L, configFilePath)
	luainterface.OpenParallel(L, tr)
	if valuesFilePath != "" {
		valuesContent, err := ioutil.ReadFile(valuesFilePath)
		if err != nil {
			return nil, "", fmt.Errorf("error reading values file %s: %w", valuesFilePath, err)
		}

		// Process values.yaml as a Go template
	tmpl, err := template.New("values").Parse(string(valuesContent))
		if err != nil {
			return nil, "", fmt.Errorf("error parsing values template: %w", err)
		}

		// Create a map of environment variables to pass to the template
	envMap := make(map[string]string)
		for _, e := range os.Environ() {
			pair := strings.SplitN(e, "=", 2)
			envMap[pair[0]] = pair[1]
		}

		var renderedValues bytes.Buffer
		if err := tmpl.Execute(&renderedValues, map[string]interface{}{"Env": envMap}); err != nil {
			return nil, "", fmt.Errorf("error executing values template: %w", err)
		}

		var goValues map[string]interface{}
		if err := yaml.Unmarshal(renderedValues.Bytes(), &goValues); err != nil {
			return nil, "", fmt.Errorf("error parsing values YAML from %s: %w", valuesFilePath, err)
		}
		luaValues := luainterface.GoValueToLua(L, goValues)
		L.SetGlobal("values", luaValues)
	}
	taskGroups, err := luainterface.LoadTaskDefinitions(L, renderedLua.String(), configFilePath)
	if err != nil {
		return nil, "", fmt.Errorf("error loading task definitions: %w", err)
	}
	return taskGroups, renderedLua.String(), nil
}

var schedulerCmd = &cobra.Command{
	Use:   "scheduler",
	Short: "Manages the background task scheduler",
	Long:  `The scheduler command provides subcommands to enable and disable the sloth-runner background task scheduler.`, 
	Run: func(cmd *cobra.Command, args []string) {
		cmd.Help()
	},
}

var pluginCmd = &cobra.Command{
	Use:   "plugin",
	Short: "Manages plugins",
	Long:  `The plugin command provides subcommands to install, list, and uninstall plugins.`, 
	Run: func(cmd *cobra.Command, args []string) {
		cmd.Help()
	},
}

var installCmd = &cobra.Command{
	Use:   "install <url>",
	Short: "Installs a plugin from a git repository",
	Long:  `The install command clones a git repository from the given URL into the plugins directory.`, 
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		pluginURL := args[0]

		homeDir, err := os.UserHomeDir()
		if err != nil {
			return fmt.Errorf("failed to get user home directory: %w", err)
		}
		pluginsDir := filepath.Join(homeDir, ".sloth-runner", "plugins")
		if err := os.MkdirAll(pluginsDir, 0755); err != nil {
			return fmt.Errorf("failed to create plugins directory: %w", err)
		}

		repoName := filepath.Base(pluginURL)
		pluginName := strings.TrimSuffix(repoName, ".git")
		pluginInstallPath := filepath.Join(pluginsDir, pluginName)

		if _, err := os.Stat(pluginInstallPath); !os.IsNotExist(err) {
			return fmt.Errorf("plugin '%s' is already installed", pluginName)
		}

		cmd.Printf("Installing plugin '%s' from %s...\n", pluginName, pluginURL)
		gitCmd := exec.Command("git", "clone", pluginURL, pluginInstallPath)
		gitCmd.Stdout = cmd.OutOrStdout()
		gitCmd.Stderr = cmd.ErrOrStderr()
		if err := gitCmd.Run(); err != nil {
			return fmt.Errorf("failed to clone plugin repository: %w", err)
		}
		cmd.Printf("Plugin '%s' installed successfully.\n", pluginName)

		return nil
	},
}

var listPluginsCmd = &cobra.Command{
	Use:   "list",
	Short: "Lists all installed plugins",
	Long:  `The list command shows all plugins that are currently installed in the plugins directory.`, 
	RunE: func(cmd *cobra.Command, args []string) error {
		homeDir, err := os.UserHomeDir()
		if err != nil {
			return fmt.Errorf("failed to get user home directory: %w", err)
		}
		pluginsDir := filepath.Join(homeDir, ".sloth-runner", "plugins")

		files, err := ioutil.ReadDir(pluginsDir)
		if err != nil {
			if os.IsNotExist(err) {
				cmd.Println("No plugins installed.")
				return nil
			}
			return fmt.Errorf("failed to read plugins directory: %w", err)
		}

		cmd.Println("Installed plugins:")
		for _, f := range files {
			if f.IsDir() {
				cmd.Println("- " + f.Name())
			}
		}

		return nil
	},
}

var uninstallPluginCmd = &cobra.Command{
	Use:   "uninstall <plugin-name>",
	Short: "Uninstalls a plugin",
	Long:  `The uninstall command removes a plugin from the plugins directory.`, 
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		pluginName := args[0]

		homeDir, err := os.UserHomeDir()
		if err != nil {
			return fmt.Errorf("failed to get user home directory: %w", err)
		}
		pluginPath := filepath.Join(homeDir, ".sloth-runner", "plugins", pluginName)

		if _, err := os.Stat(pluginPath); os.IsNotExist(err) {
			return fmt.Errorf("plugin '%s' is not installed", pluginName)
		}

		cmd.Printf("Uninstalling plugin '%s'...\n", pluginName)
		if err := os.RemoveAll(pluginPath); err != nil {
			return fmt.Errorf("failed to remove plugin directory: %w", err)
		}
		cmd.Printf("Plugin '%s' uninstalled successfully.\n", pluginName)

		return nil
	},
}

var enableCmd = &cobra.Command{
	Use:   "enable",
	Short: "Starts the sloth-runner scheduler in the background",
	Long: `The enable command starts the sloth-runner scheduler as a persistent background process.
It will monitor and execute tasks defined in the scheduler configuration file.`, 
	RunE: func(cmd *cobra.Command, args []string) error {
		pidFile := filepath.Join(filepath.Dir(schedulerConfigPath), "sloth-runner-scheduler.pid") // Local pidFile
		// Check if scheduler is already running
		if _, err := os.Stat(pidFile); err == nil {
			pidBytes, err := ioutil.ReadFile(pidFile)
			if err == nil {
				pid, _ := strconv.Atoi(string(pidBytes))
				if process, err := os.FindProcess(pid); err == nil {
					if err := processSignal(process, syscall.Signal(0)); err == nil {
						cmd.Printf("Scheduler is already running with PID %d.\n", pid)
						return nil
					}
				}
			}
			// PID file exists but process is not running, clean up
			os.Remove(pidFile)
		}

		cmd.Println("Starting sloth-runner scheduler in background...")

		// Re-execute the current binary in background with a special flag
		command := execCommand(os.Args[0], "--run-as-scheduler", "--scheduler-config", schedulerConfigPath)
		setSysProcAttr(command)
		command.Stdout = os.Stdout // For debugging, redirect to /dev/null in production
		command.Stderr = os.Stderr // For debugging, redirect to /dev/null in production

		if err := command.Start(); err != nil {
			return fmt.Errorf("failed to start scheduler process: %w", err)
		}

		// Write PID to file
		if err := ioutil.WriteFile(schedulerPIDFile, []byte(strconv.Itoa(command.Process.Pid)), 0644); err != nil {
			return fmt.Errorf("failed to write PID file: %w", err)
		}

		cmd.Printf("Scheduler started with PID %d. Logs will be redirected to stdout/stderr of the background process.\n", command.Process.Pid)
		cmd.Printf("To stop the scheduler, run: sloth-runner scheduler disable\n")
		return nil
	},
}

var disableCmd = &cobra.Command{
	Use:   "disable",
	Short: "Stops the running sloth-runner scheduler",
	Long:  `The disable command stops the background sloth-runner scheduler process.`, 
	RunE: func(cmd *cobra.Command, args []string) error {
		pidFile := filepath.Join(filepath.Dir(schedulerConfigPath), "sloth-runner-scheduler.pid") // Local pidFile
		pidBytes, err := ioutil.ReadFile(pidFile)
		if err != nil {
			return fmt.Errorf("scheduler PID file not found or readable. Is the scheduler running? %w", err)
		}

		pid, err := strconv.Atoi(string(pidBytes))
		if err != nil {
			return fmt.Errorf("invalid PID in file %s: %w", pidFile, err)
		}

		process, err := osFindProcess(pid)
		if err != nil {
			return fmt.Errorf("failed to find process with PID %d: %w", pid, err)
		}

		// Send terminate signal
		if err := processSignal(process, syscall.SIGTERM); err != nil {
			return fmt.Errorf("failed to terminate scheduler process with PID %d: %w", pid, err)
		}

		// Wait a bit for the process to terminate
		time.Sleep(1 * time.Second)

		// Check if process is still running
		if err := processSignal(process, syscall.Signal(0)); err == nil {
			return fmt.Errorf("scheduler process with PID %d did not terminate after SIGTERM", pid)
		}

		// Remove PID file
		if err := os.Remove(pidFile); err != nil {
			cmd.Printf("Warning: Failed to remove PID file %s: %v\n", pidFile, err)
		}

		cmd.Printf("Scheduler with PID %d stopped successfully.\n", pid)
		return nil
	},
}



var listScheduledCmd = &cobra.Command{
	Use:   "list",
	Short: "Lists all configured scheduled tasks",
	Long:  `The list command displays all tasks defined in the scheduler configuration file.`, 
	RunE: func(cmd *cobra.Command, args []string) error {
		cmd.SetOut(cmd.OutOrStdout()) // Add this line
		cmd.SetErr(cmd.ErrOrStderr()) // Add this line
		pterm.DefaultLogger.Writer = cmd.OutOrStdout()
		pterm.SetDefaultOutput(cmd.OutOrStdout())
		defer func() { pterm.DefaultLogger.Writer = os.Stdout }()
		defer func() { pterm.SetDefaultOutput(os.Stdout) }()
		sched := scheduler.NewScheduler(schedulerConfigPath)
		if err := sched.LoadConfig(); err != nil {
			return fmt.Errorf("failed to load scheduler config: %w", err)
		}

		if sched.Config() == nil || len(sched.Config().ScheduledTasks) == 0 {
			fmt.Println("No scheduled tasks configured.")
			return nil
		}

		pterm.DefaultSection.Println("Configured Scheduled Tasks")
		tableData := pterm.TableData{
			{"NAME", "SCHEDULE", "FILE", "GROUP", "TASK"},
		}
		for _, task := range sched.Config().ScheduledTasks {
			tableData = append(tableData, []string{task.Name, task.Schedule, task.TaskFile, task.TaskGroup, task.TaskName})
		}
		pterm.DefaultTable.WithHasHeader().WithData(tableData).Render()
		return nil
	},
}

var deleteScheduledCmd = &cobra.Command{
	Use:   "delete <task-name>",
	Short: "Deletes a scheduled task from the configuration",
	Long:  `The delete command removes a specific scheduled task from the scheduler configuration file.`, 
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		cmd.SetOut(cmd.OutOrStdout()) // Add this line
		cmd.SetErr(cmd.ErrOrStderr()) // Add this line
		// pterm.DefaultLogger.Writer = cmd.OutOrStdout() // Reverted
		// defer func() { pterm.DefaultLogger.Writer = os.Stdout }() // Reverted
		taskName := args[0]

		sched := scheduler.NewScheduler(schedulerConfigPath)
		if err := sched.LoadConfig(); err != nil {
			return fmt.Errorf("failed to load scheduler config: %w", err)
		}

		if sched.Config() == nil || len(sched.Config().ScheduledTasks) == 0 {
			return fmt.Errorf("no scheduled tasks configured to delete")
		}

		var updatedTasks []scheduler.ScheduledTask
		found := false
		for _, task := range sched.Config().ScheduledTasks {
			if task.Name == taskName {
				found = true
				cmd.Printf("Deleting scheduled task '%s'...\n", taskName)
			} else {
				updatedTasks = append(updatedTasks, task)
			}
		}

		if !found {
			return fmt.Errorf("scheduled task '%s' not found", taskName)
		}

		sched.SetConfig(&scheduler.SchedulerConfig{ScheduledTasks: updatedTasks})
		if err := sched.SaveConfig(); err != nil {
			return fmt.Errorf("failed to save updated scheduler config: %w", err)
		}

		cmd.Printf("Scheduled task '%s' deleted successfully. Please restart the scheduler for changes to take effect.\n", taskName)
		return nil
	},
}

var rootCmd = &cobra.Command{
	Use:   "sloth-runner",
	Short: "A flexible sloth-runner with Lua scripting capabilities",
	Long: `sloth-runner is a command-line tool that allows you to define and execute
	tasks using Lua scripts. It supports pipelines, workflows, dynamic task generation,
	and output manipulation.`, 
	Run: func(cmd *cobra.Command, args []string) {
		cmd.Help()
	},
}

var templateCmd = &cobra.Command{
	Use:   "template",
	Short: "Manage task templates",
	Long:  "Provides commands to list and manage available task templates.",
}

var templateListCmd = &cobra.Command{
	Use:   "list",
	Short: "Lists all available templates",
	Long:  "Displays a table of all available templates that can be used with the 'new' command.", 
	RunE: func(cmd *cobra.Command, args []string) error {
		pterm.DefaultLogger.Writer = cmd.OutOrStdout()
		defer func() { pterm.DefaultLogger.Writer = os.Stdout }()
		w := tabwriter.NewWriter(os.Stdout, 0, 0, 3, ' ', 0)
		fmt.Fprintln(w, "TEMPLATE NAME\tDESCRIPTION")
		fmt.Fprintln(w, "-------------\t-----------")

		for _, tmpl := range templateRegistry {
			fmt.Fprintf(w, "%s\t%s\n", tmpl.Name, tmpl.Description)
		}

		return w.Flush()
	},
}

var newCmd = &cobra.Command{
	Use:   "new <group-name>",
	Short: "Generates a new task definition file from a template",
	Long: `The new command creates a boilerplate Lua task definition file.
	You can choose from different templates and specify an output file.
	Run 'sloth-runner template list' to see all available templates.`, 
	Args: cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		pterm.DefaultLogger.Writer = cmd.OutOrStdout()
		defer func() { pterm.DefaultLogger.Writer = os.Stdout }()
		groupName := args[0]
		sanitizedGroupName := strings.ReplaceAll(groupName, " ", "-")

		tmpl, ok := templateRegistry[templateName]
		if !ok {
			return fmt.Errorf("invalid template '%s'. Use 'sloth-runner template list' to see the options", templateName)
		}

		templateData := make(map[string]interface{})
		templateData["GroupName"] = sanitizedGroupName

		for _, set := range setFlags {
			parts := strings.SplitN(set, "=", 2)
			if len(parts) != 2 {
				return fmt.Errorf("invalid --set flag format: %s. Expected key=value", set)
			}
			templateData[parts[0]] = parts[1]
		}

		t, err := template.New("new_task").Parse(tmpl.Content)
		if err != nil {
			return fmt.Errorf("internal error processing template: %w", err)
		}
		var output bytes.Buffer
		if err := t.Execute(&output, templateData); err != nil {
			return fmt.Errorf("error populating template: %w", err)
		}
		if outputFile != "" {
			if err := ioutil.WriteFile(outputFile, output.Bytes(), 0644); err != nil {
				return fmt.Errorf("failed to write to file %s: %w", outputFile, err)
			}
			fmt.Fprintf(os.Stderr, "✓ Task file '%s' generated successfully for group '%s'.\n", outputFile, sanitizedGroupName)
		} else {
			fmt.Println(output.String())
		}
		return nil
	},
}



func SetSurveyAsker(asker taskrunner.SurveyAsker) {
	surveyAsker = asker
}

var runCmd = &cobra.Command{
	Use:   "run",
	Short: "Executes tasks defined in a Lua template file",
	Long: `The run command executes tasks defined in a Lua template file.
	You can specify the file, environment variables, and target specific tasks or groups.`, 
	RunE: func(cmd *cobra.Command, args []string) error {
		cmd.SetOut(cmd.OutOrStdout()) // Add this line
		cmd.SetErr(cmd.ErrOrStderr()) // Add this line
		pterm.DefaultLogger.Writer = cmd.OutOrStdout()
		pterm.SetDefaultOutput(cmd.OutOrStdout()) // Add this line
		defer func() { pterm.DefaultLogger.Writer = os.Stdout }()
		defer func() { pterm.SetDefaultOutput(os.Stdout) }() // Add this line
		L := lua.NewState()
		defer L.Close()

		var dummyTr types.TaskRunner = nil
		taskGroups, luaScript, err := loadAndRenderLuaConfig(L, configFilePath, env, shardsStr, isProduction, valuesFilePath, dummyTr)
		if err != nil {
			return err
		}
		var targetTasks []string
		if targetTasksStr != "" {
			targetTasks = strings.Split(targetTasksStr, ",")
			for i, task := range targetTasks {
				targetTasks[i] = strings.TrimSpace(task)
			}
		} else {
			var allTasks []string
			if targetGroup != "" {
				if group, ok := taskGroups[targetGroup]; ok {
					for _, task := range group.Tasks {
						allTasks = append(allTasks, task.Name)
					}
				} else {
					return fmt.Errorf("task group '%s' not found", targetGroup)
				}
			} else {
				for _, group := range taskGroups {
					for _, task := range group.Tasks {
						allTasks = append(allTasks, task.Name)
					}
				}
			}
			if len(allTasks) == 0 {
				fmt.Println("No tasks found to run.")
				return nil
			}
			if yes {
				targetTasks = allTasks
			} else {
				prompt := &survey.MultiSelect{
					Message: "Select tasks to run:",
					Options: allTasks,
				}
			survey.AskOne(prompt, &targetTasks)
			}
		}
		if len(targetTasks) == 0 {
			fmt.Println("No tasks selected.")
			return nil
		}
		tr := taskrunner.NewTaskRunner(L, taskGroups, targetGroup, targetTasks, dryRun, interactive, surveyAsker, luaScript)
		luainterface.OpenParallel(L, tr)
		luainterface.OpenSession(L, tr)
		if err := tr.Run(); err != nil {
			return err // Directly return the error
		}
		return nil
	},
}

var listCmd = &cobra.Command{
	Use:   "list",
	Short: "Lists all available task groups and tasks",
	Long:  `The list command displays all task groups and their respective tasks, along with their descriptions and dependencies.`, 
	RunE: func(cmd *cobra.Command, args []string) error {
		L := lua.NewState()
		defer L.Close()
		taskGroups, _, err := loadAndRenderLuaConfig(L, configFilePath, env, shardsStr, isProduction, valuesFilePath, nil)
		if err != nil {
			return err
		}
		if len(taskGroups) == 0 {
			fmt.Println("No task groups found.")
			return nil
		}
		fmt.Println("Available Task Groups and Tasks:")
		for groupName, group := range taskGroups {
			fmt.Printf("\n  Group: %s (Description: %s)\n", groupName, group.Description)
			if len(group.Tasks) == 0 {
				fmt.Println("    No tasks defined in this group.")
				continue
			}
			for _, task := range group.Tasks {
				fmt.Printf("    - Task: %s\n", task.Name)
				fmt.Printf("      Description: %s\n", task.Description)
				if len(task.DependsOn) > 0 {
					fmt.Printf("      Depends On: %s\n", strings.Join(task.DependsOn, ", "))
				}
				fmt.Printf("      Async: %t\n", task.Async)
			}
		}
		return nil
	},
}

var validateCmd = &cobra.Command{
	Use:   "validate",
	Short: "Validates the syntax and structure of a Lua task file",
	Long:  `The validate command checks a Lua task file for syntax errors and ensures that the TaskDefinitions table is correctly structured.`, 
	RunE: func(cmd *cobra.Command, args []string) error {
		L := lua.NewState()
		defer L.Close()
		_, _, err := loadAndRenderLuaConfig(L, configFilePath, env, shardsStr, isProduction, valuesFilePath, nil)
		if err != nil {
			return err
		}
		fmt.Println("✅ Configuration file is valid.")
		return nil
	},
}

var testCmd = &cobra.Command{
	Use:   "test -w <workflow-file> -f <test-file>",
	Short: "Executes a Lua test file for a task workflow",
	Long: `The test command runs a specified Lua test file against a workflow.
	Inside the test file, you can use the 'test' and 'assert' modules to validate task behaviors.`, 
	RunE: func(cmd *cobra.Command, args []string) error {
		pterm.DefaultLogger.Writer = cmd.OutOrStdout()
		defer func() { pterm.DefaultLogger.Writer = os.Stdout }()
		testFilePath, _ := cmd.Flags().GetString("file")
		workflowFilePath, _ := cmd.Flags().GetString("workflow")

		L := lua.NewState()
		defer L.Close()

		// Load the main workflow to get TaskDefinitions
		luainterface.OpenAll(L)
		taskGroups, _, err := loadAndRenderLuaConfig(L, workflowFilePath, env, shardsStr, isProduction, valuesFilePath, nil)
		if err != nil {
			return fmt.Errorf("could not load workflow file %s: %w", workflowFilePath, err)
		}

		// Setup the testing environment
		testState := &luainterface.TestState{}
		luainterface.OpenTesting(L, testState, taskGroups)
		luainterface.OverwriteModulesWithMocks(L, testState)

		// Execute the test file
		testFileContent, err := ioutil.ReadFile(testFilePath)
		if err != nil {
			return fmt.Errorf("could not read test file %s: %w", testFilePath, err)
		}
		if err := L.DoString(string(testFileContent)); err != nil {
			return fmt.Errorf("error executing test file %s: %w", testFilePath, err)
		}

		// Print results
		pterm.DefaultSection.Printf("Test Results for %s", testFilePath)
		for _, item := range testState.Results {
			// Simple printing instead of pterm leveled list
			fmt.Println(item.Text)
		}

		pterm.DefaultSection.Println("Summary")
		summaryData := pterm.TableData{
			{"Category", "Count"},
			{"Total Assertions", fmt.Sprintf("%d", testState.Assertions)},
			{"Passed", pterm.Green(fmt.Sprintf("%d", testState.Assertions-testState.Failed))},
			{"Failed", pterm.Red(fmt.Sprintf("%d", testState.Failed))},
		}
		pterm.DefaultTable.WithData(summaryData).Render()

		if testState.Failed > 0 {
			return fmt.Errorf("%d tests failed", testState.Failed)
		}
		return nil
	},
}

var checkCmd = &cobra.Command{
	Use:   "check",
	Short: "Run checks for the environment and configuration",
	Long:  "Provides commands to check for dependencies, configuration, and other environment requirements.", 
}

var dependenciesCmd = &cobra.Command{
	Use:   "dependencies",
	Short: "Checks for required external CLI tools",
	Long:  "Verifies that all external command-line tools used by the various modules (e.g., docker, aws, doctl) are installed and available in the system's PATH.", 
	RunE: func(cmd *cobra.Command, args []string) error {
		return checkDependencies()
	},
}

func checkDependencies() error {
	dependencies := []string{
		"docker",
		"aws",
		"doctl",
		"az",
		"terraform",
		"git",
		"pulumi",
		"salt",
	}

	pterm.DefaultSection.Println("Checking for required dependencies...")
	var missing []string

	for _, dep := range dependencies {
		_, err := exec.LookPath(dep)
		if err != nil {
			pterm.Error.Printf("✗ %s (missing)\n", dep)
			missing = append(missing, dep)
		} else {
			pterm.Success.Printf("✓ %s (found)\n", dep)
		}
	}

	if len(missing) > 0 {
		pterm.Warning.Printf("The following dependencies are missing: %s\n", strings.Join(missing, ", "))
		pterm.Println("Please install them to ensure all modules work correctly.")
		return fmt.Errorf("missing %d dependencies", len(missing))
	}

	pterm.Success.Println("All dependencies found!")
	return nil
}

var agentCmd = &cobra.Command{
	Use:   "agent",
	Short: "Manages sloth-runner agents",
	Long:  `The agent command provides subcommands to start, stop, list, and manage sloth-runner agents.`, 
	Run: func(cmd *cobra.Command, args []string) {
		cmd.Help()
	},
}

var agentStartCmd = &cobra.Command{
	Use:   "start",
	Short: "Starts the sloth-runner in agent mode",
	Long:  `The agent start command starts the sloth-runner as a background agent that can execute tasks remotely.`, 
	RunE: func(cmd *cobra.Command, args []string) error {
		port, _ := cmd.Flags().GetInt("port")
		masterAddr, _ := cmd.Flags().GetString("master")
		agentName, _ := cmd.Flags().GetString("name")
		daemon, _ := cmd.Flags().GetBool("daemon")

		homeDir, err := os.UserHomeDir()
		if err != nil {
			return fmt.Errorf("failed to get user home directory: %w", err)
		}

		if daemon {
			pidFile := filepath.Join(homeDir, ".projects", "task-runner", fmt.Sprintf("sloth-runner-agent-%s.pid", agentName))
			if _, err := os.Stat(pidFile); err == nil {
				pidBytes, err := ioutil.ReadFile(pidFile)
				if err == nil {
					pid, _ := strconv.Atoi(string(pidBytes))
					if process, err := os.FindProcess(pid); err == nil {
						if err := processSignal(process, syscall.Signal(0)); err == nil {
							cmd.Printf("Agent %s is already running with PID %d.\n", agentName, pid)
							return nil
						}
					}
				}
				os.Remove(pidFile)
			}

			command := execCommand(os.Args[0], "agent", "start", "--port", strconv.Itoa(port), "--name", agentName, "--master", masterAddr)
			setSysProcAttr(command)
			stdoutFile, err := os.OpenFile(fmt.Sprintf("agent-%s.log", agentName), os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
			if err != nil {
				return fmt.Errorf("failed to open agent log for stdout: %w", err)
			}
			defer stdoutFile.Close()
			command.Stdout = stdoutFile

			stderrFile, err := os.OpenFile(fmt.Sprintf("agent-%s.log", agentName), os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
			if err != nil {
				return fmt.Errorf("failed to open agent log for stderr: %w", err)
			}
			defer stderrFile.Close()
			command.Stderr = stderrFile

			if err := command.Start(); err != nil {
				return fmt.Errorf("failed to start agent process: %w", err)
			}

			if err := ioutil.WriteFile(pidFile, []byte(strconv.Itoa(command.Process.Pid)), 0644); err != nil {
				return fmt.Errorf("failed to write PID file: %w", err)
			}

			cmd.Printf("Agent %s started with PID %d.\n", agentName, command.Process.Pid)
			return nil
		}

		lis, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
		if err != nil {
			return fmt.Errorf("failed to listen: %v", err)
		}

		if masterAddr != "" {
			conn, err := grpc.Dial(masterAddr, grpc.WithInsecure())
			if err != nil {
				return fmt.Errorf("failed to connect to master: %v", err)
			}
			defer conn.Close()

			registryClient := pb.NewAgentRegistryClient(conn)
			_, err = registryClient.RegisterAgent(context.Background(), &pb.RegisterAgentRequest{
				AgentName:    agentName,
				AgentAddress: lis.Addr().String(),
			})
			if err != nil {
				return fmt.Errorf("failed to register with master: %v", err)
			}
			slog.Info(fmt.Sprintf("Agent registered with master at %s", masterAddr))
		}

		s := grpc.NewServer()
		server := &agentServer{grpcServer: s}
		pb.RegisterAgentServer(s, server)
		slog.Info(fmt.Sprintf("Agent listening at %v", lis.Addr()))
		if err := s.Serve(lis); err != nil {
			return fmt.Errorf("failed to serve: %v", err)
		}
		return nil
	},
}

var agentRunCmd = &cobra.Command{
	Use:   "run <agent_name> <command>",
	Short: "Executes a command on a remote agent",
	Long:  `Executes an arbitrary shell command on a specified remote agent.`, 
	Args:  cobra.ExactArgs(2),
	RunE: func(cmd *cobra.Command, args []string) error {
		agentName := args[0]
		command := args[1]

		conn, err := grpc.Dial("localhost:50053", grpc.WithInsecure()) // Master's AgentRegistry address
		if err != nil {
			return fmt.Errorf("failed to connect to master: %v", err)
		}
		defer conn.Close()

		registryClient := pb.NewAgentRegistryClient(conn)
		resp, err := registryClient.ExecuteCommand(context.Background(), &pb.ExecuteCommandRequest{
			AgentName: agentName,
			Command:   command,
		})
		if err != nil {
			return fmt.Errorf("failed to execute command on agent %s: %v", agentName, err)
		}

		if !resp.GetSuccess() {
			return fmt.Errorf("command failed on agent %s: %s (stderr: %s, error: %s)", agentName, resp.GetStdout(), resp.GetStderr(), resp.GetError())
		}

		fmt.Printf("Command executed successfully on agent %s:\nStdout:\n%s\nStderr:\n%s\n", agentName, resp.GetStdout(), resp.GetStderr())
		return nil
	},
}

var agentListCmd = &cobra.Command{
	Use:   "list",
	Short: "Lists all registered agents",
	Long:  `Lists all agents that are currently registered with the master.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		debug, _ := cmd.Flags().GetBool("debug")
		if debug {
			pterm.DefaultLogger.Level = pterm.LogLevelDebug
			slog.SetDefault(slog.New(pterm.NewSlogHandler(&pterm.DefaultLogger)))
			fmt.Println("Debug mode enabled for agent list command.")
		}
		conn, err := grpc.Dial("localhost:50053", grpc.WithInsecure()) // Master's AgentRegistry address
		if err != nil {
			fmt.Printf("Error connecting to master: %v\n", err)
			return fmt.Errorf("failed to connect to master: %v", err)
		}
		defer conn.Close()
		fmt.Printf("Connected to master: %v\n", conn)

		registryClient := pb.NewAgentRegistryClient(conn)
		fmt.Printf("Registry client created: %v\n", registryClient)

		resp, err := registryClient.ListAgents(context.Background(), &pb.ListAgentsRequest{})
		if err != nil {
			return fmt.Errorf("failed to list agents: %v", err)
		}

		if len(resp.GetAgents()) == 0 {
			fmt.Println("No agents registered.")
			return nil
		}

		w := tabwriter.NewWriter(os.Stdout, 0, 0, 3, ' ', 0)
		fmt.Fprintln(w, "AGENT NAME\tADDRESS")
		fmt.Fprintln(w, "------------\t----------")
		for _, agent := range resp.GetAgents() {
			fmt.Fprintf(w, "%s\t%s\n", agent.GetAgentName(), agent.GetAgentAddress())
		}
		return w.Flush()
	},
}

var agentStopCmd = &cobra.Command{
	Use:   "stop <agent_name>",
	Short: "Stops a remote agent",
	Long:  `Stops a specified remote agent gracefully.`, 
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		agentName := args[0]

		conn, err := grpc.Dial("localhost:50053", grpc.WithInsecure()) // Master's AgentRegistry address
		if err != nil {
			return fmt.Errorf("failed to connect to master: %v", err)
		}
		defer conn.Close()

		registryClient := pb.NewAgentRegistryClient(conn)
		_, err = registryClient.StopAgent(context.Background(), &pb.StopAgentRequest{
			AgentName: agentName,
		})
		if err != nil {
			return fmt.Errorf("failed to stop agent %s: %v", agentName, err)
		}

		fmt.Printf("Stop signal sent to agent %s successfully.\n", agentName)
		return nil
	},
}

type agentServer struct {
	pb.UnimplementedAgentServer
	grpcServer *grpc.Server
}

func (s *agentServer) Shutdown(ctx context.Context, in *pb.ShutdownRequest) (*pb.ShutdownResponse, error) {
	slog.Info("Shutting down agent server")
	go func() {
		time.Sleep(1 * time.Second)
		s.grpcServer.GracefulStop()
	}()
	return &pb.ShutdownResponse{}, nil
}

func (s *agentServer) ExecuteTask(ctx context.Context, in *pb.ExecuteTaskRequest) (*pb.ExecuteTaskResponse, error) {
	slog.Info(fmt.Sprintf("Received task: %s", in.GetTaskName()))

	// Create a temporary directory for the workspace
	workDir, err := ioutil.TempDir("", "sloth-runner-agent-")
	if err != nil {
		return nil, fmt.Errorf("failed to create temp dir: %w", err)
	}
	defer os.RemoveAll(workDir)

	// Unpack the workspace
	if err := extractTar(bytes.NewReader(in.GetWorkspace()), workDir); err != nil {
		return nil, fmt.Errorf("failed to untar workspace: %w", err)
	}

	// Create a new Lua state
	L := lua.NewState()
	defer L.Close()

	// Load the Lua script
	if err := L.DoString(in.GetLuaScript()); err != nil {
		return nil, fmt.Errorf("failed to load lua script: %w", err)
	}

	// Create a new task runner
	taskGroups, err := luainterface.LoadTaskDefinitions(L, in.GetLuaScript(), "")
	if err != nil {
		return nil, fmt.Errorf("failed to load task definitions: %w", err)
	}
				tr := taskrunner.NewTaskRunner(L, taskGroups, in.GetTaskGroup(), []string{in.GetTaskName()}, false, false, nil, in.GetLuaScript())
	// Run the task
	if err := tr.Run(); err != nil {
		return &pb.ExecuteTaskResponse{Success: false, Output: err.Error()}, nil
	}

	// Pack the workspace
	var buf bytes.Buffer
	if err := createTar(workDir, &buf); err != nil {
		return nil, fmt.Errorf("failed to tar workspace: %w", err)
	}

	return &pb.ExecuteTaskResponse{Success: true, Output: "Task executed successfully", Workspace: buf.Bytes()}, nil
}

// tar function to create a tarball of a directory
func createTar(source string, writer io.Writer) error {
	tw := tar.NewWriter(writer)
	defer tw.Close()
	return filepath.Walk(source, func(file string, fi os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		header, err := tar.FileInfoHeader(fi, file)
		if err != nil {
			return err
		}
		header.Name = filepath.ToSlash(file[len(source):])
		if err := tw.WriteHeader(header); err != nil {
			return err
		}
		if !fi.IsDir() {
			f, err := os.Open(file)
			if err != nil {
				return err
			}
			defer f.Close()
			if _, err := io.Copy(tw, f); err != nil {
				return err
			}
		}
		return nil
	})
}

// untar function to extract a tarball to a directory
func extractTar(reader io.Reader, dest string) error {
	tr := tar.NewReader(reader)
	for {
		header, err := tr.Next()
		switch {
		case err == io.EOF:
			return nil
		case err != nil:
			return err
		case header == nil:
			continue
		}
		target := filepath.Join(dest, header.Name)
		switch header.Typeflag {
		case tar.TypeDir:
			if _, err := os.Stat(target); err != nil {
				if err := os.MkdirAll(target, 0755); err != nil {
					return err
				}
			}
		case tar.TypeReg:
			f, err := os.OpenFile(target, os.O_CREATE|os.O_RDWR, os.FileMode(header.Mode))
			if err != nil {
				return err
			}
			defer f.Close()
			if _, err := io.Copy(f, tr); err != nil {
				return err
			}
		}
	}
}

var masterCmd = &cobra.Command{
	Use:   "master",
	Short: "Starts the sloth-runner master server",
	Long:  `The master command starts the sloth-runner master server, which includes the agent registry.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		port, _ := cmd.Flags().GetInt("port")
		daemon, _ := cmd.Flags().GetBool("daemon")

		if daemon {
			pidFile := filepath.Join(".", "sloth-runner-master.pid")
			if _, err := os.Stat(pidFile); err == nil {
				pidBytes, err := ioutil.ReadFile(pidFile)
				if err == nil {
					pid, _ := strconv.Atoi(string(pidBytes))
					if process, err := os.FindProcess(pid); err == nil {
						if err := processSignal(process, syscall.Signal(0)); err == nil {
							cmd.Printf("Master server is already running with PID %d.\n", pid)
							return nil
						}
					}
				}
				os.Remove(pidFile)
			}

			command := execCommand(os.Args[0], "master", "--port", strconv.Itoa(port))
			setSysProcAttr(command)
			stdoutFile, err := os.OpenFile("master.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
			if err != nil {
				return fmt.Errorf("failed to open master.log for stdout: %w", err)
			}
			defer stdoutFile.Close()
			command.Stdout = stdoutFile

			stderrFile, err := os.OpenFile("master.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
			if err != nil {
				return fmt.Errorf("failed to open master.log for stderr: %w", err)
			}
			defer stderrFile.Close()
			command.Stderr = stderrFile

			if err := command.Start(); err != nil {
				return fmt.Errorf("failed to start master server process: %w", err)
			}

			if err := ioutil.WriteFile(pidFile, []byte(strconv.Itoa(command.Process.Pid)), 0644); err != nil {
				return fmt.Errorf("failed to write PID file: %w", err)
			}

			cmd.Printf("Master server started with PID %d.\n", command.Process.Pid)
			return nil
		}

		return globalAgentRegistry.Start(port)
	},
}

var globalAgentRegistry *agentRegistryServer

func init() {
	rootCmd.SetOut(os.Stdout) // Add this line
	rootCmd.SetErr(os.Stderr) // Add this line
	rootCmd.SilenceErrors = false // Add this line
	rootCmd.SilenceUsage = false // Add this line

	globalAgentRegistry = newAgentRegistryServer()

	rootCmd.AddCommand(masterCmd)
	masterCmd.Flags().IntP("port", "p", 50053, "The port for the master to listen on")
	masterCmd.Flags().Bool("daemon", false, "Run the master server as a daemon")

	agentStartCmd.Flags().IntP("port", "p", 50051, "The port for the agent to listen on")
	agentStartCmd.Flags().String("master", "", "The address of the master server to register with")
	agentStartCmd.Flags().String("name", "", "The name of the agent")
	agentStartCmd.Flags().Bool("daemon", false, "Run the agent as a daemon")
	rootCmd.AddCommand(versionCmd)
	rootCmd.AddCommand(templateCmd)
	rootCmd.AddCommand(newCmd)
	rootCmd.AddCommand(runCmd)
	rootCmd.AddCommand(listCmd)
	rootCmd.AddCommand(validateCmd)
	rootCmd.AddCommand(testCmd)
	rootCmd.AddCommand(checkCmd)
	rootCmd.AddCommand(replCmd)
	rootCmd.AddCommand(schedulerCmd)
	rootCmd.AddCommand(agentCmd)
	agentCmd.AddCommand(agentStartCmd)
	agentCmd.AddCommand(agentRunCmd)
	agentCmd.AddCommand(agentListCmd)
	agentCmd.AddCommand(agentStopCmd)
	agentListCmd.Flags().Bool("debug", false, "Enable debug logging for this command")
	checkCmd.AddCommand(dependenciesCmd)

	schedulerCmd.AddCommand(enableCmd)
	schedulerCmd.AddCommand(disableCmd)
	schedulerCmd.AddCommand(listScheduledCmd)
	schedulerCmd.AddCommand(deleteScheduledCmd)

	newCmd.Flags().StringVarP(&outputFile, "output", "o", "", "Output file path (default: stdout)")
	newCmd.Flags().StringVarP(&templateName, "template", "t", "simple", "Template to use. See 'template list' for options.")
	newCmd.Flags().StringArrayVar(&setFlags, "set", []string{}, "Set key-value pairs for template data (e.g., --set image=my-app --set version=1.0)")
	runCmd.Flags().StringVarP(&configFilePath, "file", "f", "examples/basic_pipeline.lua", "Path to the Lua task configuration template file")
	runCmd.Flags().StringVarP(&env, "env", "e", "Development", "Environment for the tasks (e.g., Development, Production)")
	runCmd.Flags().BoolVarP(&isProduction, "prod", "p", false, "Set to true for production environment")
	runCmd.Flags().StringVar(&shardsStr, "shards", "1,2,3", "Comma-separated list of shard numbers (e.g., 1,2,3)")
	runCmd.Flags().StringVarP(&targetTasksStr, "tasks", "t", "", "Comma-separated list of specific tasks to run (e.g., task1,task2)")
	runCmd.Flags().StringVarP(&targetGroup, "group", "g", "", "Run tasks only from a specific task group")
	runCmd.Flags().StringVarP(&valuesFilePath, "values", "v", "", "Path to a YAML file with values to be passed to Lua tasks")
	runCmd.Flags().BoolVarP(&dryRun, "dry-run", "d", false, "Simulate the execution of tasks without actually running them")
	runCmd.Flags().BoolVar(&returnOutput, "return", false, "Return the output of the target tasks as JSON")
	runCmd.Flags().BoolVarP(&yes, "yes", "y", false, "Bypass interactive task selection and run all tasks")
	runCmd.Flags().BoolVar(&interactive, "interactive", false, "Enable interactive mode for task execution")
	listCmd.Flags().StringVarP(&configFilePath, "file", "f", "examples/basic_pipeline.lua", "Path to the Lua task configuration template file")
	listCmd.Flags().StringVarP(&env, "env", "e", "Development", "Environment for the tasks (e.g., Development, Production)")
	listCmd.Flags().BoolVarP(&isProduction, "prod", "p", false, "Set to true for production environment")
	listCmd.Flags().StringVar(&shardsStr, "shards", "1,2,3", "Comma-separated list of shard numbers (e.g., 1,2,3)")
	listCmd.Flags().StringVarP(&valuesFilePath, "values", "v", "", "Path to a YAML file with values to be passed to Lua tasks")
	validateCmd.Flags().StringVarP(&configFilePath, "file", "f", "examples/basic_pipeline.lua", "Path to the Lua task configuration template file")
	validateCmd.Flags().StringVarP(&env, "env", "e", "Development", "Environment for the tasks (e.g., Development, Production)")
	validateCmd.Flags().BoolVarP(&isProduction, "prod", "p", false, "Set to true for production environment")
	validateCmd.Flags().StringVar(&shardsStr, "shards", "1,2,3", "Comma-separated list of shard numbers (e.g., 1,2,3)")
	validateCmd.Flags().StringVarP(&valuesFilePath, "values", "v", "", "Path to a YAML file with values to be passed to Lua tasks")
	testCmd.Flags().StringP("file", "f", "", "Path to the Lua test file (required)")
	testCmd.Flags().StringP("workflow", "w", "", "Path to the Lua workflow file to be tested (required)")
	testCmd.MarkFlagRequired("file")
	testCmd.MarkFlagRequired("workflow")
	replCmd.Flags().StringP("file", "f", "", "Path to a Lua workflow file to load into the REPL session")

	rootCmd.AddCommand(pluginCmd)
	pluginCmd.AddCommand(installCmd)
	pluginCmd.AddCommand(listPluginsCmd)
	pluginCmd.AddCommand(uninstallPluginCmd)

	schedulerCmd.PersistentFlags().StringVarP(&schedulerConfigPath, "scheduler-config", "c", "scheduler.yaml", "Path to the scheduler configuration file")
	rootCmd.PersistentFlags().BoolVar(&runAsScheduler, "run-as-scheduler", false, "(Internal) Do not use directly. Runs the process as a background scheduler.")
	rootCmd.PersistentFlags().Bool("debug", false, "Enable debug logging")
	schedulerPIDFile = filepath.Join(filepath.Dir(schedulerConfigPath), "sloth-runner-scheduler.pid")

	if testOutputBuffer != nil {
		pterm.DefaultLogger.Writer = testOutputBuffer
		slog.SetDefault(slog.New(pterm.NewSlogHandler(&pterm.DefaultLogger)))
	}
}

func Execute() error {
	rootCmd.SilenceUsage = true // Suppress help on execution errors

	// debug, _ := rootCmd.PersistentFlags().GetBool("debug") // Removed as debug is now a local flag	// if debug {
	// 	pterm.DefaultLogger.Level = pterm.LogLevelDebug
	// }

	if runAsScheduler {
		// This is the background scheduler process
		sched := scheduler.NewScheduler(schedulerConfigPath)
		if err := sched.LoadConfig(); err != nil {
			slog.Error("failed to load scheduler config", "err", err)
			return err // Return error instead of os.Exit(1)
		}
		if err := sched.Start(); err != nil {
			slog.Error("failed to start scheduler", "err", err)
			return err // Return error instead of os.Exit(1)
		}

		// Keep the scheduler running until terminated
		select {}
	}

	err := rootCmd.Execute()
	if err != nil {
		slog.Error("DEBUG: rootCmd.Execute() returned error", "err", err)
	}
	return err
}

func main() {
	// Use pterm's slog handler to make logs coexist with the live dashboard
	slog.SetDefault(slog.New(pterm.NewSlogHandler(&pterm.DefaultLogger)))

	if err := Execute(); err != nil {
		slog.Error("execution failed", "err", err)
		os.Exit(1)
	}
}
