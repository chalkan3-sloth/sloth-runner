package agent

import (
	"context"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"time"

	"github.com/chalkan3-sloth/sloth-runner/cmd/sloth-runner/commands"
	"github.com/chalkan3-sloth/sloth-runner/internal/common"
	"github.com/chalkan3-sloth/sloth-runner/internal/grpcclient"
	pb "github.com/chalkan3-sloth/sloth-runner/proto"
	"github.com/spf13/cobra"
)

// NewArtifactsCommand creates the artifacts command
func NewArtifactsCommand(ctx *commands.AppContext) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "artifacts",
		Short: "Manage artifacts on remote agents",
		Long: `The artifacts command provides subcommands to list, download, upload, and delete
artifacts generated by tasks on remote agents.

Artifacts are files produced by tasks (declared via :artifacts() in the task definition)
that can be shared between tasks or downloaded for inspection.`,
		Run: func(cmd *cobra.Command, args []string) {
			cmd.Help()
		},
	}

	// Add subcommands
	cmd.AddCommand(newArtifactsListCmd(ctx))
	cmd.AddCommand(newArtifactsDownloadCmd(ctx))
	cmd.AddCommand(newArtifactsUploadCmd(ctx))
	cmd.AddCommand(newArtifactsDeleteCmd(ctx))
	cmd.AddCommand(newArtifactsShowCmd(ctx))
	cmd.AddCommand(newArtifactsCleanupCmd(ctx))

	return cmd
}

func newArtifactsListCmd(ctx *commands.AppContext) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "list <agent-name>",
		Short: "List all artifacts on an agent",
		Long: `List all artifacts stored on a remote agent.

Shows artifact name, size, creation time, and associated stack/task.`,
		Args: cobra.ExactArgs(1),
		RunE: func(cmd *cobra.Command, args []string) error {
			agentName := args[0]

			// Get filter flags
			stackFilter, _ := cmd.Flags().GetString("stack")
			taskFilter, _ := cmd.Flags().GetString("task")
			limit, _ := cmd.Flags().GetInt("limit")

			return listArtifacts(agentName, stackFilter, taskFilter, limit)
		},
	}

	cmd.Flags().StringP("stack", "s", "", "Filter by stack name")
	cmd.Flags().StringP("task", "t", "", "Filter by task name")
	cmd.Flags().IntP("limit", "l", 50, "Maximum number of artifacts to show")

	return cmd
}

func newArtifactsDownloadCmd(ctx *commands.AppContext) *cobra.Command {
	cmd := &cobra.Command{
	Use:   "download <agent-name> <artifact-name>",
	Short: "Download an artifact from an agent",
	Long: `Download an artifact from a remote agent to the local filesystem.

By default, downloads to the current directory. Use --output to specify a different path.`,
	Args: cobra.ExactArgs(2),
	RunE: func(cmd *cobra.Command, args []string) error {
		agentName := args[0]
		artifactName := args[1]

		outputPath, _ := cmd.Flags().GetString("output")
		if outputPath == "" {
			outputPath = filepath.Base(artifactName)
		}

		return downloadArtifact(agentName, artifactName, outputPath)
	},
}

var artifactsUploadCmd = &cobra.Command{
	Use:   "upload <agent-name> <file-path>",
	Short: "Upload a file as an artifact to an agent",
	Long: `Upload a local file to a remote agent's artifact storage.

Optionally associate it with a stack and task for organization.`,
	Args: cobra.ExactArgs(2),
	RunE: func(cmd *cobra.Command, args []string) error {
		agentName := args[0]
		filePath := args[1]

		stack, _ := cmd.Flags().GetString("stack")
		task, _ := cmd.Flags().GetString("task")
		artifactName, _ := cmd.Flags().GetString("name")

		if artifactName == "" {
			artifactName = filepath.Base(filePath)
		}

		return uploadArtifact(agentName, filePath, artifactName, stack, task)
	},
}

var artifactsDeleteCmd = &cobra.Command{
	Use:   "delete <agent-name> <artifact-name>",
	Short: "Delete an artifact from an agent",
	Long: `Delete an artifact from a remote agent's storage.

Use --force to skip confirmation prompt.`,
	Args: cobra.ExactArgs(2),
	RunE: func(cmd *cobra.Command, args []string) error {
		agentName := args[0]
		artifactName := args[1]

		force, _ := cmd.Flags().GetBool("force")

		if !force {
			fmt.Printf("Are you sure you want to delete artifact '%s' from agent '%s'? (y/N): ", artifactName, agentName)
			var response string
			fmt.Scanln(&response)
			if response != "y" && response != "Y" {
				fmt.Println("Cancelled")
				return nil
			}
		}

		return deleteArtifact(agentName, artifactName)
	},
}

var artifactsShowCmd = &cobra.Command{
	Use:   "show <agent-name> <artifact-name>",
	Short: "Show detailed information about an artifact",
	Long: `Display detailed information about an artifact including:
- Name and path
- Size and checksum
- Creation and modification times
- Associated stack and task
- Download count (if tracked)`,
	Args: cobra.ExactArgs(2),
	RunE: func(cmd *cobra.Command, args []string) error {
		agentName := args[0]
		artifactName := args[1]

		return showArtifact(agentName, artifactName)
	},
}

var artifactsCleanupCmd = &cobra.Command{
	Use:   "cleanup <agent-name>",
	Short: "Clean up old or unused artifacts on an agent",
	Long: `Remove artifacts older than a specified age or matching certain criteria.

Use --older-than to specify age (e.g., "7d", "30d", "6h")
Use --stack to limit cleanup to a specific stack
Use --dry-run to preview what would be deleted`,
	Args: cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		agentName := args[0]

		olderThan, _ := cmd.Flags().GetString("older-than")
		stackFilter, _ := cmd.Flags().GetString("stack")
		dryRun, _ := cmd.Flags().GetBool("dry-run")

		return cleanupArtifacts(agentName, olderThan, stackFilter, dryRun)
	},
}

func init() {
	// List flags
	artifactsListCmd.Flags().StringP("stack", "s", "", "Filter by stack name")
	artifactsListCmd.Flags().StringP("task", "t", "", "Filter by task name")
	artifactsListCmd.Flags().IntP("limit", "l", 50, "Maximum number of artifacts to show")

	// Download flags
	artifactsDownloadCmd.Flags().StringP("output", "o", "", "Output file path (default: artifact name)")

	// Upload flags
	artifactsUploadCmd.Flags().StringP("stack", "s", "", "Associate with stack")
	artifactsUploadCmd.Flags().StringP("task", "t", "", "Associate with task")
	artifactsUploadCmd.Flags().StringP("name", "n", "", "Artifact name (default: filename)")

	// Delete flags
	artifactsDeleteCmd.Flags().BoolP("force", "f", false, "Skip confirmation")

	// Cleanup flags
	artifactsCleanupCmd.Flags().String("older-than", "30d", "Remove artifacts older than this duration")
	artifactsCleanupCmd.Flags().StringP("stack", "s", "", "Limit cleanup to specific stack")
	artifactsCleanupCmd.Flags().Bool("dry-run", false, "Preview what would be deleted without deleting")

	artifactsCmd.AddCommand(artifactsListCmd)
	artifactsCmd.AddCommand(artifactsDownloadCmd)
	artifactsCmd.AddCommand(artifactsUploadCmd)
	artifactsCmd.AddCommand(artifactsDeleteCmd)
	artifactsCmd.AddCommand(artifactsShowCmd)
	artifactsCmd.AddCommand(artifactsCleanupCmd)
}

// Implementation functions

func listArtifacts(agentName, stackFilter, taskFilter string, limit int) error {
	logger := common.GetLogger()

	// Connect to agent
	agent, err := findAgentByName(agentName)
	if err != nil {
		return fmt.Errorf("agent not found: %w", err)
	}

	conn, err := grpcclient.Connect(agent.Address)
	if err != nil {
		return fmt.Errorf("failed to connect to agent: %w", err)
	}
	defer conn.Close()

	client := pb.NewSlothRunnerServiceClient(conn)
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	// Request artifacts list
	req := &pb.ListArtifactsRequest{
		Stack: stackFilter,
		Task:  taskFilter,
		Limit: int32(limit),
	}

	resp, err := client.ListArtifacts(ctx, req)
	if err != nil {
		return fmt.Errorf("failed to list artifacts: %w", err)
	}

	if len(resp.Artifacts) == 0 {
		logger.Info("No artifacts found")
		return nil
	}

	// Display artifacts table
	fmt.Printf("\n%s Artifacts on agent: %s %s\n\n",
		common.ColorInfo("ðŸ“¦"),
		common.ColorCyan(agentName),
		common.ColorInfo("ðŸ“¦"))

	fmt.Printf("%-40s %-15s %-12s %-20s %-20s\n", "Name", "Stack", "Size", "Created", "Task")
	fmt.Println(common.Separator(110))

	for _, artifact := range resp.Artifacts {
		size := formatSize(artifact.Size)
		created := time.Unix(artifact.CreatedAt, 0).Format("2006-01-02 15:04:05")

		fmt.Printf("%-40s %-15s %-12s %-20s %-20s\n",
			common.ColorCyan(artifact.Name),
			artifact.Stack,
			size,
			created,
			artifact.Task)
	}

	fmt.Printf("\n%s Total: %d artifacts\n", common.ColorInfo("â„¹"), len(resp.Artifacts))

	return nil
}

func downloadArtifact(agentName, artifactName, outputPath string) error {
	logger := common.GetLogger()

	agent, err := findAgentByName(agentName)
	if err != nil {
		return fmt.Errorf("agent not found: %w", err)
	}

	conn, err := grpcclient.Connect(agent.Address)
	if err != nil {
		return fmt.Errorf("failed to connect to agent: %w", err)
	}
	defer conn.Close()

	client := pb.NewSlothRunnerServiceClient(conn)
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
	defer cancel()

	// Request artifact download
	req := &pb.DownloadArtifactRequest{
		Name: artifactName,
	}

	stream, err := client.DownloadArtifact(ctx, req)
	if err != nil {
		return fmt.Errorf("failed to download artifact: %w", err)
	}

	// Create output file
	outFile, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %w", err)
	}
	defer outFile.Close()

	logger.Info(fmt.Sprintf("Downloading artifact '%s' from agent '%s'...", artifactName, agentName))

	var totalBytes int64
	for {
		chunk, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			return fmt.Errorf("error receiving chunk: %w", err)
		}

		n, err := outFile.Write(chunk.Data)
		if err != nil {
			return fmt.Errorf("error writing to file: %w", err)
		}
		totalBytes += int64(n)
	}

	logger.Success(fmt.Sprintf("Downloaded %s to '%s' (%s)",
		artifactName, outputPath, formatSize(totalBytes)))

	return nil
}

func uploadArtifact(agentName, filePath, artifactName, stack, task string) error {
	logger := common.GetLogger()

	// Check if file exists
	fileInfo, err := os.Stat(filePath)
	if err != nil {
		return fmt.Errorf("file not found: %w", err)
	}

	agent, err := findAgentByName(agentName)
	if err != nil {
		return fmt.Errorf("agent not found: %w", err)
	}

	conn, err := grpcclient.Connect(agent.Address)
	if err != nil {
		return fmt.Errorf("failed to connect to agent: %w", err)
	}
	defer conn.Close()

	client := pb.NewSlothRunnerServiceClient(conn)
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
	defer cancel()

	stream, err := client.UploadArtifact(ctx)
	if err != nil {
		return fmt.Errorf("failed to start upload: %w", err)
	}

	// Open file
	file, err := os.Open(filePath)
	if err != nil {
		return fmt.Errorf("failed to open file: %w", err)
	}
	defer file.Close()

	logger.Info(fmt.Sprintf("Uploading '%s' to agent '%s' as '%s'...",
		filePath, agentName, artifactName))

	// Send metadata first
	err = stream.Send(&pb.UploadArtifactRequest{
		Data: &pb.UploadArtifactRequest_Metadata{
			Metadata: &pb.ArtifactMetadata{
				Name:  artifactName,
				Stack: stack,
				Task:  task,
				Size:  fileInfo.Size(),
			},
		},
	})
	if err != nil {
		return fmt.Errorf("failed to send metadata: %w", err)
	}

	// Send file chunks
	buffer := make([]byte, 64*1024) // 64KB chunks
	for {
		n, err := file.Read(buffer)
		if err == io.EOF {
			break
		}
		if err != nil {
			return fmt.Errorf("error reading file: %w", err)
		}

		err = stream.Send(&pb.UploadArtifactRequest{
			Data: &pb.UploadArtifactRequest_Chunk{
				Chunk: buffer[:n],
			},
		})
		if err != nil {
			return fmt.Errorf("error sending chunk: %w", err)
		}
	}

	resp, err := stream.CloseAndRecv()
	if err != nil {
		return fmt.Errorf("error finishing upload: %w", err)
	}

	logger.Success(fmt.Sprintf("Uploaded %s (%s)",
		artifactName, formatSize(resp.BytesWritten)))

	return nil
}

func deleteArtifact(agentName, artifactName string) error {
	logger := common.GetLogger()

	agent, err := findAgentByName(agentName)
	if err != nil {
		return fmt.Errorf("agent not found: %w", err)
	}

	conn, err := grpcclient.Connect(agent.Address)
	if err != nil {
		return fmt.Errorf("failed to connect to agent: %w", err)
	}
	defer conn.Close()

	client := pb.NewSlothRunnerServiceClient(conn)
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	req := &pb.DeleteArtifactRequest{
		Name: artifactName,
	}

	_, err = client.DeleteArtifact(ctx, req)
	if err != nil {
		return fmt.Errorf("failed to delete artifact: %w", err)
	}

	logger.Success(fmt.Sprintf("Deleted artifact '%s' from agent '%s'",
		artifactName, agentName))

	return nil
}

func showArtifact(agentName, artifactName string) error {
	logger := common.GetLogger()

	agent, err := findAgentByName(agentName)
	if err != nil {
		return fmt.Errorf("agent not found: %w", err)
	}

	conn, err := grpcclient.Connect(agent.Address)
	if err != nil {
		return fmt.Errorf("failed to connect to agent: %w", err)
	}
	defer conn.Close()

	client := pb.NewSlothRunnerServiceClient(conn)
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	req := &pb.GetArtifactRequest{
		Name: artifactName,
	}

	resp, err := client.GetArtifact(ctx, req)
	if err != nil {
		return fmt.Errorf("failed to get artifact info: %w", err)
	}

	artifact := resp.Artifact

	fmt.Printf("\n%s Artifact Details\n\n", common.ColorInfo("ðŸ“¦"))
	fmt.Printf("Name:       %s\n", common.ColorCyan(artifact.Name))
	fmt.Printf("Path:       %s\n", artifact.Path)
	fmt.Printf("Size:       %s\n", formatSize(artifact.Size))
	fmt.Printf("Checksum:   %s\n", artifact.Checksum)
	fmt.Printf("Stack:      %s\n", artifact.Stack)
	fmt.Printf("Task:       %s\n", artifact.Task)
	fmt.Printf("Created:    %s\n", time.Unix(artifact.CreatedAt, 0).Format("2006-01-02 15:04:05"))
	fmt.Printf("Modified:   %s\n", time.Unix(artifact.ModifiedAt, 0).Format("2006-01-02 15:04:05"))

	if artifact.DownloadCount > 0 {
		fmt.Printf("Downloads:  %d\n", artifact.DownloadCount)
	}

	return nil
}

func cleanupArtifacts(agentName, olderThan, stackFilter string, dryRun bool) error {
	logger := common.GetLogger()

	// Parse duration
	duration, err := parseDuration(olderThan)
	if err != nil {
		return fmt.Errorf("invalid duration: %w", err)
	}

	agent, err := findAgentByName(agentName)
	if err != nil {
		return fmt.Errorf("agent not found: %w", err)
	}

	conn, err := grpcclient.Connect(agent.Address)
	if err != nil {
		return fmt.Errorf("failed to connect to agent: %w", err)
	}
	defer conn.Close()

	client := pb.NewSlothRunnerServiceClient(conn)
	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Minute)
	defer cancel()

	req := &pb.CleanupArtifactsRequest{
		OlderThanSeconds: int64(duration.Seconds()),
		Stack:            stackFilter,
		DryRun:           dryRun,
	}

	resp, err := client.CleanupArtifacts(ctx, req)
	if err != nil {
		return fmt.Errorf("failed to cleanup artifacts: %w", err)
	}

	if dryRun {
		logger.Info(fmt.Sprintf("Would delete %d artifacts (%s)",
			resp.DeletedCount, formatSize(resp.BytesFreed)))
	} else {
		logger.Success(fmt.Sprintf("Deleted %d artifacts, freed %s",
			resp.DeletedCount, formatSize(resp.BytesFreed)))
	}

	return nil
}

// Helper functions

func formatSize(bytes int64) string {
	const unit = 1024
	if bytes < unit {
		return fmt.Sprintf("%d B", bytes)
	}
	div, exp := int64(unit), 0
	for n := bytes / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])
}

func parseDuration(s string) (time.Duration, error) {
	// Simple parser for durations like "30d", "7d", "6h"
	if len(s) < 2 {
		return 0, fmt.Errorf("invalid duration format")
	}

	var multiplier time.Duration
	unit := s[len(s)-1]

	switch unit {
	case 'd':
		multiplier = 24 * time.Hour
	case 'h':
		multiplier = time.Hour
	case 'm':
		multiplier = time.Minute
	default:
		return time.ParseDuration(s)
	}

	var value int
	_, err := fmt.Sscanf(s[:len(s)-1], "%d", &value)
	if err != nil {
		return 0, err
	}

	return time.Duration(value) * multiplier, nil
}
