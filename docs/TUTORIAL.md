# üöÄ Sloth Runner - Quick Tutorial

> **Welcome to the world's most intelligent task orchestration platform!**  
> This tutorial will get you up and running with AI-powered automation and GitOps workflows in just 5 minutes.

## üéØ What You'll Learn

By the end of this tutorial, you'll have:
- ‚úÖ Installed Sloth Runner
- ‚úÖ Created your first AI-optimized task
- ‚úÖ Set up a GitOps workflow
- ‚úÖ Built an intelligent automation pipeline

## üì¶ Step 1: Installation

### Quick Install (Recommended)

```bash
# Install the latest version
curl -sSL https://get.sloth-runner.dev | bash

# Verify installation
sloth-runner --version
```

### Manual Install

```bash
# Download from GitHub releases
wget https://github.com/chalkan3-sloth/sloth-runner/releases/latest/download/sloth-runner-linux-amd64.tar.gz
tar -xzf sloth-runner-linux-amd64.tar.gz
sudo mv sloth-runner /usr/local/bin/
```

### Verify Installation

```bash
sloth-runner --help
```

## ü§ñ Step 2: Your First AI-Powered Task

Create a file called `hello-ai.lua`:

```lua
-- hello-ai.lua
local ai = require("ai")
local log = require("log")

-- Configure AI for optimal performance
ai.configure({
    enabled = true,
    learning_mode = "adaptive",
    optimization_level = 8,
    failure_prediction = true
})

log.info("ü§ñ Welcome to AI-Powered Automation!")

-- Create an intelligent task
local hello_task = task("ai_hello_world")
    :description("My first AI-optimized task")
    :command(function(params, deps)
        local original_command = "echo 'Hello, AI-Powered World!'"
        
        -- Let AI optimize the command
        local ai_result = ai.optimize_command(original_command)
        
        if ai_result.confidence_score > 0.5 then
            log.info("ü§ñ AI optimized the command!")
            log.info("üìà Confidence: " .. string.format("%.1f%%", ai_result.confidence_score * 100))
            log.info("‚ö° Expected speedup: " .. string.format("%.1fx", ai_result.expected_speedup))
            
            -- Use AI-optimized command
            return exec.run(ai_result.optimized_command)
        else
            log.info("‚ÑπÔ∏è Using original command (low AI confidence)")
            return exec.run(original_command)
        end
    end)
    :on_success(function(params, output)
        log.info("‚úÖ Task completed successfully!")
        
        -- Record execution for AI learning
        ai.record_execution({
            task_name = "ai_hello_world",
            command = output.command,
            success = true,
            execution_time = output.duration or "0s"
        })
    end)
    :build()

-- Create a simple workflow
workflow.define("ai_tutorial", {
    description = "AI-Powered Hello World Tutorial",
    tasks = { hello_task },
    
    on_complete = function(success, results)
        if success then
            log.info("üéâ AI Tutorial completed successfully!")
            log.info("üß† AI is now learning from this execution")
        end
    end
})
```

### Run Your AI-Powered Task

```bash
sloth-runner run -f hello-ai.lua
```

**Expected Output:**
```
ü§ñ Welcome to AI-Powered Automation!
ü§ñ AI optimized the command!
üìà Confidence: 85.0%
‚ö° Expected speedup: 1.2x
Hello, AI-Powered World!
‚úÖ Task completed successfully!
üéâ AI Tutorial completed successfully!
üß† AI is now learning from this execution
```

## üîÑ Step 3: Your First GitOps Workflow

Create a file called `hello-gitops.lua`:

```lua
-- hello-gitops.lua
local gitops = require("gitops")
local log = require("log")

log.info("üîÑ Welcome to GitOps Native Automation!")

-- Create a GitOps workflow (you can use any public repo for testing)
local git_workflow = gitops.workflow({
    repo = "https://github.com/kubernetes/examples",  -- Example public repo
    branch = "master",
    auto_sync = false,  -- Manual sync for this demo
    diff_preview = true,
    rollback_on_failure = true
})

log.info("‚úÖ GitOps workflow created!")
log.info("üìã Workflow ID: " .. git_workflow.workflow_id)
log.info("üì¶ Repository ID: " .. git_workflow.repository_id)

-- Create a deployment task
local deploy_task = task("gitops_deploy")
    :description("GitOps-powered deployment")
    :command(function(params, deps)
        -- Preview changes before deployment
        log.info("üîç Generating diff preview...")
        local diff = gitops.generate_diff(git_workflow.workflow_id)
        
        if diff then
            log.info("üìä GitOps Change Summary:")
            log.info("  üìù Total changes: " .. diff.summary.total_changes)
            log.info("  ‚ú® Created resources: " .. diff.summary.created_resources)
            log.info("  üîÑ Updated resources: " .. diff.summary.updated_resources)
            log.info("  üóëÔ∏è Deleted resources: " .. diff.summary.deleted_resources)
            
            if diff.summary.conflict_count > 0 then
                log.warn("‚ö†Ô∏è " .. diff.summary.conflict_count .. " conflict(s) detected")
                return {success = false, message = "Conflicts need resolution"}
            end
        else
            log.info("‚ÑπÔ∏è No changes detected")
        end
        
        -- Simulate deployment (since we're using a read-only example repo)
        log.info("üöÄ Simulating GitOps deployment...")
        log.info("‚úÖ GitOps deployment completed successfully!")
        
        return {success = true, message = "GitOps deployment successful"}
    end)
    :build()

-- Monitor workflow status
local status_task = task("check_status")
    :description("Check GitOps workflow status")
    :command(function(params, deps)
        local status = gitops.get_workflow_status(git_workflow.workflow_id)
        
        if status then
            log.info("üìä GitOps Workflow Status:")
            log.info("  üè∑Ô∏è Name: " .. status.name)
            log.info("  üìà Status: " .. status.status)
            log.info("  üîÑ Auto-sync: " .. tostring(status.auto_sync))
            log.info("  üì¶ Repository: " .. status.repository)
        end
        
        return {success = true, message = "Status check completed"}
    end)
    :build()

-- Create GitOps workflow
workflow.define("gitops_tutorial", {
    description = "GitOps Native Tutorial",
    tasks = { deploy_task, status_task },
    
    on_complete = function(success, results)
        if success then
            log.info("üéâ GitOps Tutorial completed successfully!")
            log.info("üîÑ You now understand GitOps native workflows!")
        end
    end
})
```

### Run Your GitOps Workflow

```bash
sloth-runner run -f hello-gitops.lua
```

**Expected Output:**
```
üîÑ Welcome to GitOps Native Automation!
‚úÖ GitOps workflow created!
üìã Workflow ID: workflow-1234567890
üì¶ Repository ID: repo-1234567890
üîç Generating diff preview...
üìä GitOps Change Summary:
  üìù Total changes: 3
  ‚ú® Created resources: 2
  üîÑ Updated resources: 1
  üóëÔ∏è Deleted resources: 0
üöÄ Simulating GitOps deployment...
‚úÖ GitOps deployment completed successfully!
üìä GitOps Workflow Status:
  üè∑Ô∏è Name: lua-generated-workflow
  üìà Status: syncing
  üîÑ Auto-sync: false
  üì¶ Repository: repo-1234567890
üéâ GitOps Tutorial completed successfully!
üîÑ You now understand GitOps native workflows!
```

## ‚ö° Step 4: Intelligent Pipeline (AI + GitOps)

Create a file called `intelligent-pipeline.lua`:

```lua
-- intelligent-pipeline.lua  
local ai = require("ai")
local gitops = require("gitops")
local log = require("log")

log.info("üß† Building an Intelligent Pipeline with AI + GitOps!")

-- Configure AI for production-ready optimization
ai.configure({
    enabled = true,
    learning_mode = "adaptive",
    optimization_level = 7,
    failure_prediction = true,
    auto_optimize = true
})

-- Create GitOps workflow for deployment
local deployment_workflow = gitops.workflow({
    repo = "https://github.com/kubernetes/examples",
    branch = "master", 
    auto_sync = false,
    diff_preview = true,
    rollback_on_failure = true
})

-- AI-optimized build task
local build_task = task("intelligent_build")
    :description("AI-optimized build process")
    :command(function(params, deps)
        local build_command = "echo 'Building application...'"
        
        -- AI optimization with context
        local optimization = ai.optimize_command(build_command, {
            history = ai.get_task_history(build_command),
            system_resources = {
                cpu_usage = 30,
                memory_usage = 50
            }
        })
        
        if optimization.confidence_score > 0.6 then
            log.info("ü§ñ AI Build Optimization Applied!")
            log.info("üìà Confidence: " .. string.format("%.1f%%", optimization.confidence_score * 100))
            log.info("‚ö° Expected Speedup: " .. string.format("%.1fx", optimization.expected_speedup))
            
            return exec.run(optimization.optimized_command)
        else
            log.info("üîß Using standard build process")
            return exec.run(build_command)
        end
    end)
    :build()

-- AI-enhanced deployment with failure prediction
local deploy_task = task("intelligent_deploy")
    :description("AI-predicted GitOps deployment")
    :depends_on({"intelligent_build"})
    :command(function(params, deps)
        local deploy_command = "kubectl apply -f manifests/"
        
        -- AI failure prediction
        local prediction = ai.predict_failure("intelligent_deploy", deploy_command)
        
        log.info("üîÆ AI Deployment Analysis:")
        log.info("üìä Failure Probability: " .. string.format("%.1f%%", prediction.failure_probability * 100))
        log.info("üéØ Prediction Confidence: " .. string.format("%.1f%%", prediction.confidence * 100))
        
        if prediction.failure_probability > 0.3 then
            log.warn("‚ö†Ô∏è HIGH RISK DEPLOYMENT DETECTED!")
            log.warn("üö® AI recommends caution")
            
            for _, recommendation in ipairs(prediction.recommendations) do
                log.info("üí° AI Recommendation: " .. recommendation)
            end
        else
            log.info("‚úÖ AI assessment: Low risk deployment")
        end
        
        -- GitOps deployment with intelligent preview
        log.info("üîç GitOps intelligent diff analysis...")
        local diff = gitops.generate_diff(deployment_workflow.workflow_id)
        
        if diff and diff.summary.total_changes > 0 then
            log.info("üìã Deployment will apply " .. diff.summary.total_changes .. " changes")
            
            -- Check for conflicts
            if diff.summary.conflict_count > 0 then
                log.warn("üí• " .. diff.summary.conflict_count .. " conflicts detected!")
                return {success = false, message = "Conflicts require manual resolution"}
            end
        end
        
        -- Execute intelligent deployment
        log.info("üöÄ Executing AI + GitOps intelligent deployment...")
        local deploy_success = true  -- Simulated for tutorial
        
        if deploy_success then
            log.info("‚úÖ Intelligent deployment completed successfully!")
            
            -- Record execution for AI learning
            ai.record_execution({
                task_name = "intelligent_deploy",
                command = deploy_command,
                success = true,
                execution_time = "45s",
                ai_prediction_used = true,
                predicted_failure_probability = prediction.failure_probability,
                gitops_changes_applied = diff and diff.summary.total_changes or 0
            })
            
            return {success = true, message = "AI + GitOps deployment successful"}
        else
            log.error("üí• Deployment failed - AI will learn from this failure")
            return {success = false, message = "Deployment failed"}
        end
    end)
    :build()

-- Intelligent monitoring task
local monitor_task = task("intelligent_monitor")
    :description("AI-powered post-deployment monitoring")
    :depends_on({"intelligent_deploy"})
    :command(function(params, deps)
        log.info("üìä Starting AI-powered monitoring...")
        
        -- Get performance analysis
        local analysis = ai.analyze_performance("intelligent_deploy")
        
        if analysis.total_executions > 0 then
            log.info("üìà AI Performance Analysis:")
            log.info("  üìä Total executions: " .. analysis.total_executions)
            log.info("  ‚úÖ Success rate: " .. string.format("%.1f%%", analysis.success_rate * 100))
            log.info("  ‚è±Ô∏è Average time: " .. analysis.avg_execution_time)
            log.info("  üìà Trend: " .. analysis.performance_trend)
            
            if #analysis.insights > 0 then
                log.info("üí° AI Insights:")
                for _, insight in ipairs(analysis.insights) do
                    log.info("  üîÆ " .. insight)
                end
            end
        else
            log.info("‚ÑπÔ∏è Insufficient data for AI analysis - will improve with more executions")
        end
        
        -- Check GitOps workflow status
        local gitops_status = gitops.get_workflow_status(deployment_workflow.workflow_id)
        log.info("üîÑ GitOps Status: " .. gitops_status.status)
        
        return {success = true, message = "Intelligent monitoring completed"}
    end)
    :build()

-- Create the intelligent pipeline
workflow.define("intelligent_pipeline", {
    description = "AI + GitOps Intelligent Automation Pipeline",
    version = "2.0.0",
    
    metadata = {
        author = "AI-Powered DevOps",
        tags = {"ai", "gitops", "intelligent", "tutorial"},
        ai_enabled = true,
        gitops_enabled = true
    },
    
    tasks = { build_task, deploy_task, monitor_task },
    
    on_task_start = function(task_name)
        log.info("ü§ñ AI Pre-task Analysis: " .. task_name)
    end,
    
    on_task_complete = function(task_name, success, output)
        if success then
            log.info("‚úÖ Intelligent task completed: " .. task_name)
        else
            log.error("‚ùå Task failed - AI will analyze failure: " .. task_name)
        end
        
        -- Always record for AI learning
        ai.record_execution({
            task_name = task_name,
            success = success,
            execution_time = output.duration or "0s",
            pipeline = "intelligent_pipeline"
        })
    end,
    
    on_complete = function(success, results)
        if success then
            log.info("üéâ INTELLIGENT PIPELINE COMPLETED SUCCESSFULLY!")
            log.info("üß† AI has learned from this execution")
            log.info("üîÑ GitOps state is synchronized")
            log.info("üìä Performance data collected for future optimizations")
            
            -- Generate final AI insights
            local insights = ai.generate_insights({scope = "pipeline"})
            if #insights > 0 then
                log.info("üåü Final AI Insights:")
                for _, insight in ipairs(insights) do
                    log.info("  üí° " .. insight)
                end
            end
        else
            log.error("üí• Intelligent pipeline failed")
            log.info("üîç AI will analyze failure patterns for future improvements")
        end
    end
})
```

### Run Your Intelligent Pipeline

```bash
sloth-runner run -f intelligent-pipeline.lua
```

**Expected Output:**
```
üß† Building an Intelligent Pipeline with AI + GitOps!
ü§ñ AI Pre-task Analysis: intelligent_build
ü§ñ AI Build Optimization Applied!
üìà Confidence: 78.0%
‚ö° Expected Speedup: 1.5x
Building application...
‚úÖ Intelligent task completed: intelligent_build
ü§ñ AI Pre-task Analysis: intelligent_deploy
üîÆ AI Deployment Analysis:
üìä Failure Probability: 15.2%
üéØ Prediction Confidence: 82.0%
‚úÖ AI assessment: Low risk deployment
üîç GitOps intelligent diff analysis...
üìã Deployment will apply 3 changes
üöÄ Executing AI + GitOps intelligent deployment...
‚úÖ Intelligent deployment completed successfully!
‚úÖ Intelligent task completed: intelligent_deploy
ü§ñ AI Pre-task Analysis: intelligent_monitor
üìä Starting AI-powered monitoring...
üìà AI Performance Analysis:
  üìä Total executions: 1
  ‚úÖ Success rate: 100.0%
  ‚è±Ô∏è Average time: 45s
  üìà Trend: stable
üîÑ GitOps Status: syncing
‚úÖ Intelligent task completed: intelligent_monitor
üéâ INTELLIGENT PIPELINE COMPLETED SUCCESSFULLY!
üß† AI has learned from this execution
üîÑ GitOps state is synchronized
üìä Performance data collected for future optimizations
üåü Final AI Insights:
  üí° Consider implementing parallel execution for better performance
  üí° Task execution patterns suggest optimal scheduling during off-peak hours
```

## üéì What You've Learned

Congratulations! You've just:

‚úÖ **Mastered AI-Powered Automation**: Created tasks that use artificial intelligence for optimization and failure prediction

‚úÖ **Implemented GitOps Native Workflows**: Set up Git-driven deployments with intelligent diff preview

‚úÖ **Built Intelligent Pipelines**: Combined AI and GitOps for the ultimate automation experience

‚úÖ **Used Modern DSL**: Experienced the clean, powerful syntax of Sloth Runner's domain-specific language

## üöÄ Next Steps

Now that you understand the basics, explore these advanced features:

### ü§ñ Deep Dive into AI
- [AI Features Complete Guide](en/ai-features.md)
- [Performance Optimization Strategies](en/ai/optimization.md)
- [Failure Prediction Best Practices](en/ai/prediction.md)

### üîÑ Master GitOps
- [GitOps Features Complete Guide](en/gitops-features.md)
- [Multi-Environment Deployments](en/gitops/multi-env.md)
- [Kubernetes Integration](en/gitops/kubernetes.md)

### üè¢ Enterprise Features
- [Distributed Architecture](en/master-agent-architecture.md)
- [Security & RBAC](en/security.md)
- [Monitoring & Observability](en/monitoring.md)

### üìö Real-World Examples
- [Production CI/CD Pipelines](en/examples/cicd.md)
- [Infrastructure as Code](en/examples/iac.md)
- [Multi-Cloud Deployments](en/examples/multi-cloud.md)

## üí¨ Community & Support

- **üìñ [Complete Documentation](https://sloth-runner.dev/docs)** - Comprehensive guides and references
- **üí¨ [Discord Community](https://discord.gg/sloth-runner)** - Get help and share experiences  
- **üêõ [GitHub Issues](https://github.com/chalkan3-sloth/sloth-runner/issues)** - Report bugs and request features
- **üè¢ [Enterprise Support](mailto:enterprise@sloth-runner.dev)** - Commercial support and services

---

**üéâ Welcome to the future of intelligent automation!**

You're now ready to build production-grade workflows with the world's most advanced task orchestration platform. Start building amazing things with AI-powered automation and GitOps native workflows!