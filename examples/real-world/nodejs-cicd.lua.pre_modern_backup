-- Modern DSL: [FILE_DESCRIPTION]
-- Migrated from legacy TaskDefinitions format
-- This example now uses the modern fluent API alongside legacy compatibility

-- üöÄ Node.js CI/CD Pipeline - Pipeline completo de CI/CD para aplica√ß√£o Node.js
-- Este exemplo demonstra um pipeline de produ√ß√£o real com m√∫ltiplos ambientes


-- TODO: Implement modern DSL version here
-- Example modern DSL structure:
--
-- local example_task = task("task_name")
--     :description("Task description with modern DSL")
--     :command(function(params, deps)
--         -- Enhanced task logic
--         return true, "Task completed", { result = "success" }
--     end)
--     :timeout("30s")
--     :build()
--
-- workflow.define("workflow_name", {
--     description = "Workflow description - Modern DSL",
--     version = "2.0.0",
--     tasks = { example_task },
--     config = { timeout = "10m" }
-- })

-- Maintain backward compatibility with legacy format
TaskDefinitions = {
    nodejs_cicd_pipeline = {
        description = "Pipeline completo de CI/CD para aplica√ß√£o Node.js",
        
        tasks = {
            {
                name = "setup_pipeline_environment",
                description = "Configura ambiente do pipeline e vari√°veis",
                command = function(params)
                    log.info("üöÄ Configurando Pipeline CI/CD para Node.js...")
                    
                    -- Configura√ß√µes do pipeline
                    local pipeline_config = {
                        app_name = params.app_name or "nodejs-demo-app",
                        version = params.version or "1.0.0",
                        git_repo = params.git_repo or "https://github.com/example/nodejs-app.git",
                        environments = {
                            development = {
                                domain = "dev.myapp.com",
                                replicas = 1,
                                resources = {cpu = "100m", memory = "128Mi"}
                            },
                            staging = {
                                domain = "staging.myapp.com", 
                                replicas = 2,
                                resources = {cpu = "200m", memory = "256Mi"}
                            },
                            production = {
                                domain = "myapp.com",
                                replicas = 3,
                                resources = {cpu = "500m", memory = "512Mi"}
                            }
                        },
                        docker_registry = "docker.io/mycompany",
                        notification_webhook = "https://hooks.slack.com/services/..."
                    }
                    
                    -- Configurar ferramentas necess√°rias
                    local tools = {
                        node_version = "18",
                        npm_version = "latest",
                        docker_required = true,
                        kubectl_required = true,
                        helm_required = true
                    }
                    
                    state.set("pipeline_config", pipeline_config)
                    state.set("required_tools", tools)
                    
                    -- Inicializar m√©tricas do pipeline
                    local metrics = {
                        pipeline_start_time = os.time(),
                        stages_completed = 0,
                        total_stages = 8,
                        tests_run = 0,
                        tests_passed = 0,
                        build_duration = 0,
                        deploy_duration = 0
                    }
                    
                    state.set("pipeline_metrics", metrics)
                    
                    log.info("‚úÖ Pipeline configurado:")
                    log.info("  üì± App: " .. pipeline_config.app_name .. " v" .. pipeline_config.version)
                    log.info("  üåç Ambientes: " .. table.concat({"development", "staging", "production"}, ", "))
                    log.info("  üìä Total de etapas: " .. metrics.total_stages)
                    
                    return true, "Environment configured"
                end
            },
            
            {
                name = "validate_tools_and_dependencies",
                description = "Valida ferramentas e depend√™ncias necess√°rias",
                depends_on = "setup_pipeline_environment",
                command = function()
                    log.info("üîß Validando ferramentas e depend√™ncias...")
                    
                    local tools = state.get("required_tools")
                    local validation_results = {}
                    
                    -- Verificar Node.js
                    log.info("üì¶ Verificando Node.js...")
                    local node_check = exec.run("node --version")
                    if node_check.success then
                        local node_version = string.gsub(node_check.stdout, "v", "")
                        log.info("  ‚úÖ Node.js " .. string.gsub(node_version, "\n", "") .. " encontrado")
                        validation_results.node = true
                    else
                        log.error("  ‚ùå Node.js n√£o encontrado")
                        validation_results.node = false
                    end
                    
                    -- Verificar npm
                    log.info("üì¶ Verificando npm...")
                    local npm_check = exec.run("npm --version")
                    if npm_check.success then
                        log.info("  ‚úÖ npm " .. string.gsub(npm_check.stdout, "\n", "") .. " encontrado")
                        validation_results.npm = true
                    else
                        log.error("  ‚ùå npm n√£o encontrado")
                        validation_results.npm = false
                    end
                    
                    -- Verificar Docker
                    log.info("üê≥ Verificando Docker...")
                    local docker_check = exec.run("docker --version")
                    if docker_check.success then
                        log.info("  ‚úÖ Docker encontrado")
                        validation_results.docker = true
                        
                        -- Verificar se Docker daemon est√° rodando
                        local docker_info = exec.run("docker info")
                        if docker_info.success then
                            log.info("  ‚úÖ Docker daemon est√° rodando")
                        else
                            log.error("  ‚ùå Docker daemon n√£o est√° rodando")
                            validation_results.docker = false
                        end
                    else
                        log.error("  ‚ùå Docker n√£o encontrado")
                        validation_results.docker = false
                    end
                    
                    -- Verificar Git
                    log.info("üîÑ Verificando Git...")
                    local git_check = exec.run("git --version")
                    if git_check.success then
                        log.info("  ‚úÖ Git encontrado")
                        validation_results.git = true
                    else
                        log.error("  ‚ùå Git n√£o encontrado")
                        validation_results.git = false
                    end
                    
                    -- Verificar conectividade de rede
                    log.info("üåê Verificando conectividade de rede...")
                    local http = require("http")
                    local connectivity_check = http.get({
                        url = "https://registry.npmjs.org/-/ping",
                        timeout = 10
                    })
                    
                    if connectivity_check.success then
                        log.info("  ‚úÖ Conectividade com npm registry OK")
                        validation_results.network = true
                    else
                        log.error("  ‚ùå Problemas de conectividade: " .. connectivity_check.error)
                        validation_results.network = false
                    end
                    
                    state.set("tool_validation", validation_results)
                    
                    -- Verificar se todas as ferramentas essenciais est√£o dispon√≠veis
                    local essential_tools = {"node", "npm", "docker", "git", "network"}
                    local missing_tools = {}
                    
                    for _, tool in ipairs(essential_tools) do
                        if not validation_results[tool] then
                            table.insert(missing_tools, tool)
                        end
                    end
                    
                    if #missing_tools > 0 then
                        log.error("‚ùå Ferramentas essenciais faltando: " .. table.concat(missing_tools, ", "))
                        return false, "Missing essential tools"
                    end
                    
                    log.info("‚úÖ Todas as ferramentas necess√°rias est√£o dispon√≠veis!")
                    
                    return true, "Tools validated"
                end
            },
            
            {
                name = "checkout_and_prepare_code",
                description = "Faz checkout do c√≥digo e prepara ambiente",
                depends_on = "validate_tools_and_dependencies",
                command = function()
                    log.info("üì• Fazendo checkout do c√≥digo...")
                    
                    local config = state.get("pipeline_config")
                    local app_dir = "./" .. config.app_name
                    
                    -- Simular checkout (em produ√ß√£o real, usaria git clone)
                    if not fs.exists(app_dir) then
                        fs.mkdir(app_dir)
                    end
                    
                    -- Criar estrutura b√°sica de uma app Node.js
                    log.info("üèóÔ∏è  Criando estrutura da aplica√ß√£o...")
                    
                    -- package.json
                    local package_json = {
                        name = config.app_name,
                        version = config.version,
                        description = "Demo Node.js application for CI/CD pipeline",
                        main = "index.js",
                        scripts = {
                            start = "node index.js",
                            test = "jest",
                            ["test:unit"] = "jest --testPathPattern=unit",
                            ["test:integration"] = "jest --testPathPattern=integration",
                            ["test:coverage"] = "jest --coverage",
                            lint = "eslint .",
                            ["lint:fix"] = "eslint . --fix",
                            build = "npm run lint && npm run test"
                        },
                        dependencies = {
                            express = "^4.18.0",
                            cors = "^2.8.5",
                            helmet = "^6.0.0",
                            dotenv = "^16.0.0"
                        },
                        devDependencies = {
                            jest = "^29.0.0",
                            supertest = "^6.2.0",
                            eslint = "^8.0.0",
                            nodemon = "^2.0.0"
                        },
                        engines = {
                            node = ">=18.0.0",
                            npm = ">=8.0.0"
                        }
                    }
                    
                    fs.write(app_dir .. "/package.json", data.to_json(package_json))
                    
                    -- index.js
                    local index_js = [[
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
require('dotenv').config();

const app = express();
const port = process.env.PORT || 3000;

app.use(helmet());
app.use(cors());
app.use(express.json());

app.get('/', (req, res) => {
  res.json({
    message: 'Hello from Node.js CI/CD Demo!',
    version: process.env.npm_package_version || '1.0.0',
    environment: process.env.NODE_ENV || 'development',
    timestamp: new Date().toISOString()
  });
});

app.get('/health', (req, res) => {
  res.json({ status: 'healthy', uptime: process.uptime() });
});

app.listen(port, () => {
  console.log(`Server running on port ${port}`);
});

module.exports = app;
]]
                    
                    fs.write(app_dir .. "/index.js", index_js)
                    
                    -- Dockerfile
                    local dockerfile = [[
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production

COPY . .

USER node

EXPOSE 3000

HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

CMD ["npm", "start"]
]]
                    
                    fs.write(app_dir .. "/Dockerfile", dockerfile)
                    
                    -- .dockerignore
                    local dockerignore = [[
node_modules
npm-debug.log
coverage
.nyc_output
.git
.gitignore
README.md
.env
.DS_Store
]]
                    
                    fs.write(app_dir .. "/.dockerignore", dockerignore)
                    
                    -- Simular testes
                    fs.mkdir(app_dir .. "/tests")
                    
                    local test_file = [[
const request = require('supertest');
const app = require('../index');

describe('API Endpoints', () => {
  test('GET / should return welcome message', async () => {
    const response = await request(app)
      .get('/')
      .expect(200);
    
    expect(response.body.message).toBe('Hello from Node.js CI/CD Demo!');
  });

  test('GET /health should return health status', async () => {
    const response = await request(app)
      .get('/health')
      .expect(200);
    
    expect(response.body.status).toBe('healthy');
  });
});
]]
                    
                    fs.write(app_dir .. "/tests/app.test.js", test_file)
                    
                    -- Salvar informa√ß√µes do projeto
                    state.set("app_directory", app_dir)
                    
                    log.info("‚úÖ C√≥digo preparado:")
                    log.info("  üìÅ Diret√≥rio: " .. app_dir)
                    log.info("  üì¶ package.json criado")
                    log.info("  üê≥ Dockerfile criado")
                    log.info("  üß™ Testes criados")
                    
                    return true, "Code prepared"
                end
            },
            
            {
                name = "install_dependencies_and_build",
                description = "Instala depend√™ncias e executa build",
                depends_on = "checkout_and_prepare_code",
                command = function()
                    log.info("üì¶ Instalando depend√™ncias...")
                    
                    local app_dir = state.get("app_directory")
                    local build_start = os.time()
                    
                    -- Simular npm install (em produ√ß√£o real executaria npm install)
                    log.info("üì• Simulando npm install...")
                    exec.run("sleep 2") -- Simular tempo de instala√ß√£o
                    
                    -- Criar node_modules fake para simular instala√ß√£o
                    local node_modules_dir = app_dir .. "/node_modules"
                    if not fs.exists(node_modules_dir) then
                        fs.mkdir(node_modules_dir)
                    end
                    
                    -- Simular cria√ß√£o de alguns m√≥dulos importantes
                    local fake_modules = {"express", "jest", "eslint", "cors", "helmet"}
                    for _, module in ipairs(fake_modules) do
                        local module_dir = node_modules_dir .. "/" .. module
                        fs.mkdir(module_dir)
                        fs.write(module_dir .. "/package.json", '{"name": "' .. module .. '", "version": "1.0.0"}')
                    end
                    
                    log.info("‚úÖ Depend√™ncias instaladas")
                    
                    -- Simular linting
                    log.info("üîç Executando linting...")
                    exec.run("sleep 1")
                    
                    -- Simular alguns warnings de lint (real√≠stico)
                    local lint_warnings = {
                        "index.js:15:1 - Warning: Missing semicolon",
                        "index.js:23:5 - Warning: Unused variable 'temp'"
                    }
                    
                    log.info("‚ö†Ô∏è  Lint warnings encontrados:")
                    for _, warning in ipairs(lint_warnings) do
                        log.info("  " .. warning)
                    end
                    log.info("‚úÖ Linting conclu√≠do (warnings n√£o bloqueiam build)")
                    
                    local build_end = os.time()
                    local build_duration = build_end - build_start
                    
                    -- Atualizar m√©tricas
                    local metrics = state.get("pipeline_metrics")
                    metrics.build_duration = build_duration
                    metrics.stages_completed = metrics.stages_completed + 1
                    state.set("pipeline_metrics", metrics)
                    
                    log.info("‚úÖ Build conclu√≠do em " .. build_duration .. " segundos")
                    
                    return true, "Build completed"
                end
            },
            
            {
                name = "run_tests_and_generate_coverage",
                description = "Executa testes unit√°rios e de integra√ß√£o com coverage",
                depends_on = "install_dependencies_and_build",
                command = function()
                    log.info("üß™ Executando testes...")
                    
                    local metrics = state.get("pipeline_metrics")
                    local app_dir = state.get("app_directory")
                    
                    -- Simular execu√ß√£o de testes unit√°rios
                    log.info("üìã Executando testes unit√°rios...")
                    exec.run("sleep 2")
                    
                    local unit_tests = {
                        {name = "API Endpoints - GET /", status = "passed", duration = "120ms"},
                        {name = "API Endpoints - GET /health", status = "passed", duration = "85ms"},
                        {name = "Express App Initialization", status = "passed", duration = "45ms"},
                        {name = "Error Handling Middleware", status = "passed", duration = "95ms"},
                        {name = "CORS Configuration", status = "passed", duration = "65ms"}
                    }
                    
                    log.info("üìä Resultados dos testes unit√°rios:")
                    local unit_passed = 0
                    for _, test in ipairs(unit_tests) do
                        local status_icon = test.status == "passed" and "‚úÖ" or "‚ùå"
                        log.info("  " .. status_icon .. " " .. test.name .. " (" .. test.duration .. ")")
                        if test.status == "passed" then
                            unit_passed = unit_passed + 1
                        end
                    end
                    
                    -- Simular testes de integra√ß√£o
                    log.info("\nüîÑ Executando testes de integra√ß√£o...")
                    exec.run("sleep 3")
                    
                    local integration_tests = {
                        {name = "Database Connection", status = "passed", duration = "250ms"},
                        {name = "External API Integration", status = "passed", duration = "180ms"},
                        {name = "Authentication Flow", status = "passed", duration = "320ms"}
                    }
                    
                    log.info("üìä Resultados dos testes de integra√ß√£o:")
                    local integration_passed = 0
                    for _, test in ipairs(integration_tests) do
                        local status_icon = test.status == "passed" and "‚úÖ" or "‚ùå"
                        log.info("  " .. status_icon .. " " .. test.name .. " (" .. test.duration .. ")")
                        if test.status == "passed" then
                            integration_passed = integration_passed + 1
                        end
                    end
                    
                    -- Simular coverage report
                    log.info("\nüìà Gerando relat√≥rio de cobertura...")
                    exec.run("sleep 1")
                    
                    local coverage_data = {
                        statements = 92.5,
                        branches = 88.3,
                        functions = 95.2,
                        lines = 91.8
                    }
                    
                    log.info("üìä Cobertura de c√≥digo:")
                    log.info("  üìÑ Statements: " .. coverage_data.statements .. "%")
                    log.info("  üåø Branches: " .. coverage_data.branches .. "%") 
                    log.info("  üîß Functions: " .. coverage_data.functions .. "%")
                    log.info("  üìù Lines: " .. coverage_data.lines .. "%")
                    
                    -- Verificar se a cobertura atende aos crit√©rios
                    local min_coverage = 85
                    local avg_coverage = (coverage_data.statements + coverage_data.branches + 
                                        coverage_data.functions + coverage_data.lines) / 4
                    
                    if avg_coverage >= min_coverage then
                        log.info("‚úÖ Cobertura de c√≥digo atende aos crit√©rios (>=" .. min_coverage .. "%)")
                    else
                        log.error("‚ùå Cobertura insuficiente: " .. string.format("%.1f", avg_coverage) .. "% < " .. min_coverage .. "%")
                        return false, "Coverage below threshold"
                    end
                    
                    -- Gerar relat√≥rio de testes
                    local test_report = {
                        timestamp = os.date("%Y-%m-%d %H:%M:%S"),
                        unit_tests = {
                            total = #unit_tests,
                            passed = unit_passed,
                            failed = #unit_tests - unit_passed
                        },
                        integration_tests = {
                            total = #integration_tests,
                            passed = integration_passed,
                            failed = #integration_tests - integration_passed
                        },
                        coverage = coverage_data,
                        overall_status = "passed"
                    }
                    
                    fs.write(app_dir .. "/test-report.json", data.to_json(test_report))
                    
                    -- Atualizar m√©tricas
                    metrics.tests_run = #unit_tests + #integration_tests
                    metrics.tests_passed = unit_passed + integration_passed
                    metrics.stages_completed = metrics.stages_completed + 1
                    state.set("pipeline_metrics", metrics)
                    state.set("test_report", test_report)
                    
                    log.info("‚úÖ Todos os testes passaram!")
                    log.info("üìä " .. metrics.tests_passed .. "/" .. metrics.tests_run .. " testes executados com sucesso")
                    
                    return true, "Tests completed"
                end
            },
            
            {
                name = "build_and_push_docker_image",
                description = "Constr√≥i e publica imagem Docker",
                depends_on = "run_tests_and_generate_coverage",
                command = function()
                    log.info("üê≥ Construindo imagem Docker...")
                    
                    local config = state.get("pipeline_config")
                    local app_dir = state.get("app_directory")
                    local image_tag = config.docker_registry .. "/" .. config.app_name .. ":" .. config.version
                    local latest_tag = config.docker_registry .. "/" .. config.app_name .. ":latest"
                    
                    -- Simular docker build
                    log.info("üèóÔ∏è  Executando docker build...")
                    log.info("üìù Image tag: " .. image_tag)
                    
                    exec.run("sleep 3") -- Simular tempo de build
                    
                    local docker = require("docker")
                    
                    -- Em produ√ß√£o real, executaria:
                    -- docker.build({tag = image_tag, path = app_dir})
                    -- Por ora, simular o build
                    
                    log.info("‚úÖ Imagem Docker constru√≠da")
                    
                    -- Simular scan de seguran√ßa da imagem
                    log.info("üîí Executando scan de seguran√ßa da imagem...")
                    exec.run("sleep 2")
                    
                    local security_scan = {
                        vulnerabilities = {
                            critical = 0,
                            high = 1,
                            medium = 3,
                            low = 5
                        },
                        scan_status = "passed" -- passed se n√£o h√° critical/high cr√≠ticas
                    }
                    
                    log.info("üõ°Ô∏è  Resultados do scan de seguran√ßa:")
                    log.info("  üî¥ Critical: " .. security_scan.vulnerabilities.critical)
                    log.info("  üü† High: " .. security_scan.vulnerabilities.high)
                    log.info("  üü° Medium: " .. security_scan.vulnerabilities.medium)
                    log.info("  üü¢ Low: " .. security_scan.vulnerabilities.low)
                    
                    if security_scan.vulnerabilities.critical > 0 then
                        log.error("‚ùå Vulnerabilidades cr√≠ticas encontradas!")
                        return false, "Critical security vulnerabilities found"
                    end
                    
                    if security_scan.vulnerabilities.high > 2 then
                        log.error("‚ùå Muitas vulnerabilidades high encontradas!")
                        return false, "Too many high security vulnerabilities"
                    end
                    
                    log.info("‚úÖ Scan de seguran√ßa aprovado")
                    
                    -- Simular push da imagem
                    log.info("üì§ Fazendo push da imagem para registry...")
                    exec.run("sleep 2")
                    
                    -- Em produ√ß√£o real:
                    -- docker.exec({"push", image_tag})
                    -- docker.exec({"push", latest_tag})
                    
                    log.info("‚úÖ Imagem publicada no registry:")
                    log.info("  üì¶ " .. image_tag)
                    log.info("  üì¶ " .. latest_tag)
                    
                    -- Salvar info da imagem
                    local image_info = {
                        tag = image_tag,
                        latest_tag = latest_tag,
                        size = "145MB",
                        layers = 8,
                        security_scan = security_scan,
                        build_time = os.time()
                    }
                    
                    state.set("docker_image", image_info)
                    
                    local metrics = state.get("pipeline_metrics")
                    metrics.stages_completed = metrics.stages_completed + 1
                    state.set("pipeline_metrics", metrics)
                    
                    return true, "Docker image built and pushed"
                end
            },
            
            {
                name = "deploy_to_staging",
                description = "Deploy para ambiente de staging",
                depends_on = "build_and_push_docker_image",
                command = function()
                    log.info("üöÄ Fazendo deploy para STAGING...")
                    
                    local config = state.get("pipeline_config")
                    local image_info = state.get("docker_image")
                    local staging_config = config.environments.staging
                    local deploy_start = os.time()
                    
                    -- Simular deploy usando Kubernetes/Helm
                    log.info("‚ò∏Ô∏è  Aplicando manifesto Kubernetes...")
                    
                    -- Criar manifesto K8s simplificado
                    local k8s_manifest = {
                        apiVersion = "apps/v1",
                        kind = "Deployment",
                        metadata = {
                            name = config.app_name .. "-staging",
                            namespace = "staging"
                        },
                        spec = {
                            replicas = staging_config.replicas,
                            selector = {
                                matchLabels = {
                                    app = config.app_name,
                                    environment = "staging"
                                }
                            },
                            template = {
                                metadata = {
                                    labels = {
                                        app = config.app_name,
                                        environment = "staging",
                                        version = config.version
                                    }
                                },
                                spec = {
                                    containers = {{
                                        name = config.app_name,
                                        image = image_info.tag,
                                        ports = {{containerPort = 3000}},
                                        resources = {
                                            requests = staging_config.resources,
                                            limits = {
                                                cpu = "400m",
                                                memory = "512Mi"
                                            }
                                        },
                                        env = {{
                                            name = "NODE_ENV",
                                            value = "staging"
                                        }},
                                        readinessProbe = {
                                            httpGet = {
                                                path = "/health",
                                                port = 3000
                                            },
                                            initialDelaySeconds = 10
                                        }
                                    }}
                                }
                            }
                        }
                    }
                    
                    -- Salvar manifesto
                    local app_dir = state.get("app_directory")
                    fs.write(app_dir .. "/k8s-staging.yaml", data.to_json(k8s_manifest))
                    
                    -- Simular aplica√ß√£o do manifesto
                    exec.run("sleep 3")
                    log.info("‚úÖ Manifesto Kubernetes aplicado")
                    
                    -- Simular espera pelo rollout
                    log.info("‚è≥ Aguardando rollout do deployment...")
                    exec.run("sleep 5")
                    
                    -- Verificar health dos pods
                    log.info("üè• Verificando sa√∫de dos pods...")
                    local pods_healthy = true
                    local pod_status = {
                        {name = config.app_name .. "-staging-5f6d7c8b9-abc12", status = "Running", ready = true},
                        {name = config.app_name .. "-staging-5f6d7c8b9-def34", status = "Running", ready = true}
                    }
                    
                    for _, pod in ipairs(pod_status) do
                        local status_icon = pod.ready and "‚úÖ" or "‚ùå"
                        log.info("  " .. status_icon .. " " .. pod.name .. " - " .. pod.status)
                        if not pod.ready then
                            pods_healthy = false
                        end
                    end
                    
                    if not pods_healthy then
                        log.error("‚ùå Alguns pods n√£o est√£o healthy")
                        return false, "Unhealthy pods in staging"
                    end
                    
                    -- Smoke tests no staging
                    log.info("üí® Executando smoke tests no staging...")
                    local http = require("http")
                    
                    local smoke_tests = {
                        {
                            name = "Health Check",
                            url = "https://" .. staging_config.domain .. "/health",
                            expected_status = 200
                        },
                        {
                            name = "Main Endpoint",
                            url = "https://" .. staging_config.domain .. "/",
                            expected_status = 200
                        }
                    }
                    
                    for _, test in ipairs(smoke_tests) do
                        -- Simular requisi√ß√£o HTTP
                        exec.run("sleep 1")
                        
                        -- Em produ√ß√£o real:
                        -- local result = http.get({url = test.url, timeout = 10})
                        -- Por ora, simular sucesso
                        log.info("  ‚úÖ " .. test.name .. " - Status 200 OK")
                    end
                    
                    local deploy_end = os.time()
                    local deploy_duration = deploy_end - deploy_start
                    
                    -- Salvar info do deploy
                    local staging_deployment = {
                        environment = "staging",
                        version = config.version,
                        image = image_info.tag,
                        replicas = staging_config.replicas,
                        domain = staging_config.domain,
                        deploy_time = os.time(),
                        deploy_duration = deploy_duration,
                        health_status = "healthy"
                    }
                    
                    state.set("staging_deployment", staging_deployment)
                    
                    log.info("‚úÖ Deploy para staging conclu√≠do!")
                    log.info("  üåç URL: https://" .. staging_config.domain)
                    log.info("  ‚è±Ô∏è  Tempo de deploy: " .. deploy_duration .. " segundos")
                    log.info("  üîÑ R√©plicas: " .. staging_config.replicas)
                    
                    local metrics = state.get("pipeline_metrics")
                    metrics.deploy_duration = metrics.deploy_duration + deploy_duration
                    metrics.stages_completed = metrics.stages_completed + 1
                    state.set("pipeline_metrics", metrics)
                    
                    return true, "Deployed to staging"
                end
            },
            
            {
                name = "run_staging_tests",
                description = "Executa testes automatizados no ambiente de staging",
                depends_on = "deploy_to_staging",
                command = function()
                    log.info("üß™ Executando testes automatizados no staging...")
                    
                    local config = state.get("pipeline_config")
                    local staging_config = config.environments.staging
                    
                    -- Testes de aceita√ß√£o automatizados
                    log.info("ü§ñ Executando testes de aceita√ß√£o...")
                    
                    local acceptance_tests = {
                        {
                            name = "User Registration Flow",
                            steps = {"Open app", "Fill form", "Submit", "Verify confirmation"},
                            status = "passed",
                            duration = "2.3s"
                        },
                        {
                            name = "API Authentication",
                            steps = {"Request token", "Use token", "Refresh token"},
                            status = "passed", 
                            duration = "1.8s"
                        },
                        {
                            name = "Database Operations",
                            steps = {"Create record", "Read record", "Update record", "Delete record"},
                            status = "passed",
                            duration = "3.1s"
                        }
                    }
                    
                    exec.run("sleep 4") -- Simular execu√ß√£o dos testes
                    
                    local acceptance_passed = 0
                    for _, test in ipairs(acceptance_tests) do
                        local status_icon = test.status == "passed" and "‚úÖ" or "‚ùå"
                        log.info("  " .. status_icon .. " " .. test.name .. " (" .. test.duration .. ")")
                        if test.status == "passed" then
                            acceptance_passed = acceptance_passed + 1
                        end
                    end
                    
                    -- Testes de performance
                    log.info("\n‚ö° Executando testes de performance...")
                    exec.run("sleep 3")
                    
                    local performance_results = {
                        response_time_avg = "120ms",
                        response_time_p95 = "250ms", 
                        response_time_p99 = "480ms",
                        requests_per_second = 850,
                        error_rate = "0.02%",
                        memory_usage_avg = "180MB",
                        cpu_usage_avg = "15%"
                    }
                    
                    log.info("üìà Resultados de performance:")
                    log.info("  ‚è±Ô∏è  Tempo m√©dio de resposta: " .. performance_results.response_time_avg)
                    log.info("  üìä P95: " .. performance_results.response_time_p95)
                    log.info("  üìä P99: " .. performance_results.response_time_p99)
                    log.info("  üöÄ RPS: " .. performance_results.requests_per_second)
                    log.info("  ‚ùå Taxa de erro: " .. performance_results.error_rate)
                    log.info("  üíæ Uso de mem√≥ria: " .. performance_results.memory_usage_avg)
                    log.info("  üñ•Ô∏è  Uso de CPU: " .. performance_results.cpu_usage_avg)
                    
                    -- Verificar SLAs
                    local sla_checks = {
                        {metric = "Response Time P95", value = 250, threshold = 300, unit = "ms"},
                        {metric = "Error Rate", value = 0.02, threshold = 0.1, unit = "%"},
                        {metric = "CPU Usage", value = 15, threshold = 70, unit = "%"},
                        {metric = "Memory Usage", value = 180, threshold = 400, unit = "MB"}
                    }
                    
                    local sla_violations = {}
                    log.info("\nüìã Verifica√ß√£o de SLAs:")
                    for _, check in ipairs(sla_checks) do
                        if check.value <= check.threshold then
                            log.info("  ‚úÖ " .. check.metric .. ": " .. check.value .. check.unit .. " ‚â§ " .. check.threshold .. check.unit)
                        else
                            log.info("  ‚ùå " .. check.metric .. ": " .. check.value .. check.unit .. " > " .. check.threshold .. check.unit)
                            table.insert(sla_violations, check.metric)
                        end
                    end
                    
                    if #sla_violations > 0 then
                        log.error("‚ùå SLA violations encontrados: " .. table.concat(sla_violations, ", "))
                        return false, "SLA violations in staging tests"
                    end
                    
                    -- Gerar relat√≥rio de testes de staging
                    local staging_test_report = {
                        timestamp = os.date("%Y-%m-%d %H:%M:%S"),
                        environment = "staging",
                        acceptance_tests = {
                            total = #acceptance_tests,
                            passed = acceptance_passed,
                            failed = #acceptance_tests - acceptance_passed
                        },
                        performance = performance_results,
                        sla_compliance = true,
                        overall_status = "passed"
                    }
                    
                    local app_dir = state.get("app_directory")
                    fs.write(app_dir .. "/staging-test-report.json", data.to_json(staging_test_report))
                    
                    state.set("staging_test_report", staging_test_report)
                    
                    log.info("‚úÖ Todos os testes de staging passaram!")
                    log.info("üìä " .. acceptance_passed .. "/" .. #acceptance_tests .. " testes de aceita√ß√£o OK")
                    log.info("‚ö° Performance dentro dos SLAs")
                    
                    local metrics = state.get("pipeline_metrics")
                    metrics.stages_completed = metrics.stages_completed + 1
                    state.set("pipeline_metrics", metrics)
                    
                    return true, "Staging tests completed"
                end
            },
            
            {
                name = "generate_pipeline_report",
                description = "Gera relat√≥rio completo do pipeline",
                depends_on = "run_staging_tests",
                command = function()
                    log.info("üìä Gerando relat√≥rio final do pipeline...")
                    
                    local config = state.get("pipeline_config")
                    local metrics = state.get("pipeline_metrics")
                    local test_report = state.get("test_report")
                    local staging_deployment = state.get("staging_deployment")
                    local staging_test_report = state.get("staging_test_report")
                    local docker_image = state.get("docker_image")
                    
                    local pipeline_end = os.time()
                    local total_duration = pipeline_end - metrics.pipeline_start_time
                    
                    -- Calcular estat√≠sticas
                    local success_rate = (metrics.stages_completed / metrics.total_stages) * 100
                    
                    local final_report = {
                        pipeline_id = "pipeline-" .. os.time(),
                        timestamp = os.date("%Y-%m-%d %H:%M:%S"),
                        application = {
                            name = config.app_name,
                            version = config.version,
                            git_repo = config.git_repo
                        },
                        execution = {
                            total_duration = total_duration,
                            stages_completed = metrics.stages_completed,
                            total_stages = metrics.total_stages,
                            success_rate = success_rate,
                            build_duration = metrics.build_duration,
                            deploy_duration = metrics.deploy_duration
                        },
                        quality_metrics = {
                            tests_executed = metrics.tests_run,
                            tests_passed = metrics.tests_passed,
                            code_coverage = test_report.coverage,
                            security_scan = docker_image.security_scan
                        },
                        deployments = {
                            staging = staging_deployment
                        },
                        artifacts = {
                            docker_image = docker_image.tag,
                            test_reports = {"test-report.json", "staging-test-report.json"},
                            k8s_manifests = {"k8s-staging.yaml"}
                        },
                        next_steps = {
                            "Manual approval required for production deployment",
                            "Performance monitoring in staging",
                            "Security scan results review"
                        }
                    }
                    
                    -- Criar relat√≥rio detalhado
                    local report_content = string.format([[
üöÄ Pipeline CI/CD - Relat√≥rio de Execu√ß√£o
========================================

üìÖ Data/Hora: %s
üè∑Ô∏è  Pipeline ID: %s

üì± Aplica√ß√£o:
- Nome: %s
- Vers√£o: %s
- Reposit√≥rio: %s

‚è±Ô∏è  Execu√ß√£o:
- Dura√ß√£o Total: %d segundos (%.1f minutos)
- Etapas Conclu√≠das: %d/%d (%.1f%%)
- Tempo de Build: %d segundos
- Tempo de Deploy: %d segundos

üß™ Qualidade:
- Testes Executados: %d
- Testes Aprovados: %d
- Taxa de Sucesso: %.1f%%
- Cobertura de C√≥digo: %.1f%%

üê≥ Artifacts:
- Imagem Docker: %s
- Tamanho da Imagem: %s
- Vulnerabilidades: %d cr√≠ticas, %d high

üöÄ Deployments:
- Staging: ‚úÖ %s (%d r√©plicas)

üìä M√©tricas de Performance (Staging):
- Response Time P95: %s
- RPS: %d
- Error Rate: %s
- Memory Usage: %s

‚úÖ Status: PIPELINE EXECUTADO COM SUCESSO

üéØ Pr√≥ximos Passos:
%s

üìà Recomenda√ß√µes:
- ‚úÖ Todos os testes passaram
- ‚úÖ Cobertura de c√≥digo adequada
- ‚úÖ Scan de seguran√ßa aprovado
- ‚úÖ Performance dentro dos SLAs
- ‚úÖ Deploy em staging bem-sucedido

üîÑ Pronto para deploy em produ√ß√£o (requer aprova√ß√£o manual)
]],
                        final_report.timestamp,
                        final_report.pipeline_id,
                        final_report.application.name,
                        final_report.application.version,
                        final_report.application.git_repo,
                        final_report.execution.total_duration,
                        final_report.execution.total_duration / 60,
                        final_report.execution.stages_completed,
                        final_report.execution.total_stages,
                        final_report.execution.success_rate,
                        final_report.execution.build_duration,
                        final_report.execution.deploy_duration,
                        final_report.quality_metrics.tests_executed,
                        final_report.quality_metrics.tests_passed,
                        (final_report.quality_metrics.tests_passed / final_report.quality_metrics.tests_executed) * 100,
                        (test_report.coverage.statements + test_report.coverage.branches + 
                         test_report.coverage.functions + test_report.coverage.lines) / 4,
                        final_report.artifacts.docker_image,
                        docker_image.size,
                        docker_image.security_scan.vulnerabilities.critical,
                        docker_image.security_scan.vulnerabilities.high,
                        staging_deployment.domain,
                        staging_deployment.replicas,
                        staging_test_report.performance.response_time_p95,
                        staging_test_report.performance.requests_per_second,
                        staging_test_report.performance.error_rate,
                        staging_test_report.performance.memory_usage_avg,
                        table.concat(final_report.next_steps, "\n")
                    )
                    
                    local app_dir = state.get("app_directory")
                    fs.write(app_dir .. "/pipeline-report.md", report_content)
                    fs.write(app_dir .. "/pipeline-report.json", data.to_json(final_report))
                    
                    state.set("final_pipeline_report", final_report)
                    
                    log.info("üìà Pipeline Report Summary:")
                    log.info("  ‚è±Ô∏è  Total Duration: " .. total_duration .. " segundos")
                    log.info("  ‚úÖ Success Rate: " .. string.format("%.1f", success_rate) .. "%")
                    log.info("  üß™ Tests Passed: " .. metrics.tests_passed .. "/" .. metrics.tests_run)
                    log.info("  üöÄ Staging Deploy: SUCCESS")
                    log.info("  üìÑ Relat√≥rio: pipeline-report.md")
                    
                    log.info("\nüéâ PIPELINE CI/CD CONCLU√çDO COM SUCESSO!")
                    log.info("‚ú® Aplica√ß√£o pronta para deploy em produ√ß√£o")
                    
                    return true, "Pipeline completed successfully"
                end
            }
        }
    }
}