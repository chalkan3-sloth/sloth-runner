-- GitOps Avan√ßado - Integra√ß√£o com Kubernetes
-- Demonstra GitOps com deploymens reais, health checks e rollbacks inteligentes

local gitops = require("gitops")
local log = require("log")
local exec = require("exec")

log.info("üöÄ GitOps Avan√ßado - Kubernetes Integration")
log.info("=" .. string.rep("=", 60))

-- Configura√ß√£o de m√∫ltiplos ambientes
local environments = {
    {
        name = "development",
        repo = "https://github.com/company/k8s-dev",
        branch = "develop",
        namespace = "dev",
        auto_sync = true,
        sync_interval = "5m"
    },
    {
        name = "staging", 
        repo = "https://github.com/company/k8s-staging",
        branch = "staging",
        namespace = "staging",
        auto_sync = true,
        sync_interval = "10m"
    },
    {
        name = "production",
        repo = "https://github.com/company/k8s-prod",
        branch = "main",
        namespace = "production",
        auto_sync = false,  -- Manual deploys em produ√ß√£o
        sync_interval = "never"
    }
}

-- Fun√ß√£o para criar pipeline GitOps por ambiente
local function setup_environment_gitops(env)
    log.info("üèóÔ∏è Configurando GitOps para " .. env.name .. "...")
    
    -- Registrar reposit√≥rio
    local repo_id = gitops.register_repository({
        id = env.name .. "-repo",
        url = env.repo,
        branch = env.branch
    })
    
    if not repo_id then
        log.error("‚ùå Falha ao registrar reposit√≥rio " .. env.name)
        return nil
    end
    
    -- Criar workflow GitOps
    local workflow_id = gitops.create_workflow({
        id = env.name .. "-workflow",
        name = env.name .. " Environment GitOps",
        repository = repo_id,
        target_path = "manifests",
        auto_sync = env.auto_sync,
        diff_preview = true,
        rollback_on_failure = true
    })
    
    if workflow_id then
        log.info("‚úÖ " .. env.name .. " GitOps configurado: " .. workflow_id)
        return workflow_id
    else
        log.error("‚ùå Falha ao criar workflow " .. env.name)
        return nil
    end
end

-- Fun√ß√£o para deployment com valida√ß√£o
local function deploy_environment(env, workflow_id, force)
    log.info("üöÄ Iniciando deployment " .. env.name .. "...")
    
    -- 1. Gerar diff preview
    log.info("üîç Analisando mudan√ßas...")
    local diff = gitops.generate_diff(workflow_id)
    
    if not diff then
        log.info("‚ÑπÔ∏è Nenhuma mudan√ßa detectada para " .. env.name)
        return true
    end
    
    -- 2. Exibir resumo das mudan√ßas
    log.info("üìä Mudan√ßas detectadas em " .. env.name .. ":")
    log.info("  üìù Total: " .. diff.summary.total_changes)
    log.info("  ‚ú® Criados: " .. diff.summary.created_resources)
    log.info("  üîÑ Atualizados: " .. diff.summary.updated_resources)
    log.info("  üóëÔ∏è Removidos: " .. diff.summary.deleted_resources)
    
    -- 3. Verificar alertas e conflitos
    if diff.summary.conflict_count > 0 then
        log.warn("‚ö†Ô∏è " .. diff.summary.conflict_count .. " conflito(s) detectado(s)!")
        for i, warning in ipairs(diff.warnings) do
            log.warn("  " .. i .. ". " .. warning)
        end
        
        if not force and env.name == "production" then
            log.error("‚ùå Deployment bloqueado por conflitos em produ√ß√£o")
            return false
        end
    end
    
    -- 4. Valida√ß√£o espec√≠fica por ambiente
    if env.name == "production" then
        -- Em produ√ß√£o, requer valida√ß√£o extra
        log.info("üîí Valida√ß√µes de produ√ß√£o...")
        
        -- Verificar se h√° mudan√ßas cr√≠ticas
        local has_critical_changes = false
        for _, change in ipairs(diff.changes) do
            if change.impact == "critical" or change.impact == "high" then
                has_critical_changes = true
                log.warn("‚ö†Ô∏è Mudan√ßa cr√≠tica: " .. change.resource .. " (" .. change.type .. ")")
            end
        end
        
        if has_critical_changes and not force then
            log.error("‚ùå Deployment bloqueado: mudan√ßas cr√≠ticas requerem aprova√ß√£o manual")
            log.info("üí° Use for√ßa (force=true) para prosseguir mesmo assim")
            return false
        end
    end
    
    -- 5. Executar sync
    log.info("üöÄ Executando sync GitOps...")
    local sync_success = gitops.sync_workflow(workflow_id)
    
    if not sync_success then
        log.error("‚ùå Sync falhou para " .. env.name)
        return false
    end
    
    -- 6. Verificar status p√≥s-deployment
    log.info("üîç Verificando status p√≥s-deployment...")
    local status = gitops.get_workflow_status(workflow_id)
    
    if status and status.last_sync_result then
        local result = status.last_sync_result
        log.info("üìä Resultado do sync:")
        log.info("  Status: " .. result.status)
        log.info("  Commit: " .. result.commit_hash)
        
        if result.metrics then
            log.info("  Dura√ß√£o: " .. result.metrics.duration)
            log.info("  Recursos aplicados: " .. result.metrics.resources_applied)
        end
        
        if result.status == "succeeded" then
            log.info("‚úÖ Deployment " .. env.name .. " realizado com sucesso!")
            return true
        else
            log.error("‚ùå Deployment " .. env.name .. " falhou: " .. (result.message or "erro desconhecido"))
            return false
        end
    end
    
    return false
end

-- Fun√ß√£o para health check p√≥s-deployment
local function health_check_environment(env, workflow_id)
    log.info("üè• Health check " .. env.name .. "...")
    
    -- Simular health checks reais (em produ√ß√£o usaria kubectl, curl, etc.)
    local checks = {
        {
            name = "Pod Readiness",
            command = "kubectl get pods -n " .. env.namespace .. " --field-selector=status.phase=Running",
            expected = "success"
        },
        {
            name = "Service Endpoints",
            command = "kubectl get endpoints -n " .. env.namespace,
            expected = "success" 
        },
        {
            name = "Ingress Status",
            command = "kubectl get ingress -n " .. env.namespace,
            expected = "success"
        }
    }
    
    local passed_checks = 0
    local total_checks = #checks
    
    for _, check in ipairs(checks) do
        log.info("üîç " .. check.name .. "...")
        
        -- Simular execu√ß√£o (em ambiente real executaria o comando)
        local success = math.random() > 0.2 -- 80% success rate
        
        if success then
            log.info("  ‚úÖ " .. check.name .. " - OK")
            passed_checks = passed_checks + 1
        else
            log.warn("  ‚ùå " .. check.name .. " - FALHA")
        end
    end
    
    local health_percentage = (passed_checks / total_checks) * 100
    log.info("üìä Health Score: " .. passed_checks .. "/" .. total_checks .. " (" .. string.format("%.1f", health_percentage) .. "%)")
    
    if health_percentage >= 80 then
        log.info("‚úÖ Environment " .. env.name .. " est√° saud√°vel")
        return true
    else
        log.warn("‚ö†Ô∏è Environment " .. env.name .. " est√° degradado")
        return false
    end
end

-- Fun√ß√£o para rollback inteligente
local function intelligent_rollback(env, workflow_id, reason)
    log.warn("üîÑ Iniciando rollback inteligente para " .. env.name .. "...")
    log.warn("üìã Motivo: " .. reason)
    
    -- Backup antes do rollback
    log.info("üíæ Criando backup do estado atual...")
    
    -- Executar rollback
    local rollback_success = gitops.rollback_workflow(workflow_id, reason)
    
    if rollback_success then
        log.info("‚úÖ Rollback executado com sucesso!")
        
        -- Verificar health ap√≥s rollback
        log.info("üîç Verificando sa√∫de p√≥s-rollback...")
        local health_ok = health_check_environment(env, workflow_id)
        
        if health_ok then
            log.info("‚úÖ Environment " .. env.name .. " restaurado com sucesso!")
            return true
        else
            log.error("‚ùå Environment ainda est√° degradado ap√≥s rollback!")
            return false
        end
    else
        log.error("‚ùå Rollback falhou para " .. env.name .. "!")
        return false
    end
end

-- Criar workflows para todos os ambientes
local env_workflows = {}

for _, env in ipairs(environments) do
    local workflow_id = setup_environment_gitops(env)
    if workflow_id then
        env_workflows[env.name] = {
            env = env,
            workflow_id = workflow_id
        }
    end
end

-- Iniciar auto-sync controller
log.info("")
log.info("üîÑ Iniciando GitOps Auto-Sync Controller...")
gitops.start_auto_sync()

-- Pipeline de deployment completo
workflow.define("gitops_kubernetes_pipeline", {
    description = "Pipeline GitOps completo com Kubernetes",
    version = "2.0.0",
    
    -- Metadados do pipeline
    metadata = {
        author = "DevOps Team",
        tags = {"gitops", "kubernetes", "production"},
        environments = {"development", "staging", "production"}
    },
    
    tasks = {
        {
            name = "deploy_development",
            description = "Deploy autom√°tico no ambiente de desenvolvimento",
            command = function(params, deps)
                local env_data = env_workflows["development"]
                if not env_data then
                    return {success = false, message = "Development environment not configured"}
                end
                
                local success = deploy_environment(env_data.env, env_data.workflow_id, true)
                
                if success then
                    health_check_environment(env_data.env, env_data.workflow_id)
                    return {success = true, message = "Development deployment completed"}
                else
                    return {success = false, message = "Development deployment failed"}
                end
            end
        },
        
        {
            name = "deploy_staging",
            description = "Deploy no ambiente de staging com valida√ß√£o",
            depends_on = {"deploy_development"},
            command = function(params, deps)
                local env_data = env_workflows["staging"]
                if not env_data then
                    return {success = false, message = "Staging environment not configured"}
                end
                
                log.info("üéØ Iniciando deployment staging...")
                
                local success = deploy_environment(env_data.env, env_data.workflow_id, false)
                
                if success then
                    local health_ok = health_check_environment(env_data.env, env_data.workflow_id)
                    
                    if health_ok then
                        return {success = true, message = "Staging deployment completed and healthy"}
                    else
                        -- Rollback autom√°tico se health check falhar
                        intelligent_rollback(env_data.env, env_data.workflow_id, "Health check failed")
                        return {success = false, message = "Staging deployment rolled back due to health issues"}
                    end
                else
                    return {success = false, message = "Staging deployment failed"}
                end
            end
        },
        
        {
            name = "production_approval",
            description = "Aprova√ß√£o manual para produ√ß√£o",
            depends_on = {"deploy_staging"},
            command = function(params, deps)
                log.info("üîí Aguardando aprova√ß√£o para produ√ß√£o...")
                log.info("üìã Staging deployment conclu√≠do com sucesso")
                log.info("üéØ Ready para produ√ß√£o!")
                
                -- Em ambiente real, aqui haveria integra√ß√£o com sistema de aprova√ß√£o
                -- Por agora, simulamos aprova√ß√£o autom√°tica
                local approved = true
                
                if approved then
                    log.info("‚úÖ Produ√ß√£o aprovada!")
                    return {success = true, message = "Production deployment approved"}
                else
                    log.warn("‚ùå Produ√ß√£o rejeitada!")
                    return {success = false, message = "Production deployment rejected"}
                end
            end
        },
        
        {
            name = "deploy_production",
            description = "Deploy em produ√ß√£o com m√°xima seguran√ßa",
            depends_on = {"production_approval"},
            command = function(params, deps)
                local env_data = env_workflows["production"]
                if not env_data then
                    return {success = false, message = "Production environment not configured"}
                end
                
                log.info("üè≠ Iniciando deployment PRODU√á√ÉO...")
                log.info("‚ö†Ô∏è M√°xima aten√ß√£o! Deploy em ambiente de produ√ß√£o!")
                
                -- Deploy com valida√ß√µes extras
                local success = deploy_environment(env_data.env, env_data.workflow_id, false)
                
                if success then
                    log.info("üîç Executando health checks cr√≠ticos...")
                    local health_ok = health_check_environment(env_data.env, env_data.workflow_id)
                    
                    if health_ok then
                        log.info("üéâ PRODU√á√ÉO DEPLOYED COM SUCESSO!")
                        return {success = true, message = "Production deployment completed successfully"}
                    else
                        log.error("üí• Health check falhou em produ√ß√£o!")
                        
                        -- Rollback imediato em produ√ß√£o
                        intelligent_rollback(env_data.env, env_data.workflow_id, "Production health check failed")
                        return {success = false, message = "Production deployment rolled back"}
                    end
                else
                    log.error("üí• Deploy produ√ß√£o falhou!")
                    return {success = false, message = "Production deployment failed"}
                end
            end
        },
        
        {
            name = "post_deployment_monitoring",
            description = "Monitoramento p√≥s-deployment",
            depends_on = {"deploy_production"},
            command = function(params, deps)
                log.info("üìä Iniciando monitoramento p√≥s-deployment...")
                
                -- Monitorar todos os ambientes
                for env_name, env_data in pairs(env_workflows) do
                    log.info("üîç Monitorando " .. env_name .. "...")
                    
                    local status = gitops.get_workflow_status(env_data.workflow_id)
                    if status then
                        log.info("  Status: " .. status.status)
                        if status.last_sync_result then
                            log.info("  Last sync: " .. status.last_sync_result.status)
                        end
                    end
                    
                    health_check_environment(env_data.env, env_data.workflow_id)
                end
                
                log.info("üìà Monitoramento conclu√≠do!")
                return {success = true, message = "Post-deployment monitoring completed"}
            end
        }
    },
    
    -- Hooks do pipeline
    on_task_start = function(task_name)
        log.info("üöÄ Iniciando task: " .. task_name)
    end,
    
    on_task_complete = function(task_name, success, output)
        if success then
            log.info("‚úÖ Task conclu√≠da: " .. task_name)
        else
            log.error("‚ùå Task falhou: " .. task_name)
            
            -- Em caso de falha, executar rollback nos ambientes j√° deployados
            if task_name == "deploy_production" then
                log.warn("üîÑ Falha cr√≠tica! Executando rollback de emerg√™ncia...")
                
                for env_name, env_data in pairs(env_workflows) do
                    if env_name ~= "development" then -- N√£o rollback dev
                        intelligent_rollback(env_data.env, env_data.workflow_id, "Emergency rollback due to production failure")
                    end
                end
            end
        end
    end,
    
    on_complete = function(success, results)
        if success then
            log.info("üéâ PIPELINE GITOPS KUBERNETES CONCLU√çDO COM SUCESSO!")
            log.info("üöÄ Todos os ambientes deployados e saud√°veis!")
            
            -- Enviar notifica√ß√µes (simulado)
            log.info("üì± Enviando notifica√ß√µes de sucesso...")
            
        else
            log.error("üí• Pipeline GitOps falhou!")
            log.error("üîç Verificar logs para detalhes dos erros")
            
            -- Alertas cr√≠ticos (simulado)
            log.error("üö® ALERTA CR√çTICO: Pipeline de produ√ß√£o falhou!")
        end
        
        -- Resumo final
        log.info("")
        log.info("üìä RESUMO FINAL:")
        log.info("üîÑ GitOps workflows ativos: " .. #gitops.list_workflows())
        log.info("üèóÔ∏è Ambientes gerenciados: " .. #environments)
        log.info("üìà Auto-sync: Ativo para dev/staging")
        log.info("üîí Produ√ß√£o: Deploy manual com valida√ß√µes")
    end
})