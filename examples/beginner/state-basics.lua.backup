-- ğŸ’¾ State Basics - Aprendendo gerenciamento de estado
-- Este exemplo demonstra como usar o sistema de estado do Sloth Runner

TaskDefinitions = {
    state_basics = {
        description = "Exemplos bÃ¡sicos de gerenciamento de estado",
        clean_workdir_after_run = true,
        
        tasks = {
            {
                name = "basic_state_operations",
                description = "OperaÃ§Ãµes bÃ¡sicas de estado (set, get, delete)",
                command = function()
                    log.info("ğŸ’¾ Demonstrando operaÃ§Ãµes bÃ¡sicas de estado...")
                    
                    -- ğŸ“ Definir valores de diferentes tipos
                    state.set("app_name", "Sloth Runner")
                    state.set("version", "1.0.0")
                    state.set("user_count", 1337)
                    state.set("is_production", false)
                    
                    -- ğŸ“š Definir estruturas complexas
                    local config = {
                        database = {
                            host = "localhost",
                            port = 5432,
                            name = "myapp"
                        },
                        features = {"auth", "api", "monitoring"},
                        limits = {
                            max_connections = 100,
                            timeout = 30
                        }
                    }
                    state.set("app_config", config)
                    
                    log.info("âœ… Valores definidos no estado!")
                    
                    -- ğŸ“– Ler valores do estado
                    local app_name = state.get("app_name")
                    local version = state.get("version")
                    local user_count = state.get("user_count")
                    local is_prod = state.get("is_production")
                    
                    log.info("ğŸ“‹ Valores lidos do estado:")
                    log.info("  App: " .. app_name .. " v" .. version)
                    log.info("  UsuÃ¡rios: " .. user_count)
                    log.info("  ProduÃ§Ã£o: " .. tostring(is_prod))
                    
                    -- ğŸ” Ler estrutura complexa
                    local saved_config = state.get("app_config")
                    log.info("  Database: " .. saved_config.database.host .. ":" .. saved_config.database.port)
                    log.info("  Features: " .. table.concat(saved_config.features, ", "))
                    
                    return true, "OperaÃ§Ãµes bÃ¡sicas de estado executadas"
                end
            },
            
            {
                name = "default_values",
                description = "Usando valores padrÃ£o quando chaves nÃ£o existem",
                depends_on = "basic_state_operations",
                command = function()
                    log.info("ğŸ¯ Demonstrando valores padrÃ£o...")
                    
                    -- ğŸ“– Tentar ler uma chave que nÃ£o existe (com padrÃ£o)
                    local theme = state.get("ui_theme", "dark")
                    local max_retries = state.get("max_retries", 3)
                    local debug_mode = state.get("debug_mode", true)
                    
                    log.info("ğŸ¨ Tema UI: " .. theme .. " (valor padrÃ£o)")
                    log.info("ğŸ”„ Max retries: " .. max_retries .. " (valor padrÃ£o)")
                    log.info("ğŸ› Debug mode: " .. tostring(debug_mode) .. " (valor padrÃ£o)")
                    
                    -- âœ… Verificar se uma chave existe
                    if state.exists("app_name") then
                        log.info("âœ… 'app_name' existe no estado")
                    end
                    
                    if not state.exists("missing_key") then
                        log.info("âŒ 'missing_key' nÃ£o existe no estado")
                    end
                    
                    return true, "Valores padrÃ£o demonstrados"
                end
            },
            
            {
                name = "state_persistence",
                description = "Demonstra que o estado persiste entre execuÃ§Ãµes",
                depends_on = "default_values",
                command = function()
                    log.info("ğŸ’¿ Demonstrando persistÃªncia de estado...")
                    
                    -- ğŸ“Š Incrementar um contador de execuÃ§Ãµes
                    local execution_count = state.get("execution_count", 0)
                    execution_count = execution_count + 1
                    state.set("execution_count", execution_count)
                    
                    log.info("ğŸ”¢ Esta Ã© a execuÃ§Ã£o nÃºmero: " .. execution_count)
                    
                    -- â° Salvar timestamp da Ãºltima execuÃ§Ã£o
                    local last_run = state.get("last_execution_time")
                    local current_time = os.time()
                    
                    if last_run then
                        local time_diff = current_time - last_run
                        log.info("â±ï¸  Tempo desde a Ãºltima execuÃ§Ã£o: " .. time_diff .. " segundos")
                    else
                        log.info("ğŸ†• Esta Ã© a primeira execuÃ§Ã£o!")
                    end
                    
                    state.set("last_execution_time", current_time)
                    
                    -- ğŸ“ Manter um log de execuÃ§Ãµes
                    local execution_log = state.get("execution_log", {})
                    table.insert(execution_log, {
                        run_number = execution_count,
                        timestamp = current_time,
                        date = os.date("%Y-%m-%d %H:%M:%S", current_time)
                    })
                    state.set("execution_log", execution_log)
                    
                    log.info("ğŸ“š Log de execuÃ§Ãµes atualizado")
                    
                    return true, "PersistÃªncia de estado demonstrada"
                end
            },
            
            {
                name = "cleanup_demo",
                description = "Demonstra como limpar dados desnecessÃ¡rios",
                depends_on = "state_persistence",
                command = function()
                    log.info("ğŸ§¹ Demonstrando limpeza de estado...")
                    
                    -- ğŸ—‚ï¸ Criar algumas chaves temporÃ¡rias
                    state.set("temp_data_1", "temporary value 1")
                    state.set("temp_data_2", "temporary value 2")
                    state.set("temp_config", {key = "value"})
                    
                    -- ğŸ” Verificar que as chaves existem
                    log.info("ğŸ“‹ Antes da limpeza:")
                    log.info("  temp_data_1 exists: " .. tostring(state.exists("temp_data_1")))
                    log.info("  temp_data_2 exists: " .. tostring(state.exists("temp_data_2")))
                    log.info("  temp_config exists: " .. tostring(state.exists("temp_config")))
                    
                    -- ğŸ—‘ï¸ Deletar chaves individuais
                    state.delete("temp_data_1")
                    log.info("ğŸ—‘ï¸  Deletada: temp_data_1")
                    
                    state.delete("temp_data_2")
                    log.info("ğŸ—‘ï¸  Deletada: temp_data_2")
                    
                    -- âœ… Verificar depois da limpeza
                    log.info("ğŸ“‹ Depois da limpeza:")
                    log.info("  temp_data_1 exists: " .. tostring(state.exists("temp_data_1")))
                    log.info("  temp_data_2 exists: " .. tostring(state.exists("temp_data_2")))
                    log.info("  temp_config exists: " .. tostring(state.exists("temp_config")))
                    
                    -- ğŸ§½ Limpar a chave restante
                    state.delete("temp_config")
                    log.info("ğŸ—‘ï¸  Deletada: temp_config")
                    
                    log.info("âœ… Limpeza concluÃ­da!")
                    
                    return true, "Limpeza de estado demonstrada"
                end
            },
            
            {
                name = "advanced_state_operations",
                description = "OperaÃ§Ãµes avanÃ§adas com estado (increment, lists, maps)",
                depends_on = "cleanup_demo",
                command = function()
                    log.info("ğŸš€ Demonstrando operaÃ§Ãµes avanÃ§adas de estado...")
                    
                    -- ğŸ”¢ OperaÃ§Ãµes numÃ©ricas
                    local counter = state.increment("download_counter", 1)
                    log.info("ğŸ“Š Downloads incrementados para: " .. counter)
                    
                    counter = state.increment("download_counter", 5)
                    log.info("ğŸ“Š Downloads incrementados para: " .. counter)
                    
                    -- ğŸ“‹ ManipulaÃ§Ã£o de listas
                    local task_queue = state.get("task_queue", {})
                    
                    -- Adicionar tarefas Ã  fila
                    local new_tasks = {"send_email", "backup_database", "update_cache"}
                    for _, task in ipairs(new_tasks) do
                        table.insert(task_queue, {
                            name = task,
                            status = "pending",
                            created = os.date("%H:%M:%S")
                        })
                    end
                    
                    state.set("task_queue", task_queue)
                    log.info("ğŸ“‹ " .. #task_queue .. " tarefas adicionadas Ã  fila")
                    
                    -- ğŸ“ˆ EstatÃ­sticas de processamento
                    local processing_stats = state.get("processing_stats", {
                        total_processed = 0,
                        successful = 0,
                        failed = 0,
                        start_time = os.time()
                    })
                    
                    processing_stats.total_processed = processing_stats.total_processed + 3
                    processing_stats.successful = processing_stats.successful + 2
                    processing_stats.failed = processing_stats.failed + 1
                    
                    state.set("processing_stats", processing_stats)
                    
                    log.info("ğŸ“ˆ EstatÃ­sticas atualizadas:")
                    log.info("  Total processado: " .. processing_stats.total_processed)
                    log.info("  Sucessos: " .. processing_stats.successful)
                    log.info("  Falhas: " .. processing_stats.failed)
                    
                    return true, "OperaÃ§Ãµes avanÃ§adas demonstradas"
                end
            },
            
            {
                name = "state_statistics_and_export",
                description = "Mostra estatÃ­sticas do estado e exporta para arquivo",
                depends_on = "advanced_state_operations",
                artifacts = {"state_export.json", "state_report.md"},
                command = function()
                    log.info("ğŸ“Š Coletando estatÃ­sticas do estado...")
                    
                    -- ğŸ“Š Obter estatÃ­sticas completas
                    local stats = state.stats()
                    log.info("ğŸ“‹ EstatÃ­sticas do Estado:")
                    log.info("  Total de chaves: " .. tostring(stats.total_keys))
                    log.info("  MemÃ³ria utilizada: " .. tostring(stats.memory_usage or 0) .. " bytes")
                    
                    -- ğŸ—‚ï¸ Coletar todos os dados do estado para export
                    local state_snapshot = {
                        metadata = {
                            export_time = os.date("%Y-%m-%d %H:%M:%S"),
                            total_keys = stats.total_keys,
                            script_name = "state-basics.lua"
                        },
                        data = {}
                    }
                    
                    -- ğŸ“ Coletar dados especÃ­ficos
                    local key_list = {
                        "app_name", "version", "user_count", "is_production",
                        "app_config", "execution_count", "last_execution_time",
                        "execution_log", "download_counter", "task_queue", "processing_stats"
                    }
                    
                    for _, key in ipairs(key_list) do
                        if state.exists(key) then
                            state_snapshot.data[key] = state.get(key)
                        end
                    end
                    
                    -- ğŸ’¾ Exportar para JSON
                    local json_export = json.encode(state_snapshot)
                    fs.write("state_export.json", json_export)
                    log.info("ğŸ’¾ Estado exportado para: state_export.json")
                    
                    -- ğŸ“„ Criar relatÃ³rio em Markdown
                    local report_content = string.format([[
# ğŸ“Š RelatÃ³rio de Estado do Sloth Runner

**Gerado em:** %s  
**Script:** state-basics.lua  
**Total de chaves:** %d

## ğŸ—ï¸ ConfiguraÃ§Ã£o da AplicaÃ§Ã£o

- **Nome:** %s
- **VersÃ£o:** %s
- **UsuÃ¡rios:** %d
- **Ambiente de ProduÃ§Ã£o:** %s

## ğŸ“ˆ EstatÃ­sticas de ExecuÃ§Ã£o

- **ExecuÃ§Ãµes totais:** %d
- **Ãšltima execuÃ§Ã£o:** %s
- **Downloads totais:** %d

## ğŸ“‹ Fila de Tarefas

Total de tarefas na fila: %d

## ğŸ“Š EstatÃ­sticas de Processamento

- **Total processado:** %d
- **Sucessos:** %d  
- **Falhas:** %d
- **Taxa de sucesso:** %.1f%%

## ğŸ’¡ PrÃ³ximos Passos

1. Execute novamente para ver a persistÃªncia do estado
2. Experimente: `sloth-runner run examples/beginner/docker-basics.lua`
3. Explore exemplos intermediÃ¡rios em `examples/intermediate/`

---
*Gerado automaticamente pelo Sloth Runner ğŸ¦¥*
]], 
                        state_snapshot.metadata.export_time,
                        state_snapshot.metadata.total_keys,
                        state.get("app_name", "N/A"),
                        state.get("version", "N/A"),
                        state.get("user_count", 0),
                        tostring(state.get("is_production", false)),
                        state.get("execution_count", 0),
                        os.date("%Y-%m-%d %H:%M:%S", state.get("last_execution_time", os.time())),
                        state.get("download_counter", 0),
                        #(state.get("task_queue", {})),
                        (state.get("processing_stats", {})).total_processed or 0,
                        (state.get("processing_stats", {})).successful or 0,
                        (state.get("processing_stats", {})).failed or 0,
                        ((state.get("processing_stats", {})).successful or 0) / math.max(((state.get("processing_stats", {})).total_processed or 1), 1) * 100
                    )
                    
                    fs.write("state_report.md", report_content)
                    log.info("ğŸ“„ RelatÃ³rio criado: state_report.md")
                    
                    -- ğŸ¯ Dicas finais
                    log.info("\nğŸ¯ Dicas do Estado:")
                    log.info("  ğŸ’¡ O estado persiste entre execuÃ§Ãµes")
                    log.info("  ğŸ’¡ Use state.exists() para verificar chaves")
                    log.info("  ğŸ’¡ state.increment() Ã© ideal para contadores")
                    log.info("  ğŸ’¡ Estruturas complexas podem ser armazenadas")
                    log.info("  ğŸ’¡ Use state.delete() para limpeza")
                    
                    return true, "RelatÃ³rio de estado criado com sucesso"
                end
            }
        }
    }
}