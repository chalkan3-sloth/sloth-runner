-- 💾 State Basics - Aprendendo gerenciamento de estado
-- Este exemplo demonstra como usar o sistema de estado do Sloth Runner

TaskDefinitions = {
    state_basics = {
        description = "Exemplos básicos de gerenciamento de estado",
        clean_workdir_after_run = true,
        
        tasks = {
            {
                name = "basic_state_operations",
                description = "Operações básicas de estado (set, get, delete)",
                command = function()
                    log.info("💾 Demonstrando operações básicas de estado...")
                    
                    -- 📝 Definir valores de diferentes tipos
                    state.set("app_name", "Sloth Runner")
                    state.set("version", "1.0.0")
                    state.set("user_count", 1337)
                    state.set("is_production", false)
                    
                    -- 📚 Definir estruturas complexas
                    local config = {
                        database = {
                            host = "localhost",
                            port = 5432,
                            name = "myapp"
                        },
                        features = {"auth", "api", "monitoring"},
                        limits = {
                            max_connections = 100,
                            timeout = 30
                        }
                    }
                    state.set("app_config", config)
                    
                    log.info("✅ Valores definidos no estado!")
                    
                    -- 📖 Ler valores do estado
                    local app_name = state.get("app_name")
                    local version = state.get("version")
                    local user_count = state.get("user_count")
                    local is_prod = state.get("is_production")
                    
                    log.info("📋 Valores lidos do estado:")
                    log.info("  App: " .. app_name .. " v" .. version)
                    log.info("  Usuários: " .. user_count)
                    log.info("  Produção: " .. tostring(is_prod))
                    
                    -- 🔍 Ler estrutura complexa
                    local saved_config = state.get("app_config")
                    log.info("  Database: " .. saved_config.database.host .. ":" .. saved_config.database.port)
                    log.info("  Features: " .. table.concat(saved_config.features, ", "))
                    
                    return true, "Operações básicas de estado executadas"
                end
            },
            
            {
                name = "default_values",
                description = "Usando valores padrão quando chaves não existem",
                depends_on = "basic_state_operations",
                command = function()
                    log.info("🎯 Demonstrando valores padrão...")
                    
                    -- 📖 Tentar ler uma chave que não existe (com padrão)
                    local theme = state.get("ui_theme", "dark")
                    local max_retries = state.get("max_retries", 3)
                    local debug_mode = state.get("debug_mode", true)
                    
                    log.info("🎨 Tema UI: " .. theme .. " (valor padrão)")
                    log.info("🔄 Max retries: " .. max_retries .. " (valor padrão)")
                    log.info("🐛 Debug mode: " .. tostring(debug_mode) .. " (valor padrão)")
                    
                    -- ✅ Verificar se uma chave existe
                    if state.exists("app_name") then
                        log.info("✅ 'app_name' existe no estado")
                    end
                    
                    if not state.exists("missing_key") then
                        log.info("❌ 'missing_key' não existe no estado")
                    end
                    
                    return true, "Valores padrão demonstrados"
                end
            },
            
            {
                name = "state_persistence",
                description = "Demonstra que o estado persiste entre execuções",
                depends_on = "default_values",
                command = function()
                    log.info("💿 Demonstrando persistência de estado...")
                    
                    -- 📊 Incrementar um contador de execuções
                    local execution_count = state.get("execution_count", 0)
                    execution_count = execution_count + 1
                    state.set("execution_count", execution_count)
                    
                    log.info("🔢 Esta é a execução número: " .. execution_count)
                    
                    -- ⏰ Salvar timestamp da última execução
                    local last_run = state.get("last_execution_time")
                    local current_time = os.time()
                    
                    if last_run then
                        local time_diff = current_time - last_run
                        log.info("⏱️  Tempo desde a última execução: " .. time_diff .. " segundos")
                    else
                        log.info("🆕 Esta é a primeira execução!")
                    end
                    
                    state.set("last_execution_time", current_time)
                    
                    -- 📝 Manter um log de execuções
                    local execution_log = state.get("execution_log", {})
                    table.insert(execution_log, {
                        run_number = execution_count,
                        timestamp = current_time,
                        date = os.date("%Y-%m-%d %H:%M:%S", current_time)
                    })
                    state.set("execution_log", execution_log)
                    
                    log.info("📚 Log de execuções atualizado")
                    
                    return true, "Persistência de estado demonstrada"
                end
            },
            
            {
                name = "cleanup_demo",
                description = "Demonstra como limpar dados desnecessários",
                depends_on = "state_persistence",
                command = function()
                    log.info("🧹 Demonstrando limpeza de estado...")
                    
                    -- 🗂️ Criar algumas chaves temporárias
                    state.set("temp_data_1", "temporary value 1")
                    state.set("temp_data_2", "temporary value 2")
                    state.set("temp_config", {key = "value"})
                    
                    -- 🔍 Verificar que as chaves existem
                    log.info("📋 Antes da limpeza:")
                    log.info("  temp_data_1 exists: " .. tostring(state.exists("temp_data_1")))
                    log.info("  temp_data_2 exists: " .. tostring(state.exists("temp_data_2")))
                    log.info("  temp_config exists: " .. tostring(state.exists("temp_config")))
                    
                    -- 🗑️ Deletar chaves individuais
                    state.delete("temp_data_1")
                    log.info("🗑️  Deletada: temp_data_1")
                    
                    state.delete("temp_data_2")
                    log.info("🗑️  Deletada: temp_data_2")
                    
                    -- ✅ Verificar depois da limpeza
                    log.info("📋 Depois da limpeza:")
                    log.info("  temp_data_1 exists: " .. tostring(state.exists("temp_data_1")))
                    log.info("  temp_data_2 exists: " .. tostring(state.exists("temp_data_2")))
                    log.info("  temp_config exists: " .. tostring(state.exists("temp_config")))
                    
                    -- 🧽 Limpar a chave restante
                    state.delete("temp_config")
                    log.info("🗑️  Deletada: temp_config")
                    
                    log.info("✅ Limpeza concluída!")
                    
                    return true, "Limpeza de estado demonstrada"
                end
            },
            
            {
                name = "advanced_state_operations",
                description = "Operações avançadas com estado (increment, lists, maps)",
                depends_on = "cleanup_demo",
                command = function()
                    log.info("🚀 Demonstrando operações avançadas de estado...")
                    
                    -- 🔢 Operações numéricas
                    local counter = state.increment("download_counter", 1)
                    log.info("📊 Downloads incrementados para: " .. counter)
                    
                    counter = state.increment("download_counter", 5)
                    log.info("📊 Downloads incrementados para: " .. counter)
                    
                    -- 📋 Manipulação de listas
                    local task_queue = state.get("task_queue", {})
                    
                    -- Adicionar tarefas à fila
                    local new_tasks = {"send_email", "backup_database", "update_cache"}
                    for _, task in ipairs(new_tasks) do
                        table.insert(task_queue, {
                            name = task,
                            status = "pending",
                            created = os.date("%H:%M:%S")
                        })
                    end
                    
                    state.set("task_queue", task_queue)
                    log.info("📋 " .. #task_queue .. " tarefas adicionadas à fila")
                    
                    -- 📈 Estatísticas de processamento
                    local processing_stats = state.get("processing_stats", {
                        total_processed = 0,
                        successful = 0,
                        failed = 0,
                        start_time = os.time()
                    })
                    
                    processing_stats.total_processed = processing_stats.total_processed + 3
                    processing_stats.successful = processing_stats.successful + 2
                    processing_stats.failed = processing_stats.failed + 1
                    
                    state.set("processing_stats", processing_stats)
                    
                    log.info("📈 Estatísticas atualizadas:")
                    log.info("  Total processado: " .. processing_stats.total_processed)
                    log.info("  Sucessos: " .. processing_stats.successful)
                    log.info("  Falhas: " .. processing_stats.failed)
                    
                    return true, "Operações avançadas demonstradas"
                end
            },
            
            {
                name = "state_statistics_and_export",
                description = "Mostra estatísticas do estado e exporta para arquivo",
                depends_on = "advanced_state_operations",
                artifacts = {"state_export.json", "state_report.md"},
                command = function()
                    log.info("📊 Coletando estatísticas do estado...")
                    
                    -- 📊 Obter estatísticas completas
                    local stats = state.stats()
                    log.info("📋 Estatísticas do Estado:")
                    log.info("  Total de chaves: " .. tostring(stats.total_keys))
                    log.info("  Memória utilizada: " .. tostring(stats.memory_usage or 0) .. " bytes")
                    
                    -- 🗂️ Coletar todos os dados do estado para export
                    local state_snapshot = {
                        metadata = {
                            export_time = os.date("%Y-%m-%d %H:%M:%S"),
                            total_keys = stats.total_keys,
                            script_name = "state-basics.lua"
                        },
                        data = {}
                    }
                    
                    -- 📝 Coletar dados específicos
                    local key_list = {
                        "app_name", "version", "user_count", "is_production",
                        "app_config", "execution_count", "last_execution_time",
                        "execution_log", "download_counter", "task_queue", "processing_stats"
                    }
                    
                    for _, key in ipairs(key_list) do
                        if state.exists(key) then
                            state_snapshot.data[key] = state.get(key)
                        end
                    end
                    
                    -- 💾 Exportar para JSON
                    local json_export = json.encode(state_snapshot)
                    fs.write("state_export.json", json_export)
                    log.info("💾 Estado exportado para: state_export.json")
                    
                    -- 📄 Criar relatório em Markdown
                    local report_content = string.format([[
# 📊 Relatório de Estado do Sloth Runner

**Gerado em:** %s  
**Script:** state-basics.lua  
**Total de chaves:** %d

## 🏗️ Configuração da Aplicação

- **Nome:** %s
- **Versão:** %s
- **Usuários:** %d
- **Ambiente de Produção:** %s

## 📈 Estatísticas de Execução

- **Execuções totais:** %d
- **Última execução:** %s
- **Downloads totais:** %d

## 📋 Fila de Tarefas

Total de tarefas na fila: %d

## 📊 Estatísticas de Processamento

- **Total processado:** %d
- **Sucessos:** %d  
- **Falhas:** %d
- **Taxa de sucesso:** %.1f%%

## 💡 Próximos Passos

1. Execute novamente para ver a persistência do estado
2. Experimente: `sloth-runner run examples/beginner/docker-basics.lua`
3. Explore exemplos intermediários em `examples/intermediate/`

---
*Gerado automaticamente pelo Sloth Runner 🦥*
]], 
                        state_snapshot.metadata.export_time,
                        state_snapshot.metadata.total_keys,
                        state.get("app_name", "N/A"),
                        state.get("version", "N/A"),
                        state.get("user_count", 0),
                        tostring(state.get("is_production", false)),
                        state.get("execution_count", 0),
                        os.date("%Y-%m-%d %H:%M:%S", state.get("last_execution_time", os.time())),
                        state.get("download_counter", 0),
                        #(state.get("task_queue", {})),
                        (state.get("processing_stats", {})).total_processed or 0,
                        (state.get("processing_stats", {})).successful or 0,
                        (state.get("processing_stats", {})).failed or 0,
                        ((state.get("processing_stats", {})).successful or 0) / math.max(((state.get("processing_stats", {})).total_processed or 1), 1) * 100
                    )
                    
                    fs.write("state_report.md", report_content)
                    log.info("📄 Relatório criado: state_report.md")
                    
                    -- 🎯 Dicas finais
                    log.info("\n🎯 Dicas do Estado:")
                    log.info("  💡 O estado persiste entre execuções")
                    log.info("  💡 Use state.exists() para verificar chaves")
                    log.info("  💡 state.increment() é ideal para contadores")
                    log.info("  💡 Estruturas complexas podem ser armazenadas")
                    log.info("  💡 Use state.delete() para limpeza")
                    
                    return true, "Relatório de estado criado com sucesso"
                end
            }
        }
    }
}