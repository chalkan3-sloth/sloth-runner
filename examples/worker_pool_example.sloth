-- worker_pool_example.sloth
-- Demonstrates worker pool pattern with goroutines
-- Perfect for rate-limited APIs or controlled concurrency

local process_with_pool = task("worker_pool_processing")
    :description("Process tasks using a worker pool with controlled concurrency")
    :command(function(this, params)
        local goroutine = require("goroutine")
        
        -- Create a worker pool with 5 concurrent workers
        log.info("ğŸ­ Creating worker pool with 5 workers...")
        goroutine.pool_create("data_processing", { workers = 5 })
        
        -- Generate 50 tasks to process
        local tasks = {}
        for i = 1, 50 do
            tasks[i] = {
                id = i,
                data = "Task #" .. i,
                priority = math.random(1, 3)
            }
        end
        
        log.info("ğŸ“‹ Submitting " .. #tasks .. " tasks to worker pool...")
        
        -- Submit all tasks to the pool
        local task_ids = {}
        for _, task_data in ipairs(tasks) do
            local task_id = goroutine.pool_submit("data_processing", function()
                -- Simulate processing work
                log.info("âš™ï¸ Processing " .. task_data.data .. " (priority: " .. task_data.priority .. ")")
                goroutine.sleep(100 * task_data.priority)  -- Higher priority = longer processing
                
                return {
                    id = task_data.id,
                    status = "completed",
                    processed_at = os.date("%H:%M:%S")
                }
            end)
            
            if task_id then
                table.insert(task_ids, task_id)
            end
        end
        
        log.info("â³ Waiting for all tasks to complete...")
        
        -- Wait for pool to complete all work
        goroutine.pool_wait("data_processing")
        
        -- Get pool statistics
        local stats = goroutine.pool_stats("data_processing")
        
        log.info("\nğŸ“Š Worker Pool Statistics:")
        log.info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        log.info("ğŸ‘· Workers: " .. stats.workers)
        log.info("âœ… Completed: " .. stats.completed)
        log.info("âŒ Failed: " .. stats.failed)
        log.info("âš¡ Active: " .. stats.active)
        log.info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        
        -- Close the pool
        goroutine.pool_close("data_processing")
        
        return true, "All tasks processed successfully", {
            total_tasks = #tasks,
            workers = stats.workers,
            completed = stats.completed,
            failed = stats.failed
        }
    end)
    :timeout("5m")
    :build()

-- Create workflow
workflow.define("worker_pool_workflow")
    :description("Process multiple tasks with a worker pool")
    :version("1.0.0")
    :tasks({ process_with_pool })
    :config({
        timeout = "10m"
    })
