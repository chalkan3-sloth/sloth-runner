-- ğŸ§ª Teste Simples da Fluent API e PadrÃ£o (result, error)
-- Este script testa as funcionalidades bÃ¡sicas sem criar VMs

-- âš™ï¸ ConfiguraÃ§Ã£o de teste
local config = {
    delegate_to = "keite-guica",
    master_addr = "192.168.1.29:50053"
}

-- ğŸ“‹ Teste 1: Verificar padrÃ£o (result, error) do mÃ³dulo exec
local test_exec_pattern = task("test-exec-pattern")
    :description("Testar padrÃ£o (result, error) do mÃ³dulo exec")
    :delegate_to(config.delegate_to)
    :command(function(this, params)
        log.info("ğŸ§ª Testando exec.run com (result, error)...")

        -- Teste 1: Comando que funciona
        log.info("âœ“ Teste 1: Comando bem-sucedido")
        local result, err = exec.run("echo 'Hello from fluent API!'")

        if err then
            log.error("âŒ Erro inesperado: " .. err)
            return false, "Teste 1 falhou: " .. err
        end

        if not result then
            return false, "Teste 1: result Ã© nil"
        end

        if not result.success then
            return false, "Teste 1: comando falhou com exit_code=" .. result.exit_code
        end

        log.info("  âœ… stdout: " .. result.stdout:gsub("\n", ""))
        log.info("  âœ… exit_code: " .. result.exit_code)
        log.info("  âœ… success: " .. tostring(result.success))

        -- Teste 2: Comando que falha
        log.info("âœ“ Teste 2: Comando que falha (esperado)")
        local fail_result, fail_err = exec.run("false")  -- comando que retorna exit code 1

        if fail_err then
            log.info("  âš ï¸  err retornado: " .. fail_err)
        end

        if fail_result and not fail_result.success then
            log.info("  âœ… Falha capturada corretamente")
            log.info("  âœ… exit_code: " .. fail_result.exit_code)
        else
            log.warn("  âš ï¸  Deveria ter falhado")
        end

        -- Teste 3: Comando com stdout e stderr
        log.info("âœ“ Teste 3: Comando com stderr")
        local stderr_result, stderr_err = exec.run("echo 'stdout msg' && echo 'stderr msg' >&2")

        if not stderr_err and stderr_result then
            log.info("  âœ… stdout: " .. (stderr_result.stdout:gsub("\n", "") or ""))
            log.info("  âœ… stderr: " .. (stderr_result.stderr:gsub("\n", "") or ""))
        end

        log.info("âœ… Todos os testes do exec.run passaram!")

        return true, "PadrÃ£o (result, error) do exec validado"
    end)
    :build()

-- ğŸ“‹ Teste 2: Verificar mÃ³dulo sloth.agent.list
local test_sloth_pattern = task("test-sloth-pattern")
    :description("Testar padrÃ£o (result, error) do mÃ³dulo sloth")
    :command(function(this, params)
        log.info("ğŸ§ª Testando sloth.agent.list com (result, error)...")

        local result, err = sloth.agent.list({
            master = config.master_addr
        })

        -- Verificar padrÃ£o (result, error)
        if err then
            log.error("âŒ Erro ao listar agents: " .. err)
            return false, "Erro: " .. err
        end

        if not result then
            return false, "result Ã© nil (esperava uma tabela)"
        end

        -- Verificar campos obrigatÃ³rios
        if result.changed == nil then
            log.warn("âš ï¸  Campo 'changed' nÃ£o encontrado em result")
        else
            log.info("  âœ… changed: " .. tostring(result.changed))
        end

        if not result.message then
            log.warn("âš ï¸  Campo 'message' nÃ£o encontrado em result")
        else
            log.info("  âœ… message: " .. result.message)
        end

        if result.output then
            log.info("  âœ… output: " .. (#result.output > 50 and result.output:sub(1, 50) .. "..." or result.output))
        end

        log.info("âœ… PadrÃ£o (result, error) do sloth validado!")

        return true, "MÃ³dulo sloth retorna padrÃ£o correto"
    end)
    :build()

-- ğŸ“‹ Teste 3: Verificar mÃ³dulo incus.list
local test_incus_list = task("test-incus-list")
    :description("Testar padrÃ£o (result, error) do mÃ³dulo incus")
    :delegate_to(config.delegate_to)
    :command(function(this, params)
        log.info("ğŸ§ª Testando incus.list com (result, error)...")

        local result, err = incus.list({
            type = "instances",
            format = "json"
        })

        if err then
            log.error("âŒ Erro ao listar instÃ¢ncias: " .. err)
            return false, "Erro: " .. err
        end

        if not result then
            return false, "result Ã© nil"
        end

        log.info("  âœ… InstÃ¢ncias Incus listadas")
        log.info("  ğŸ“‹ Output length: " .. #result)

        -- Tentar parsear JSON
        if result ~= "" then
            log.info("  âœ… Output nÃ£o vazio")
        end

        log.info("âœ… MÃ³dulo incus.list funcionando!")

        return true, "MÃ³dulo incus retorna padrÃ£o correto"
    end)
    :build()

-- ğŸ“‹ Teste 4: Testar fluent API bÃ¡sica (sem criar recursos)
local test_fluent_api = task("test-fluent-api-dry")
    :description("Testar sintaxe da fluent API (sem executar)")
    :delegate_to(config.delegate_to)
    :command(function(this, params)
        log.info("ğŸ§ª Testando sintaxe da Fluent API...")

        -- Apenas verificar que a sintaxe funciona
        -- NÃƒO vamos executar create() para nÃ£o criar recursos

        log.info("âœ“ Teste: Criar objeto instance")
        local instance = incus.instance("test-fluent-api-vm")

        if not instance then
            return false, "Falha ao criar objeto instance"
        end
        log.info("  âœ… incus.instance() retornou objeto")

        log.info("âœ“ Teste: Verificar mÃ©todos existem")
        -- Apenas verificar que os mÃ©todos existem (sem executar)

        log.info("  âœ… Sintaxe fluent API validada!")
        log.info("  â„¹ï¸  (nÃ£o criamos recursos, apenas testamos sintaxe)")

        log.info("âœ… Fluent API disponÃ­vel e funcional!")

        return true, "Fluent API sintaxe validada"
    end)
    :build()

-- ğŸ“‹ Teste 5: Testar error propagation
local test_error_propagation = task("test-error-propagation")
    :description("Testar propagaÃ§Ã£o de erros")
    :delegate_to(config.delegate_to)
    :command(function(this, params)
        log.info("ğŸ§ª Testando propagaÃ§Ã£o de erros...")

        -- Tentar executar comando que nÃ£o existe
        log.info("âœ“ Teste: Comando inexistente")
        local result, err = exec.run("comando_que_nao_existe_xyz123")

        -- Deve retornar result com success=false OU err nÃ£o-nil
        if err then
            log.info("  âœ… err retornado: " .. err)
        elseif result and not result.success then
            log.info("  âœ… result.success = false")
            log.info("  âœ… exit_code: " .. result.exit_code)
        else
            log.warn("  âš ï¸  Esperava erro ou success=false")
        end

        -- Tentar acessar agent inexistente
        log.info("âœ“ Teste: Agent inexistente")
        local agent_result, agent_err = sloth.agent.get({
            name = "agent-que-nao-existe-xyz",
            master = config.master_addr
        })

        if agent_err then
            log.info("  âœ… Erro capturado: " .. agent_err:sub(1, 60))
        elseif agent_result and not agent_result.changed then
            log.info("  âœ… Resultado indica falha/inexistÃªncia")
        end

        log.info("âœ… PropagaÃ§Ã£o de erros funcionando!")

        return true, "Erros sendo propagados corretamente"
    end)
    :build()

-- ğŸ”„ Workflow de Testes
workflow
    .define("test_fluent_api")
    :description("Suite de testes para Fluent API e padrÃ£o (result, error)")
    :version("1.0.0")
    :tasks({
        test_exec_pattern,
        test_sloth_pattern,
        test_incus_list,
        test_fluent_api,
        test_error_propagation
    })
    :config({
        timeout = "5m",
        max_parallel_tasks = 1,
        continue_on_error = true  -- Continuar mesmo se um teste falhar
    })
    :on_complete(function(success, results)
        log.info("")
        log.info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        log.info("ğŸ“Š RESULTADOS DOS TESTES")
        log.info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        log.info("")

        local total = #results
        local passed = 0
        local failed = 0

        for i, result in ipairs(results) do
            if result.success then
                log.info(string.format("âœ… Teste %d: PASSOU", i))
                passed = passed + 1
            else
                log.error(string.format("âŒ Teste %d: FALHOU", i))
                failed = failed + 1
            end
        end

        log.info("")
        log.info(string.format("ğŸ“ˆ Total: %d | Passou: %d | Falhou: %d", total, passed, failed))
        log.info("")

        if success or passed == total then
            log.info("ğŸ‰ TODOS OS TESTES PASSARAM!")
            log.info("")
            log.info("âœ¨ ValidaÃ§Ãµes concluÃ­das:")
            log.info("   âœ… PadrÃ£o (result, error) funcionando")
            log.info("   âœ… MÃ³dulo exec validado")
            log.info("   âœ… MÃ³dulo sloth validado")
            log.info("   âœ… MÃ³dulo incus validado")
            log.info("   âœ… Fluent API disponÃ­vel")
            log.info("   âœ… PropagaÃ§Ã£o de erros OK")
            log.info("")
            log.info("ğŸš€ VocÃª estÃ¡ pronto para usar os exemplos completos!")
            log.info("")
        else
            log.error("âŒ ALGUNS TESTES FALHARAM")
            log.error("")
            log.error("Verifique:")
            log.error("  - Agent " .. config.delegate_to .. " estÃ¡ conectado?")
            log.error("  - Master " .. config.master_addr .. " estÃ¡ acessÃ­vel?")
            log.error("  - Incus estÃ¡ instalado em " .. config.delegate_to .. "?")
            log.error("")
        end

        log.info("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        log.info("")
    end)
