-- ü¶• Bootstrap Moderno de Agent com Fluent API
-- Este exemplo demonstra o uso da fluent API do m√≥dulo Incus e o padr√£o (result, error)

-- ‚öôÔ∏è Configura√ß√£o
local config = {
    vm_name = "agent-keite-01",
    image = "images:archlinux",
    delegate_to = "192.168.1.17:50051",  -- IP:porta do agent keite-guica
    master_addr = "192.168.1.29:50053",
    host_ip = "192.168.1.17",
    ssh_port = 50060,
    agent_port = 50060,
    memory = "2GB",
    cpus = 2
}

-- Ler chave SSH local do Mac (antes de qualquer delega√ß√£o)
-- Esta chave ser√° usada pela task install-agent que roda localmente
local local_ssh_key_path = os.getenv("HOME") .. "/.ssh/id_ed25519.pub"
local local_ssh_key_file = io.open(local_ssh_key_path, "r")
local mac_ssh_key = ""

if local_ssh_key_file then
    mac_ssh_key = local_ssh_key_file:read("*all"):gsub("\n", "")
    local_ssh_key_file:close()
    log.info("üìã Chave SSH local lida: " .. local_ssh_key_path .. " (" .. #mac_ssh_key .. " bytes)")
else
    log.warn("‚ö†Ô∏è  Chave SSH local n√£o encontrada: " .. local_ssh_key_path)
    log.warn("   A task install-agent pode falhar se a chave n√£o estiver na VM")
end

-- üìã Tarefa 1: Criar e configurar VM usando Fluent API
local create_vm = task("create-vm-fluent")
    :description("Criar VM Arch Linux usando fluent API")
    :delegate_to(config.delegate_to)
    :command(function(this, params)
        log.info("üöÄ Criando VM com fluent API: " .. config.vm_name)

        -- Demonstra√ß√£o da Fluent API - encadeamento elegante
        local result, err = incus.instance(config.vm_name)
            :image(config.image)
            :config({
                ["limits.memory"] = config.memory,
                ["limits.cpu"] = tostring(config.cpus)
            })
            :profile("default")
            :ephemeral(false)
            :launch()  -- launch cria e inicia em uma opera√ß√£o

        -- ‚úÖ Novo padr√£o: sempre verificar (result, error)
        if err then
            log.error("‚ùå Erro ao criar VM: " .. err)
            return false, "Falha ao criar VM: " .. err
        end

        log.info("‚úÖ VM criada e iniciada com sucesso!")
        log.info("   Output: " .. (result or ""))

        -- Aguardar VM inicializar completamente
        log.info("‚è≥ Aguardando VM inicializar...")
        local sleep_result, sleep_err = exec.run("sleep 10")
        if sleep_err then
            log.warn("‚ö†Ô∏è  Aviso no sleep: " .. sleep_err)
        end

        return true, "VM " .. config.vm_name .. " criada e rodando"
    end)
    :build()

-- üìã Tarefa 2: Configurar SSH com checagem de erros
local setup_ssh = task("setup-ssh-modern")
    :description("Configurar SSH usando novo padr√£o de erros")
    :delegate_to(config.delegate_to)
    :command(function(this, params)
        log.info("üîê Configurando SSH com tratamento de erros")

        -- Obter chave SSH p√∫blica do agent remoto
        local key_result, key_err = exec.run("cat ~/.ssh/id_rsa.pub")
        if key_err then
            return false, "Erro ao ler chave SSH: " .. key_err
        end

        if not key_result.success then
            return false, "Falha ao obter chave SSH: " .. key_result.stderr
        end

        local ssh_pub_key_remote = key_result.stdout:gsub("\n", "")
        if ssh_pub_key_remote == "" then
            return false, "Chave SSH p√∫blica do agent est√° vazia"
        end

        log.info("üìã Chave SSH do agent remoto obtida (" .. #ssh_pub_key_remote .. " bytes)")

        -- Usar a chave SSH local do Mac da vari√°vel global
        if mac_ssh_key and mac_ssh_key ~= "" then
            log.info("üìã Chave SSH local do Mac obtida (" .. #mac_ssh_key .. " bytes)")
        else
            log.warn("‚ö†Ô∏è  Chave SSH local do Mac n√£o dispon√≠vel")
        end

        -- Atualizar sistema
        log.info("üì¶ Atualizando sistema...")
        local update_result, update_err = incus.exec({
            instance = config.vm_name,
            command = "pacman -Sy --noconfirm"
        })

        if update_err then
            return false, "Erro ao atualizar sistema: " .. update_err
        end

        log.info("‚úÖ Sistema atualizado")

        -- Instalar pacotes necess√°rios
        log.info("üì¶ Instalando openssh e sudo...")
        local install_result, install_err = incus.exec({
            instance = config.vm_name,
            command = "pacman -S --noconfirm openssh sudo wget curl"
        })

        if install_err then
            return false, "Erro ao instalar pacotes: " .. install_err
        end

        log.info("‚úÖ Pacotes instalados")

        -- Configurar diret√≥rio SSH
        local commands = {
            "mkdir -p /root/.ssh",
            "chmod 700 /root/.ssh",
            string.format('echo "%s" > /root/.ssh/authorized_keys', ssh_pub_key_remote)
        }

        -- Adicionar chave local do Mac se dispon√≠vel
        if mac_ssh_key and mac_ssh_key ~= "" then
            table.insert(commands, string.format('echo "%s" >> /root/.ssh/authorized_keys', mac_ssh_key))
            log.info("üìù Adicionando chave SSH local do Mac √† VM")
        else
            log.warn("‚ö†Ô∏è  N√£o foi poss√≠vel adicionar chave do Mac - install-agent pode falhar")
        end

        table.insert(commands, "chmod 600 /root/.ssh/authorized_keys")

        for _, cmd in ipairs(commands) do
            local result, err = incus.exec({
                instance = config.vm_name,
                command = cmd
            })
            if err then
                return false, "Erro ao executar: " .. cmd .. " - " .. err
            end
        end

        if mac_ssh_key and mac_ssh_key ~= "" then
            log.info("‚úÖ Chaves SSH configuradas (agent remoto + Mac local)")
        else
            log.info("‚úÖ Chave SSH configurada (apenas agent remoto)")
            log.warn("‚ö†Ô∏è  A task install-agent pode falhar pois a chave do Mac n√£o est√° na VM")
        end

        -- Configurar sshd
        local sshd_commands = {
            "sed -i 's/#PermitRootLogin.*/PermitRootLogin yes/' /etc/ssh/sshd_config",
            "sed -i 's/#PubkeyAuthentication.*/PubkeyAuthentication yes/' /etc/ssh/sshd_config",
            "systemctl enable sshd",
            "systemctl start sshd"
        }

        for _, cmd in ipairs(sshd_commands) do
            local result, err = incus.exec({
                instance = config.vm_name,
                command = cmd
            })
            if err then
                log.warn("‚ö†Ô∏è  Aviso ao configurar sshd: " .. err)
            end
        end

        log.info("‚úÖ SSH daemon configurado")

        return true, "SSH configurado com sucesso"
    end)
    :build()

-- üìã Tarefa 3: Criar proxy device para acesso externo usando Fluent API
local create_proxy = task("create-proxy-modern")
    :description("Criar proxy device usando fluent API")
    :delegate_to(config.delegate_to)
    :command(function(this, params)
        log.info("üåê Criando proxy devices com Fluent API...")

        -- Obter IP da VM
        local ip_cmd = string.format("incus list %s -c 4 -f csv", config.vm_name)
        local ip_result, ip_err = exec.run(ip_cmd)

        if ip_err then
            return false, "Erro ao obter IP da VM: " .. ip_err
        end

        if not ip_result.success then
            return false, "Falha ao listar VMs: " .. ip_result.stderr
        end

        local vm_ip = ip_result.stdout:match("(%d+%.%d+%.%d+%.%d+)")
        if not vm_ip then
            return false, "N√£o foi poss√≠vel extrair IP da VM do output: " .. ip_result.stdout
        end

        log.info("üìç VM IP: " .. vm_ip)

        -- ‚ú® Usar Fluent API para criar proxies
        log.info("üîå Criando proxies com :proxy()...")

        -- Criar proxy SSH usando fluent API
        local instance, err = incus.instance(config.vm_name)
            :proxy("ssh-proxy",
                   string.format("tcp:0.0.0.0:%d", config.ssh_port),
                   string.format("tcp:%s:22", vm_ip))

        if err then
            log.warn("‚ö†Ô∏è  Aviso ao criar proxy SSH: " .. err)
        else
            log.info(string.format("‚úÖ Proxy SSH: 0.0.0.0:%d -> %s:22", config.ssh_port, vm_ip))
        end

        -- Criar proxy Agent usando fluent API
        instance, err = incus.instance(config.vm_name)
            :proxy("agent-proxy",
                   string.format("tcp:0.0.0.0:%d", config.agent_port),
                   string.format("tcp:%s:%d", vm_ip, config.agent_port))

        if err then
            log.warn("‚ö†Ô∏è  Aviso ao criar proxy agent: " .. err)
        else
            log.info(string.format("‚úÖ Proxy Agent: 0.0.0.0:%d -> %s:%d", config.agent_port, vm_ip, config.agent_port))
        end

        return true, "Proxies configurados com sucesso usando Fluent API"
    end)
    :build()

-- üìã Tarefa 4: Testar SSH com retry
local test_ssh = task("test-ssh-retry")
    :description("Testar SSH com retry autom√°tico")
    :delegate_to(config.delegate_to)
    :command(function(this, params)
        log.info("üß™ Testando conex√£o SSH...")

        -- Aguardar SSH estar pronto
        log.info("‚è≥ Aguardando SSH inicializar...")
        exec.run("sleep 8")

        -- Tentar conectar com retry
        local max_retries = 5
        local retry_delay = 3

        for attempt = 1, max_retries do
            log.info(string.format("üîå Tentativa %d/%d de conectar via SSH...", attempt, max_retries))

            local ssh_cmd = string.format(
                'ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10 -p %d root@localhost "hostname"',
                config.ssh_port
            )

            local result, err = exec.run(ssh_cmd)

            if not err and result.success then
                local hostname = result.stdout:gsub("\n", "")
                log.info("‚úÖ SSH conectado! Hostname: " .. hostname)
                return true, "SSH testado com sucesso"
            end

            if attempt < max_retries then
                log.info(string.format("‚è≥ Aguardando %ds antes da pr√≥xima tentativa...", retry_delay))
                exec.run(string.format("sleep %d", retry_delay))
            end
        end

        return false, string.format("SSH n√£o respondeu ap√≥s %d tentativas", max_retries)
    end)
    :build()

-- üìã Tarefa 5: Instalar Agent usando m√≥dulo sloth (novo padr√£o)
local install_agent = task("install-agent-modern")
    :description("Instalar agent usando novo padr√£o (result, error)")
    :command(function(this, params)
        log.info("ü¶• Instalando sloth-runner agent...")

        -- ‚úÖ Novo padr√£o: sloth.agent.install retorna (result, error)
        local result, err = sloth.agent.install({
            name = config.vm_name,
            ssh_host = config.host_ip,
            ssh_user = "root",
            ssh_port = tostring(config.ssh_port),
            ssh_key = os.getenv("HOME") .. "/.ssh/id_ed25519",
            master = config.master_addr,
            bind_address = "0.0.0.0",
            port = tostring(config.agent_port),
            report_address = string.format("%s:%d", config.host_ip, config.agent_port)
        })

        -- Verificar erro
        if err then
            log.error("‚ùå Erro ao instalar agent")
            log.error("   Mensagem: " .. err)
            return false, "Falha ao instalar agent: " .. err
        end

        -- Verificar resultado (nil significa erro mesmo sem err)
        if not result then
            return false, "Resultado nil ao instalar agent"
        end

        -- ‚úÖ Verificar se houve mudan√ßa (idempot√™ncia)
        if result.changed then
            log.info("‚úÖ Agent instalado com sucesso!")
            log.info("   Mensagem: " .. result.message)
            if result.output then
                log.info("   Output: " .. result.output)
            end
        else
            log.info("‚ÑπÔ∏è  " .. result.message)
            log.info("   (Agent j√° estava instalado - idempotente)")
        end

        return true, result.message, {changed = result.changed}
    end)
    :build()

-- üìã Tarefa 6: Verificar agent conectado
local verify_agent = task("verify-agent-modern")
    :description("Verificar agent usando novo padr√£o")
    :command(function(this, params)
        log.info("üîç Verificando agent no master...")

        -- Aguardar agent conectar
        log.info("‚è≥ Aguardando agent estabelecer conex√£o...")
        exec.run("sleep 10")

        -- ‚úÖ Novo padr√£o: sloth.agent.list retorna (result, error)
        local result, err = sloth.agent.list({
            master = config.master_addr
        })

        if err then
            return false, "Erro ao listar agents: " .. err
        end

        if not result then
            return false, "Resultado nil ao listar agents"
        end

        log.info("üìã Agents registrados no master:")
        log.info(result.output or "(sem output)")

        -- Verificar se nosso agent est√° na lista
        if result.output and result.output:match(config.vm_name) then
            log.info("‚úÖ Agent " .. config.vm_name .. " encontrado e ativo!")

            -- Obter detalhes do agent
            local details, details_err = sloth.agent.get({
                name = config.vm_name,
                master = config.master_addr
            })

            if not details_err and details then
                log.info("üìä Detalhes do agent:")
                log.info(details.output or "(sem detalhes)")
            end

            return true, "Agent verificado e conectado"
        else
            return false, "Agent " .. config.vm_name .. " n√£o encontrado na lista"
        end
    end)
    :build()

-- üìã Tarefa 7: Teste de execu√ß√£o remota
local test_execution = task("test-remote-execution")
    :description("Testar execu√ß√£o remota no novo agent")
    :delegate_to(config.vm_name)
    :command(function(this, params)
        log.info("üß™ Testando execu√ß√£o remota...")

        -- Executar comandos de teste
        local tests = {
            {name = "Hostname", cmd = "hostname"},
            {name = "Kernel", cmd = "uname -r"},
            {name = "Uptime", cmd = "uptime"},
            {name = "Mem√≥ria", cmd = "free -h | grep Mem"},
            {name = "Disco", cmd = "df -h /"}
        }

        for _, test in ipairs(tests) do
            local result, err = exec.run(test.cmd)

            if err then
                log.warn("‚ö†Ô∏è  " .. test.name .. " falhou: " .. err)
            elseif result.success then
                local output = result.stdout:gsub("\n", " "):gsub("%s+", " ")
                log.info("‚úÖ " .. test.name .. ": " .. output)
            else
                log.warn("‚ö†Ô∏è  " .. test.name .. " exit code: " .. result.exit_code)
            end
        end

        log.info("üéâ Todos os testes conclu√≠dos!")

        return true, "Execu√ß√£o remota funcionando perfeitamente"
    end)
    :build()

-- üîÑ Workflow Principal
workflow
    .define("modern_incus_bootstrap")
    :description("Bootstrap moderno de agent com fluent API e (result, error)")
    :version("2.0.0")
    :tasks({
        create_vm,
        setup_ssh,
        create_proxy,
        test_ssh,
        install_agent,
        verify_agent,
        test_execution
    })
    :config({
        timeout = "30m",
        max_parallel_tasks = 1,
        continue_on_error = false
    })
    :on_complete(function(success, results)
        log.info("")
        log.info("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")

        if success then
            log.info("üéâ BOOTSTRAP CONCLU√çDO COM SUCESSO!")
            log.info("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
            log.info("")
            log.info("üìã Configura√ß√£o:")
            log.info("   VM: " .. config.vm_name)
            log.info("   Imagem: " .. config.image)
            log.info("   Mem√≥ria: " .. config.memory)
            log.info("   CPUs: " .. config.cpus)
            log.info("")
            log.info("üåê Acesso:")
            log.info("   SSH: ssh -p " .. config.ssh_port .. " root@" .. config.host_ip)
            log.info("   Agent: " .. config.vm_name .. " @ " .. config.master_addr)
            log.info("")
            log.info("üöÄ Uso:")
            log.info("   sloth-runner run <task> --delegate-to " .. config.vm_name)
            log.info("")
            log.info("‚ú® Features demonstradas:")
            log.info("   ‚úÖ Fluent API para Incus")
            log.info("   ‚úÖ Padr√£o (result, error) consistente")
            log.info("   ‚úÖ Tratamento de erros robusto")
            log.info("   ‚úÖ Opera√ß√µes idempotentes")
            log.info("   ‚úÖ Delega√ß√£o remota")
            log.info("")
        else
            log.error("‚ùå BOOTSTRAP FALHOU")
            log.info("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
            log.error("")
            log.error("Verifique os logs acima para identificar o erro.")
            log.error("")
            log.error("üõ†Ô∏è  Comandos √∫teis para debug:")
            log.error("   incus list " .. config.vm_name)
            log.error("   incus console " .. config.vm_name)
            log.error("   ssh -p " .. config.ssh_port .. " root@" .. config.host_ip)
            log.error("")
        end

        log.info("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
        log.info("")
    end)
